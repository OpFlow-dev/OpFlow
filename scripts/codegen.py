#  ----------------------------------------------------------------------------
#
#  Copyright (c) 2019 - 2021  by the OpFlow developers
#
#  This file is part of OpFlow.
#
#  OpFlow is free software and is distributed under the MPL v2.0 license.
#  The full text of the license can be found in the file LICENSE at the top
#  level directory of OpFlow.
#
#  ----------------------------------------------------------------------------

common_header = '''//  ----------------------------------------------------------------------------
//
//  Copyright (c) 2019 - 2021  by the OpFlow developers
//
//  This file is part of OpFlow.
//
//  OpFlow is free software and is distributed under the MPL v2.0 license.
//  The full text of the license can be found in the file LICENSE at the top
//  level directory of OpFlow.
//
//  ----------------------------------------------------------------------------
//  Note: This file is generated by script in "script/codegen.py". Modify the 
//        script rather than this file if you need to.
//  ----------------------------------------------------------------------------
'''


def concat_repeat(gen, de, s, e):
    ret = ""
    for j in range(s, e):
        ret += gen(j) + de
    ret += gen(e)
    return ret


def gen_equation_holder_hpp(n=10):
    with open("./EquationHolder.hpp", 'w') as f:
        f.write(common_header)
        f.write('''
#ifndef OPFLOW_EQUATIONHOLDER_HPP
#define OPFLOW_EQUATIONHOLDER_HPP

#include "Core/Meta.hpp"
#include <functional>

namespace OpFlow {
    template <typename ... E>
    struct EqnHolder;
                
        ''')
        # generate template with 1...n equations
        for i in range(1, n + 1):
            f.write('''template <{}, {}>
struct EqnHolder<{}, {}> {{
    {}
    {}
    {}
    {}
    
    EqnHolder({}, {}) : {}, {} {{}}
}};
    
    auto makeEqnHolder({}, {}) {{
        return EqnHolder<{}, {}>({}, {});
    }}
    
            '''.format(
                concat_repeat(lambda j: "typename E{}".format(j), ",", 1, i),
                concat_repeat(lambda j: "typename T{}".format(j), ",", 1, i),
                concat_repeat(lambda j: "E{}".format(j), ",", 1, i),
                concat_repeat(lambda j: "T{}".format(j), ",", 1, i),
                concat_repeat(lambda j: "T{}* target{};".format(j, j), "\n", 1, i),
                concat_repeat(lambda j: "using st_field_type{} = Meta::RealType<decltype(target{}->getStencilField())>;".format(j, j), "\n", 1, i),
                concat_repeat(lambda j: "using getter_type{} = std::function<E{}({})>;".format(j, j, concat_repeat(lambda k: "st_field_type{}&".format(k), ",", 1, i)), "\n", 1, i),
                concat_repeat(lambda j: "getter_type{} getter{};".format(j, j), "\n", 1, i),
                concat_repeat(lambda j: "getter_type{} getter{}".format(j, j), ",", 1, i),
                concat_repeat(lambda j : "T{}& target{}".format(j, j), ",", 1, i),
                concat_repeat(lambda j: "getter{}(getter{})".format(j, j), ",", 1, i),
                concat_repeat(lambda j: "target{}(&target{})".format(j, j), ",", 1, i),
                concat_repeat(lambda j: "auto&& func{}".format(j), ",", 1, i),
                concat_repeat(lambda j: "auto&& target{}".format(j), ",", 1, i),
                concat_repeat(lambda j: "Meta::RealType<decltype(func{}({}))>".format(j, concat_repeat(lambda k: "target{}.getStencilField()".format(k), ",", 1, i)), ",", 1, i),
                concat_repeat(lambda j: "Meta::RealType<decltype(target{})>".format(j), ",", 1, i),
                concat_repeat(lambda j: "func{}".format(j), ",", 1, i),
                concat_repeat(lambda j: "target{}".format(j), ",", 1, i)
            ))

        f.write("}\n\n#endif")


if __name__ == "__main__":
    gen_equation_holder_hpp()
