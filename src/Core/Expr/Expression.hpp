//  ----------------------------------------------------------------------------
//
//  Copyright (c) 2019 - 2022 by the OpFlow developers
//
//  This file is part of OpFlow.
//
//  OpFlow is free software and is distributed under the MPL v2.0 license.
//  The full text of the license can be found in the file LICENSE at the top
//  level directory of OpFlow.
//
//  ----------------------------------------------------------------------------
//  Note: This file is generated by script in "script/codegen.py". Modify the
//        script rather than this file if you need to.
//  ----------------------------------------------------------------------------

#ifndef OPFLOW_EXPRESSION_HPP
#define OPFLOW_EXPRESSION_HPP

#include "Core/Expr/Expr.hpp"
#include "Core/Expr/ExprTrait.hpp"
#include "Core/Operator/Operator.hpp"

namespace OpFlow {
    template <typename Op, ExprType... Args>
    struct Expression;

    template <typename Op>
    requires(!ExprType<Op>) struct Expression<Op> : ResultType<Op>::type {
        friend Expr<Expression<Op>>;
        Expression() = default;

    protected:
        OPFLOW_STRONG_INLINE auto evalAtImpl_final(auto&& i) const {
            OP_STACK_PUSH("Eval {} at {}", this->getName(), i);
            auto ret = Op::eval(OP_PERFECT_FOWD(i));
            OP_STACK_APPEND(" = {}", ret);
            OP_STACK_POP;
            return ret;
        }
        OPFLOW_STRONG_INLINE auto evalSafeAtImpl_final(auto&& i) const {
            OP_STACK_PUSH("Eval {} at {}", this->getName(), i);
            auto ret = Op::eval_safe(std::forward<decltype(i)>(i));
            OP_STACK_APPEND(" = {}", ret);
            OP_STACK_POP;
            return ret;
        }
        void prepareImpl_final() const { Op::prepare(*this); }
        bool containsImpl_final(auto&&...) const { return false; }
    };

#define DEFINE_EVAL_OPS(...)                                                                                 \
    OPFLOW_STRONG_INLINE auto evalAtImpl_final(auto&& i) const {                                             \
        OP_STACK_PUSH("Eval {} at {}", this->getName(), i);                                                  \
        auto ret = Op::eval(__VA_ARGS__, OP_PERFECT_FOWD(i));                                                \
        OP_STACK_APPEND(" = {}", ret);                                                                       \
        OP_STACK_POP;                                                                                        \
        return ret;                                                                                          \
    }                                                                                                        \
    OPFLOW_STRONG_INLINE auto evalSafeAtImpl_final(auto&& i) const {                                         \
        OP_STACK_PUSH("Eval {} at {}", this->getName(), i);                                                  \
        auto ret = Op::eval_safe(__VA_ARGS__, std::forward<decltype(i)>(i));                                 \
        OP_STACK_APPEND(" = {}", ret);                                                                       \
        OP_STACK_POP;                                                                                        \
        return ret;                                                                                          \
    }

    template <typename Op, ExprType Arg>
    struct Expression<Op, Arg> : ResultType<Op, Arg>::type {
        friend Expr<Expression<Op, Arg>>;
        // note: cannot use auto&& arg1 here because it shadows ctors
        explicit Expression(Arg&& arg1) : arg1(OP_PERFECT_FOWD(arg1)) {}
        explicit Expression(Arg& arg1) : arg1(arg1) {}
        explicit Expression(const Arg& arg1) : arg1(arg1) {}
        Expression(const Expression& e) : ResultType<Op, Arg>::type(e), arg1(e.arg1) {}
        Expression(Expression&& e) noexcept : ResultType<Op, Arg>::type(std::move(e)), arg1(e.arg1) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const { return arg1.contains(t); }

        DEFINE_EVAL_OPS(arg1)
    public:
        typename internal::ExprProxy<Arg>::type arg1;
    };
    template <typename Op, typename Arg1, typename Arg2>
    struct Expression<Op, Arg1, Arg2> : ResultType<Op, Arg1, Arg2>::type {
        friend Expr<Expression<Op, Arg1, Arg2>>;
        explicit Expression(auto&& arg1, auto&& arg2)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)) {}
        Expression(const Expression& e) : ResultType<Op, Arg1, Arg2>::type(e), arg1(e.arg1), arg2(e.arg2) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2>::type(std::move(e)), arg1(e.arg1), arg2(e.arg2) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const { return arg1.contains(t) || arg2.contains(t); }

        DEFINE_EVAL_OPS(arg1, arg2)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3>
    struct Expression<Op, Arg1, Arg2, Arg3> : ResultType<Op, Arg1, Arg2, Arg3>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3>::type(e), arg1(e.arg1), arg2(e.arg2), arg3(e.arg3) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3>::type(std::move(e)), arg1(e.arg1), arg2(e.arg2), arg3(e.arg3) {
        }

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4> : ResultType<Op, Arg1, Arg2, Arg3, Arg4>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4>::type(e), arg1(e.arg1), arg2(e.arg2), arg3(e.arg3),
              arg4(e.arg4) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4>::type(std::move(e)), arg1(e.arg1), arg2(e.arg2),
              arg3(e.arg3), arg4(e.arg4) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5> : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5>::type(e), arg1(e.arg1), arg2(e.arg2), arg3(e.arg3),
              arg4(e.arg4), arg5(e.arg5) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5>::type(std::move(e)), arg1(e.arg1), arg2(e.arg2),
              arg3(e.arg3), arg4(e.arg4), arg5(e.arg5) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>
        : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>::type(e), arg1(e.arg1), arg2(e.arg2),
              arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>::type(std::move(e)), arg1(e.arg1),
              arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7>
        : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7>::type(e), arg1(e.arg1), arg2(e.arg2),
              arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6), arg7(e.arg7) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7>::type(std::move(e)), arg1(e.arg1),
              arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6), arg7(e.arg7) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7, typename Arg8>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8>
        : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7, auto&& arg8)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)), arg8(OP_PERFECT_FOWD(arg8)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8>::type(e), arg1(e.arg1),
              arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6), arg7(e.arg7),
              arg8(e.arg8) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8>::type(std::move(e)),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            arg8.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t) || arg8.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
        typename internal::ExprProxy<Arg8>::type arg8;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7, typename Arg8, typename Arg9>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9>
        : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7, auto&& arg8, auto&& arg9)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)), arg8(OP_PERFECT_FOWD(arg8)), arg9(OP_PERFECT_FOWD(arg9)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9>::type(e), arg1(e.arg1),
              arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6), arg7(e.arg7),
              arg8(e.arg8), arg9(e.arg9) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9>::type(std::move(e)),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            arg8.prepare();
            arg9.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t) || arg8.contains(t)
                   || arg9.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
        typename internal::ExprProxy<Arg8>::type arg8;
        typename internal::ExprProxy<Arg9>::type arg9;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10>
        : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7, auto&& arg8, auto&& arg9, auto&& arg10)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)), arg8(OP_PERFECT_FOWD(arg8)), arg9(OP_PERFECT_FOWD(arg9)),
              arg10(OP_PERFECT_FOWD(arg10)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10>::type(e),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10>::type(std::move(e)),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            arg8.prepare();
            arg9.prepare();
            arg10.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t) || arg8.contains(t)
                   || arg9.contains(t) || arg10.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
        typename internal::ExprProxy<Arg8>::type arg8;
        typename internal::ExprProxy<Arg9>::type arg9;
        typename internal::ExprProxy<Arg10>::type arg10;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10, typename Arg11>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11>
        : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7, auto&& arg8, auto&& arg9, auto&& arg10, auto&& arg11)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)), arg8(OP_PERFECT_FOWD(arg8)), arg9(OP_PERFECT_FOWD(arg9)),
              arg10(OP_PERFECT_FOWD(arg10)), arg11(OP_PERFECT_FOWD(arg11)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11>::type(e),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11>::type(
                    std::move(e)),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            arg8.prepare();
            arg9.prepare();
            arg10.prepare();
            arg11.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t) || arg8.contains(t)
                   || arg9.contains(t) || arg10.contains(t) || arg11.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
        typename internal::ExprProxy<Arg8>::type arg8;
        typename internal::ExprProxy<Arg9>::type arg9;
        typename internal::ExprProxy<Arg10>::type arg10;
        typename internal::ExprProxy<Arg11>::type arg11;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10, typename Arg11,
              typename Arg12>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12>
        : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12>::type {
        friend Expr<
                Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7, auto&& arg8, auto&& arg9, auto&& arg10, auto&& arg11, auto&& arg12)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)), arg8(OP_PERFECT_FOWD(arg8)), arg9(OP_PERFECT_FOWD(arg9)),
              arg10(OP_PERFECT_FOWD(arg10)), arg11(OP_PERFECT_FOWD(arg11)), arg12(OP_PERFECT_FOWD(arg12)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12>::type(
                    e),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12>::type(
                    std::move(e)),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            arg8.prepare();
            arg9.prepare();
            arg10.prepare();
            arg11.prepare();
            arg12.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t) || arg8.contains(t)
                   || arg9.contains(t) || arg10.contains(t) || arg11.contains(t) || arg12.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
        typename internal::ExprProxy<Arg8>::type arg8;
        typename internal::ExprProxy<Arg9>::type arg9;
        typename internal::ExprProxy<Arg10>::type arg10;
        typename internal::ExprProxy<Arg11>::type arg11;
        typename internal::ExprProxy<Arg12>::type arg12;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10, typename Arg11,
              typename Arg12, typename Arg13>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13>
        : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12,
                     Arg13>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12,
                               Arg13>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7, auto&& arg8, auto&& arg9, auto&& arg10, auto&& arg11, auto&& arg12,
                            auto&& arg13)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)), arg8(OP_PERFECT_FOWD(arg8)), arg9(OP_PERFECT_FOWD(arg9)),
              arg10(OP_PERFECT_FOWD(arg10)), arg11(OP_PERFECT_FOWD(arg11)), arg12(OP_PERFECT_FOWD(arg12)),
              arg13(OP_PERFECT_FOWD(arg13)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12,
                         Arg13>::type(e),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12,
                         Arg13>::type(std::move(e)),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            arg8.prepare();
            arg9.prepare();
            arg10.prepare();
            arg11.prepare();
            arg12.prepare();
            arg13.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t) || arg8.contains(t)
                   || arg9.contains(t) || arg10.contains(t) || arg11.contains(t) || arg12.contains(t)
                   || arg13.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
        typename internal::ExprProxy<Arg8>::type arg8;
        typename internal::ExprProxy<Arg9>::type arg9;
        typename internal::ExprProxy<Arg10>::type arg10;
        typename internal::ExprProxy<Arg11>::type arg11;
        typename internal::ExprProxy<Arg12>::type arg12;
        typename internal::ExprProxy<Arg13>::type arg13;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10, typename Arg11,
              typename Arg12, typename Arg13, typename Arg14>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                      Arg14> : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10,
                                          Arg11, Arg12, Arg13, Arg14>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12,
                               Arg13, Arg14>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7, auto&& arg8, auto&& arg9, auto&& arg10, auto&& arg11, auto&& arg12,
                            auto&& arg13, auto&& arg14)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)), arg8(OP_PERFECT_FOWD(arg8)), arg9(OP_PERFECT_FOWD(arg9)),
              arg10(OP_PERFECT_FOWD(arg10)), arg11(OP_PERFECT_FOWD(arg11)), arg12(OP_PERFECT_FOWD(arg12)),
              arg13(OP_PERFECT_FOWD(arg13)), arg14(OP_PERFECT_FOWD(arg14)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14>::type(e),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14>::type(std::move(e)),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            arg8.prepare();
            arg9.prepare();
            arg10.prepare();
            arg11.prepare();
            arg12.prepare();
            arg13.prepare();
            arg14.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t) || arg8.contains(t)
                   || arg9.contains(t) || arg10.contains(t) || arg11.contains(t) || arg12.contains(t)
                   || arg13.contains(t) || arg14.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                        arg14)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
        typename internal::ExprProxy<Arg8>::type arg8;
        typename internal::ExprProxy<Arg9>::type arg9;
        typename internal::ExprProxy<Arg10>::type arg10;
        typename internal::ExprProxy<Arg11>::type arg11;
        typename internal::ExprProxy<Arg12>::type arg12;
        typename internal::ExprProxy<Arg13>::type arg13;
        typename internal::ExprProxy<Arg14>::type arg14;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10, typename Arg11,
              typename Arg12, typename Arg13, typename Arg14, typename Arg15>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                      Arg14, Arg15> : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
                                                 Arg10, Arg11, Arg12, Arg13, Arg14, Arg15>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12,
                               Arg13, Arg14, Arg15>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7, auto&& arg8, auto&& arg9, auto&& arg10, auto&& arg11, auto&& arg12,
                            auto&& arg13, auto&& arg14, auto&& arg15)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)), arg8(OP_PERFECT_FOWD(arg8)), arg9(OP_PERFECT_FOWD(arg9)),
              arg10(OP_PERFECT_FOWD(arg10)), arg11(OP_PERFECT_FOWD(arg11)), arg12(OP_PERFECT_FOWD(arg12)),
              arg13(OP_PERFECT_FOWD(arg13)), arg14(OP_PERFECT_FOWD(arg14)), arg15(OP_PERFECT_FOWD(arg15)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14, Arg15>::type(e),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14), arg15(e.arg15) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14, Arg15>::type(std::move(e)),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14), arg15(e.arg15) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            arg8.prepare();
            arg9.prepare();
            arg10.prepare();
            arg11.prepare();
            arg12.prepare();
            arg13.prepare();
            arg14.prepare();
            arg15.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t) || arg8.contains(t)
                   || arg9.contains(t) || arg10.contains(t) || arg11.contains(t) || arg12.contains(t)
                   || arg13.contains(t) || arg14.contains(t) || arg15.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                        arg14, arg15)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
        typename internal::ExprProxy<Arg8>::type arg8;
        typename internal::ExprProxy<Arg9>::type arg9;
        typename internal::ExprProxy<Arg10>::type arg10;
        typename internal::ExprProxy<Arg11>::type arg11;
        typename internal::ExprProxy<Arg12>::type arg12;
        typename internal::ExprProxy<Arg13>::type arg13;
        typename internal::ExprProxy<Arg14>::type arg14;
        typename internal::ExprProxy<Arg15>::type arg15;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10, typename Arg11,
              typename Arg12, typename Arg13, typename Arg14, typename Arg15, typename Arg16>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                      Arg14, Arg15, Arg16>
        : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                     Arg14, Arg15, Arg16>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12,
                               Arg13, Arg14, Arg15, Arg16>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7, auto&& arg8, auto&& arg9, auto&& arg10, auto&& arg11, auto&& arg12,
                            auto&& arg13, auto&& arg14, auto&& arg15, auto&& arg16)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)), arg8(OP_PERFECT_FOWD(arg8)), arg9(OP_PERFECT_FOWD(arg9)),
              arg10(OP_PERFECT_FOWD(arg10)), arg11(OP_PERFECT_FOWD(arg11)), arg12(OP_PERFECT_FOWD(arg12)),
              arg13(OP_PERFECT_FOWD(arg13)), arg14(OP_PERFECT_FOWD(arg14)), arg15(OP_PERFECT_FOWD(arg15)),
              arg16(OP_PERFECT_FOWD(arg16)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14, Arg15, Arg16>::type(e),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14), arg15(e.arg15), arg16(e.arg16) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14, Arg15, Arg16>::type(std::move(e)),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14), arg15(e.arg15), arg16(e.arg16) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            arg8.prepare();
            arg9.prepare();
            arg10.prepare();
            arg11.prepare();
            arg12.prepare();
            arg13.prepare();
            arg14.prepare();
            arg15.prepare();
            arg16.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t) || arg8.contains(t)
                   || arg9.contains(t) || arg10.contains(t) || arg11.contains(t) || arg12.contains(t)
                   || arg13.contains(t) || arg14.contains(t) || arg15.contains(t) || arg16.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                        arg14, arg15, arg16)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
        typename internal::ExprProxy<Arg8>::type arg8;
        typename internal::ExprProxy<Arg9>::type arg9;
        typename internal::ExprProxy<Arg10>::type arg10;
        typename internal::ExprProxy<Arg11>::type arg11;
        typename internal::ExprProxy<Arg12>::type arg12;
        typename internal::ExprProxy<Arg13>::type arg13;
        typename internal::ExprProxy<Arg14>::type arg14;
        typename internal::ExprProxy<Arg15>::type arg15;
        typename internal::ExprProxy<Arg16>::type arg16;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10, typename Arg11,
              typename Arg12, typename Arg13, typename Arg14, typename Arg15, typename Arg16, typename Arg17>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                      Arg14, Arg15, Arg16, Arg17>
        : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                     Arg14, Arg15, Arg16, Arg17>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12,
                               Arg13, Arg14, Arg15, Arg16, Arg17>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7, auto&& arg8, auto&& arg9, auto&& arg10, auto&& arg11, auto&& arg12,
                            auto&& arg13, auto&& arg14, auto&& arg15, auto&& arg16, auto&& arg17)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)), arg8(OP_PERFECT_FOWD(arg8)), arg9(OP_PERFECT_FOWD(arg9)),
              arg10(OP_PERFECT_FOWD(arg10)), arg11(OP_PERFECT_FOWD(arg11)), arg12(OP_PERFECT_FOWD(arg12)),
              arg13(OP_PERFECT_FOWD(arg13)), arg14(OP_PERFECT_FOWD(arg14)), arg15(OP_PERFECT_FOWD(arg15)),
              arg16(OP_PERFECT_FOWD(arg16)), arg17(OP_PERFECT_FOWD(arg17)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14, Arg15, Arg16, Arg17>::type(e),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14), arg15(e.arg15), arg16(e.arg16), arg17(e.arg17) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14, Arg15, Arg16, Arg17>::type(std::move(e)),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14), arg15(e.arg15), arg16(e.arg16), arg17(e.arg17) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            arg8.prepare();
            arg9.prepare();
            arg10.prepare();
            arg11.prepare();
            arg12.prepare();
            arg13.prepare();
            arg14.prepare();
            arg15.prepare();
            arg16.prepare();
            arg17.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t) || arg8.contains(t)
                   || arg9.contains(t) || arg10.contains(t) || arg11.contains(t) || arg12.contains(t)
                   || arg13.contains(t) || arg14.contains(t) || arg15.contains(t) || arg16.contains(t)
                   || arg17.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                        arg14, arg15, arg16, arg17)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
        typename internal::ExprProxy<Arg8>::type arg8;
        typename internal::ExprProxy<Arg9>::type arg9;
        typename internal::ExprProxy<Arg10>::type arg10;
        typename internal::ExprProxy<Arg11>::type arg11;
        typename internal::ExprProxy<Arg12>::type arg12;
        typename internal::ExprProxy<Arg13>::type arg13;
        typename internal::ExprProxy<Arg14>::type arg14;
        typename internal::ExprProxy<Arg15>::type arg15;
        typename internal::ExprProxy<Arg16>::type arg16;
        typename internal::ExprProxy<Arg17>::type arg17;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10, typename Arg11,
              typename Arg12, typename Arg13, typename Arg14, typename Arg15, typename Arg16, typename Arg17,
              typename Arg18>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                      Arg14, Arg15, Arg16, Arg17, Arg18>
        : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                     Arg14, Arg15, Arg16, Arg17, Arg18>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12,
                               Arg13, Arg14, Arg15, Arg16, Arg17, Arg18>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7, auto&& arg8, auto&& arg9, auto&& arg10, auto&& arg11, auto&& arg12,
                            auto&& arg13, auto&& arg14, auto&& arg15, auto&& arg16, auto&& arg17,
                            auto&& arg18)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)), arg8(OP_PERFECT_FOWD(arg8)), arg9(OP_PERFECT_FOWD(arg9)),
              arg10(OP_PERFECT_FOWD(arg10)), arg11(OP_PERFECT_FOWD(arg11)), arg12(OP_PERFECT_FOWD(arg12)),
              arg13(OP_PERFECT_FOWD(arg13)), arg14(OP_PERFECT_FOWD(arg14)), arg15(OP_PERFECT_FOWD(arg15)),
              arg16(OP_PERFECT_FOWD(arg16)), arg17(OP_PERFECT_FOWD(arg17)), arg18(OP_PERFECT_FOWD(arg18)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14, Arg15, Arg16, Arg17, Arg18>::type(e),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14), arg15(e.arg15), arg16(e.arg16), arg17(e.arg17), arg18(e.arg18) {
        }
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14, Arg15, Arg16, Arg17, Arg18>::type(std::move(e)),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14), arg15(e.arg15), arg16(e.arg16), arg17(e.arg17), arg18(e.arg18) {
        }

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            arg8.prepare();
            arg9.prepare();
            arg10.prepare();
            arg11.prepare();
            arg12.prepare();
            arg13.prepare();
            arg14.prepare();
            arg15.prepare();
            arg16.prepare();
            arg17.prepare();
            arg18.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t) || arg8.contains(t)
                   || arg9.contains(t) || arg10.contains(t) || arg11.contains(t) || arg12.contains(t)
                   || arg13.contains(t) || arg14.contains(t) || arg15.contains(t) || arg16.contains(t)
                   || arg17.contains(t) || arg18.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                        arg14, arg15, arg16, arg17, arg18)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
        typename internal::ExprProxy<Arg8>::type arg8;
        typename internal::ExprProxy<Arg9>::type arg9;
        typename internal::ExprProxy<Arg10>::type arg10;
        typename internal::ExprProxy<Arg11>::type arg11;
        typename internal::ExprProxy<Arg12>::type arg12;
        typename internal::ExprProxy<Arg13>::type arg13;
        typename internal::ExprProxy<Arg14>::type arg14;
        typename internal::ExprProxy<Arg15>::type arg15;
        typename internal::ExprProxy<Arg16>::type arg16;
        typename internal::ExprProxy<Arg17>::type arg17;
        typename internal::ExprProxy<Arg18>::type arg18;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10, typename Arg11,
              typename Arg12, typename Arg13, typename Arg14, typename Arg15, typename Arg16, typename Arg17,
              typename Arg18, typename Arg19>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                      Arg14, Arg15, Arg16, Arg17, Arg18, Arg19>
        : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                     Arg14, Arg15, Arg16, Arg17, Arg18, Arg19>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12,
                               Arg13, Arg14, Arg15, Arg16, Arg17, Arg18, Arg19>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7, auto&& arg8, auto&& arg9, auto&& arg10, auto&& arg11, auto&& arg12,
                            auto&& arg13, auto&& arg14, auto&& arg15, auto&& arg16, auto&& arg17,
                            auto&& arg18, auto&& arg19)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)), arg8(OP_PERFECT_FOWD(arg8)), arg9(OP_PERFECT_FOWD(arg9)),
              arg10(OP_PERFECT_FOWD(arg10)), arg11(OP_PERFECT_FOWD(arg11)), arg12(OP_PERFECT_FOWD(arg12)),
              arg13(OP_PERFECT_FOWD(arg13)), arg14(OP_PERFECT_FOWD(arg14)), arg15(OP_PERFECT_FOWD(arg15)),
              arg16(OP_PERFECT_FOWD(arg16)), arg17(OP_PERFECT_FOWD(arg17)), arg18(OP_PERFECT_FOWD(arg18)),
              arg19(OP_PERFECT_FOWD(arg19)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14, Arg15, Arg16, Arg17, Arg18, Arg19>::type(e),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14), arg15(e.arg15), arg16(e.arg16), arg17(e.arg17), arg18(e.arg18),
              arg19(e.arg19) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14, Arg15, Arg16, Arg17, Arg18, Arg19>::type(std::move(e)),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14), arg15(e.arg15), arg16(e.arg16), arg17(e.arg17), arg18(e.arg18),
              arg19(e.arg19) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            arg8.prepare();
            arg9.prepare();
            arg10.prepare();
            arg11.prepare();
            arg12.prepare();
            arg13.prepare();
            arg14.prepare();
            arg15.prepare();
            arg16.prepare();
            arg17.prepare();
            arg18.prepare();
            arg19.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t) || arg8.contains(t)
                   || arg9.contains(t) || arg10.contains(t) || arg11.contains(t) || arg12.contains(t)
                   || arg13.contains(t) || arg14.contains(t) || arg15.contains(t) || arg16.contains(t)
                   || arg17.contains(t) || arg18.contains(t) || arg19.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                        arg14, arg15, arg16, arg17, arg18, arg19)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
        typename internal::ExprProxy<Arg8>::type arg8;
        typename internal::ExprProxy<Arg9>::type arg9;
        typename internal::ExprProxy<Arg10>::type arg10;
        typename internal::ExprProxy<Arg11>::type arg11;
        typename internal::ExprProxy<Arg12>::type arg12;
        typename internal::ExprProxy<Arg13>::type arg13;
        typename internal::ExprProxy<Arg14>::type arg14;
        typename internal::ExprProxy<Arg15>::type arg15;
        typename internal::ExprProxy<Arg16>::type arg16;
        typename internal::ExprProxy<Arg17>::type arg17;
        typename internal::ExprProxy<Arg18>::type arg18;
        typename internal::ExprProxy<Arg19>::type arg19;
    };

    template <typename Op, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
              typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10, typename Arg11,
              typename Arg12, typename Arg13, typename Arg14, typename Arg15, typename Arg16, typename Arg17,
              typename Arg18, typename Arg19, typename Arg20>
    struct Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                      Arg14, Arg15, Arg16, Arg17, Arg18, Arg19, Arg20>
        : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                     Arg14, Arg15, Arg16, Arg17, Arg18, Arg19, Arg20>::type {
        friend Expr<Expression<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12,
                               Arg13, Arg14, Arg15, Arg16, Arg17, Arg18, Arg19, Arg20>>;
        explicit Expression(auto&& arg1, auto&& arg2, auto&& arg3, auto&& arg4, auto&& arg5, auto&& arg6,
                            auto&& arg7, auto&& arg8, auto&& arg9, auto&& arg10, auto&& arg11, auto&& arg12,
                            auto&& arg13, auto&& arg14, auto&& arg15, auto&& arg16, auto&& arg17,
                            auto&& arg18, auto&& arg19, auto&& arg20)
            : arg1(OP_PERFECT_FOWD(arg1)), arg2(OP_PERFECT_FOWD(arg2)), arg3(OP_PERFECT_FOWD(arg3)),
              arg4(OP_PERFECT_FOWD(arg4)), arg5(OP_PERFECT_FOWD(arg5)), arg6(OP_PERFECT_FOWD(arg6)),
              arg7(OP_PERFECT_FOWD(arg7)), arg8(OP_PERFECT_FOWD(arg8)), arg9(OP_PERFECT_FOWD(arg9)),
              arg10(OP_PERFECT_FOWD(arg10)), arg11(OP_PERFECT_FOWD(arg11)), arg12(OP_PERFECT_FOWD(arg12)),
              arg13(OP_PERFECT_FOWD(arg13)), arg14(OP_PERFECT_FOWD(arg14)), arg15(OP_PERFECT_FOWD(arg15)),
              arg16(OP_PERFECT_FOWD(arg16)), arg17(OP_PERFECT_FOWD(arg17)), arg18(OP_PERFECT_FOWD(arg18)),
              arg19(OP_PERFECT_FOWD(arg19)), arg20(OP_PERFECT_FOWD(arg20)) {}
        Expression(const Expression& e)
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14, Arg15, Arg16, Arg17, Arg18, Arg19, Arg20>::type(e),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14), arg15(e.arg15), arg16(e.arg16), arg17(e.arg17), arg18(e.arg18),
              arg19(e.arg19), arg20(e.arg20) {}
        Expression(Expression&& e) noexcept
            : ResultType<Op, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13,
                         Arg14, Arg15, Arg16, Arg17, Arg18, Arg19, Arg20>::type(std::move(e)),
              arg1(e.arg1), arg2(e.arg2), arg3(e.arg3), arg4(e.arg4), arg5(e.arg5), arg6(e.arg6),
              arg7(e.arg7), arg8(e.arg8), arg9(e.arg9), arg10(e.arg10), arg11(e.arg11), arg12(e.arg12),
              arg13(e.arg13), arg14(e.arg14), arg15(e.arg15), arg16(e.arg16), arg17(e.arg17), arg18(e.arg18),
              arg19(e.arg19), arg20(e.arg20) {}

    protected:
        void prepareImpl_final() const {
            arg1.prepare();
            arg2.prepare();
            arg3.prepare();
            arg4.prepare();
            arg5.prepare();
            arg6.prepare();
            arg7.prepare();
            arg8.prepare();
            arg9.prepare();
            arg10.prepare();
            arg11.prepare();
            arg12.prepare();
            arg13.prepare();
            arg14.prepare();
            arg15.prepare();
            arg16.prepare();
            arg17.prepare();
            arg18.prepare();
            arg19.prepare();
            arg20.prepare();
            Op::prepare(*this);
        }

        bool containsImpl_final(const auto& t) const {
            return arg1.contains(t) || arg2.contains(t) || arg3.contains(t) || arg4.contains(t)
                   || arg5.contains(t) || arg6.contains(t) || arg7.contains(t) || arg8.contains(t)
                   || arg9.contains(t) || arg10.contains(t) || arg11.contains(t) || arg12.contains(t)
                   || arg13.contains(t) || arg14.contains(t) || arg15.contains(t) || arg16.contains(t)
                   || arg17.contains(t) || arg18.contains(t) || arg19.contains(t) || arg20.contains(t);
        }

        DEFINE_EVAL_OPS(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
                        arg14, arg15, arg16, arg17, arg18, arg19, arg20)
    public:
        typename internal::ExprProxy<Arg1>::type arg1;
        typename internal::ExprProxy<Arg2>::type arg2;
        typename internal::ExprProxy<Arg3>::type arg3;
        typename internal::ExprProxy<Arg4>::type arg4;
        typename internal::ExprProxy<Arg5>::type arg5;
        typename internal::ExprProxy<Arg6>::type arg6;
        typename internal::ExprProxy<Arg7>::type arg7;
        typename internal::ExprProxy<Arg8>::type arg8;
        typename internal::ExprProxy<Arg9>::type arg9;
        typename internal::ExprProxy<Arg10>::type arg10;
        typename internal::ExprProxy<Arg11>::type arg11;
        typename internal::ExprProxy<Arg12>::type arg12;
        typename internal::ExprProxy<Arg13>::type arg13;
        typename internal::ExprProxy<Arg14>::type arg14;
        typename internal::ExprProxy<Arg15>::type arg15;
        typename internal::ExprProxy<Arg16>::type arg16;
        typename internal::ExprProxy<Arg17>::type arg17;
        typename internal::ExprProxy<Arg18>::type arg18;
        typename internal::ExprProxy<Arg19>::type arg19;
        typename internal::ExprProxy<Arg20>::type arg20;
    };

    // general exprs
    template <typename Op, typename... Args>
    requires(sizeof...(Args) > 0) auto makeExpression(Args&&... args) {
        return Expression<Op, Meta::RealType<Args>...>(std::forward<Args>(args)...);
    }

    // nullary op exprs
    template <typename Op>
    auto makeExpression() {
        return Expression<Op>();
    }

#undef DEFINE_EVAL_OPS
}// namespace OpFlow
#endif
