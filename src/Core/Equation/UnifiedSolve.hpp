//  ----------------------------------------------------------------------------
//
//  Copyright (c) 2019 - 2022 by the OpFlow developers
//
//  This file is part of OpFlow.
//
//  OpFlow is free software and is distributed under the MPL v2.0 license.
//  The full text of the license can be found in the file LICENSE at the top
//  level directory of OpFlow.
//
//  ----------------------------------------------------------------------------
//  Note: This file is generated by script in "script/codegen.py". Modify the
//        script rather than this file if you need to.
//  ----------------------------------------------------------------------------

#ifndef OPFLOW_UNIFIEDSOLVE_HPP
#define OPFLOW_UNIFIEDSOLVE_HPP

#include "Core/Equation/AMGCLBackend.hpp"
#include "Core/Equation/Equation.hpp"
#include "Core/Equation/HYPREEqnSolveHandler.hpp"
#include "Core/Solvers/IJ/IJSolver.hpp"
#include "Core/Solvers/SemiStruct/SemiStructSolver.hpp"
#include "Core/Solvers/SemiStruct/SemiStructSolverFAC.hpp"
#include "Core/Solvers/Struct/StructSolver.hpp"
#include "Core/Solvers/Struct/StructSolverBiCGSTAB.hpp"
#include "Core/Solvers/Struct/StructSolverCycRed.hpp"
#include "Core/Solvers/Struct/StructSolverFGMRES.hpp"
#include "Core/Solvers/Struct/StructSolverGMRES.hpp"
#include "Core/Solvers/Struct/StructSolverJacobi.hpp"
#include "Core/Solvers/Struct/StructSolverLGMRES.hpp"
#include "Core/Solvers/Struct/StructSolverNone.hpp"
#include "Core/Solvers/Struct/StructSolverPCG.hpp"
#include "Core/Solvers/Struct/StructSolverPFMG.hpp"
#include "Core/Solvers/Struct/StructSolverPrecond.hpp"
#include "Core/Solvers/Struct/StructSolverSMG.hpp"

namespace OpFlow {
    template <StructSolverType type = StructSolverType::GMRES,
              StructSolverType pType = StructSolverType::None, typename F, StructuredFieldExprType T>
    void Solve(const F& func, T&& target, StructSolverParams<type> params = StructSolverParams<type> {},
               StructSolverParams<pType> precParams = StructSolverParams<pType> {}) {
        auto solver = PrecondStructSolver<type, pType>(params, precParams);
        auto handler = makeEqnSolveHandler(func, target, solver);
        handler->solve();
    }

    template <SemiStructSolverType type = SemiStructSolverType::FAC,
              SemiStructSolverType pType = SemiStructSolverType::None, typename F,
              SemiStructuredFieldExprType T>
    void Solve(const F& func, T&& target,
               SemiStructSolverParams<type> params = SemiStructSolverParams<type> {},
               SemiStructSolverParams<pType> precParams = SemiStructSolverParams<pType> {}) {
        if constexpr (pType != SemiStructSolverType::None) {
            auto solver = PrecondSemiStructSolver<type, pType>(params, precParams);
            auto handler = makeEqnSolveHandler(func, target, solver);
            handler->solve();
        } else {
            auto solver = SemiStructSolver<type>(params);
            auto handler = HYPREEqnSolveHandler<Meta::RealType<F>, Meta::RealType<T>, SemiStructSolver<type>>(
                    func, target, solver);
            handler.solve();
        }
    }

    template <typename S, typename F, FieldExprType T>
    void Solve(F&& func, T&& target, auto&& indexer, IJSolverParams<S> params = IJSolverParams<S> {}) {
        auto handler = makeEqnSolveHandler(func, target, indexer, params);
        handler->solve();
    }

    template <typename S, typename F1, typename T1>
    void SolveEqns(F1&& f1, T1&& t1, auto&& mapper, const std::vector<IJSolverParams<S>>& params) {
        auto eqn_holder = makeEqnHolder(f1, t1);
        auto st_holder = makeStencilHolder(eqn_holder);
        std::vector<bool> pin;
        for (const auto& p : params) pin.push_back(p.pinValue);
        auto mat = CSRMatrixGenerator::generate(st_holder, mapper, pin);
        std::vector<Real> x(mat.rhs.size());
        AMGCLBackend<S, Real>::solve(mat, x, params[0].p, params[0].bp, params[0].verbose);
        Meta::static_for<decltype(st_holder)::size>([&]<int i>(Meta::int_<i>) {
            auto target = eqn_holder.template getTarget<i + 1>();
            rangeFor(target->assignableRange, [&](auto&& k) {
                (*target)[k] = x[mapper(DS::ColoredIndex<Meta::RealType<decltype(k)>> {k, i + 1})];
            });
        });
    }

    template <typename S, typename F1, typename F2, typename T1, typename T2>
    void SolveEqns(F1&& f1, F2&& f2, T1&& t1, T2&& t2, auto&& mapper,
                   const std::vector<IJSolverParams<S>>& params) {
        auto eqn_holder = makeEqnHolder(f1, f2, t1, t2);
        auto st_holder = makeStencilHolder(eqn_holder);
        std::vector<bool> pin;
        for (const auto& p : params) pin.push_back(p.pinValue);
        auto mat = CSRMatrixGenerator::generate(st_holder, mapper, pin);
        std::vector<Real> x(mat.rhs.size());
        AMGCLBackend<S, Real>::solve(mat, x, params[0].p, params[0].bp, params[0].verbose);
        Meta::static_for<decltype(st_holder)::size>([&]<int i>(Meta::int_<i>) {
            auto target = eqn_holder.template getTarget<i + 1>();
            rangeFor(target->assignableRange, [&](auto&& k) {
                (*target)[k] = x[mapper(DS::ColoredIndex<Meta::RealType<decltype(k)>> {k, i + 1})];
            });
        });
    }

    template <typename S, typename F1, typename F2, typename F3, typename T1, typename T2, typename T3>
    void SolveEqns(F1&& f1, F2&& f2, F3&& f3, T1&& t1, T2&& t2, T3&& t3, auto&& mapper,
                   const std::vector<IJSolverParams<S>>& params) {
        auto eqn_holder = makeEqnHolder(f1, f2, f3, t1, t2, t3);
        auto st_holder = makeStencilHolder(eqn_holder);
        std::vector<bool> pin;
        for (const auto& p : params) pin.push_back(p.pinValue);
        auto mat = CSRMatrixGenerator::generate(st_holder, mapper, pin);
        std::vector<Real> x(mat.rhs.size());
        AMGCLBackend<S, Real>::solve(mat, x, params[0].p, params[0].bp, params[0].verbose);
        Meta::static_for<decltype(st_holder)::size>([&]<int i>(Meta::int_<i>) {
            auto target = eqn_holder.template getTarget<i + 1>();
            rangeFor(target->assignableRange, [&](auto&& k) {
                (*target)[k] = x[mapper(DS::ColoredIndex<Meta::RealType<decltype(k)>> {k, i + 1})];
            });
        });
    }

    template <typename S, typename F1, typename F2, typename F3, typename F4, typename T1, typename T2,
              typename T3, typename T4>
    void SolveEqns(F1&& f1, F2&& f2, F3&& f3, F4&& f4, T1&& t1, T2&& t2, T3&& t3, T4&& t4, auto&& mapper,
                   const std::vector<IJSolverParams<S>>& params) {
        auto eqn_holder = makeEqnHolder(f1, f2, f3, f4, t1, t2, t3, t4);
        auto st_holder = makeStencilHolder(eqn_holder);
        std::vector<bool> pin;
        for (const auto& p : params) pin.push_back(p.pinValue);
        auto mat = CSRMatrixGenerator::generate(st_holder, mapper, pin);
        std::vector<Real> x(mat.rhs.size());
        AMGCLBackend<S, Real>::solve(mat, x, params[0].p, params[0].bp, params[0].verbose);
        Meta::static_for<decltype(st_holder)::size>([&]<int i>(Meta::int_<i>) {
            auto target = eqn_holder.template getTarget<i + 1>();
            rangeFor(target->assignableRange, [&](auto&& k) {
                (*target)[k] = x[mapper(DS::ColoredIndex<Meta::RealType<decltype(k)>> {k, i + 1})];
            });
        });
    }

    template <typename S, typename F1, typename F2, typename F3, typename F4, typename F5, typename T1,
              typename T2, typename T3, typename T4, typename T5>
    void SolveEqns(F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                   auto&& mapper, const std::vector<IJSolverParams<S>>& params) {
        auto eqn_holder = makeEqnHolder(f1, f2, f3, f4, f5, t1, t2, t3, t4, t5);
        auto st_holder = makeStencilHolder(eqn_holder);
        std::vector<bool> pin;
        for (const auto& p : params) pin.push_back(p.pinValue);
        auto mat = CSRMatrixGenerator::generate(st_holder, mapper, pin);
        std::vector<Real> x(mat.rhs.size());
        AMGCLBackend<S, Real>::solve(mat, x, params[0].p, params[0].bp, params[0].verbose);
        Meta::static_for<decltype(st_holder)::size>([&]<int i>(Meta::int_<i>) {
            auto target = eqn_holder.template getTarget<i + 1>();
            rangeFor(target->assignableRange, [&](auto&& k) {
                (*target)[k] = x[mapper(DS::ColoredIndex<Meta::RealType<decltype(k)>> {k, i + 1})];
            });
        });
    }

    template <typename S, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6,
              typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
    void SolveEqns(F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, T1&& t1, T2&& t2, T3&& t3, T4&& t4,
                   T5&& t5, T6&& t6, auto&& mapper, const std::vector<IJSolverParams<S>>& params) {
        auto eqn_holder = makeEqnHolder(f1, f2, f3, f4, f5, f6, t1, t2, t3, t4, t5, t6);
        auto st_holder = makeStencilHolder(eqn_holder);
        std::vector<bool> pin;
        for (const auto& p : params) pin.push_back(p.pinValue);
        auto mat = CSRMatrixGenerator::generate(st_holder, mapper, pin);
        std::vector<Real> x(mat.rhs.size());
        AMGCLBackend<S, Real>::solve(mat, x, params[0].p, params[0].bp, params[0].verbose);
        Meta::static_for<decltype(st_holder)::size>([&]<int i>(Meta::int_<i>) {
            auto target = eqn_holder.template getTarget<i + 1>();
            rangeFor(target->assignableRange, [&](auto&& k) {
                (*target)[k] = x[mapper(DS::ColoredIndex<Meta::RealType<decltype(k)>> {k, i + 1})];
            });
        });
    }

    template <typename S, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6,
              typename F7, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6,
              typename T7>
    void SolveEqns(F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, T1&& t1, T2&& t2, T3&& t3,
                   T4&& t4, T5&& t5, T6&& t6, T7&& t7, auto&& mapper,
                   const std::vector<IJSolverParams<S>>& params) {
        auto eqn_holder = makeEqnHolder(f1, f2, f3, f4, f5, f6, f7, t1, t2, t3, t4, t5, t6, t7);
        auto st_holder = makeStencilHolder(eqn_holder);
        std::vector<bool> pin;
        for (const auto& p : params) pin.push_back(p.pinValue);
        auto mat = CSRMatrixGenerator::generate(st_holder, mapper, pin);
        std::vector<Real> x(mat.rhs.size());
        AMGCLBackend<S, Real>::solve(mat, x, params[0].p, params[0].bp, params[0].verbose);
        Meta::static_for<decltype(st_holder)::size>([&]<int i>(Meta::int_<i>) {
            auto target = eqn_holder.template getTarget<i + 1>();
            rangeFor(target->assignableRange, [&](auto&& k) {
                (*target)[k] = x[mapper(DS::ColoredIndex<Meta::RealType<decltype(k)>> {k, i + 1})];
            });
        });
    }

    template <typename S, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6,
              typename F7, typename F8, typename T1, typename T2, typename T3, typename T4, typename T5,
              typename T6, typename T7, typename T8>
    void SolveEqns(F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, T1&& t1, T2&& t2,
                   T3&& t3, T4&& t4, T5&& t5, T6&& t6, T7&& t7, T8&& t8, auto&& mapper,
                   const std::vector<IJSolverParams<S>>& params) {
        auto eqn_holder = makeEqnHolder(f1, f2, f3, f4, f5, f6, f7, f8, t1, t2, t3, t4, t5, t6, t7, t8);
        auto st_holder = makeStencilHolder(eqn_holder);
        std::vector<bool> pin;
        for (const auto& p : params) pin.push_back(p.pinValue);
        auto mat = CSRMatrixGenerator::generate(st_holder, mapper, pin);
        std::vector<Real> x(mat.rhs.size());
        AMGCLBackend<S, Real>::solve(mat, x, params[0].p, params[0].bp, params[0].verbose);
        Meta::static_for<decltype(st_holder)::size>([&]<int i>(Meta::int_<i>) {
            auto target = eqn_holder.template getTarget<i + 1>();
            rangeFor(target->assignableRange, [&](auto&& k) {
                (*target)[k] = x[mapper(DS::ColoredIndex<Meta::RealType<decltype(k)>> {k, i + 1})];
            });
        });
    }

    template <typename S, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6,
              typename F7, typename F8, typename F9, typename T1, typename T2, typename T3, typename T4,
              typename T5, typename T6, typename T7, typename T8, typename T9>
    void SolveEqns(F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, T1&& t1,
                   T2&& t2, T3&& t3, T4&& t4, T5&& t5, T6&& t6, T7&& t7, T8&& t8, T9&& t9, auto&& mapper,
                   const std::vector<IJSolverParams<S>>& params) {
        auto eqn_holder
                = makeEqnHolder(f1, f2, f3, f4, f5, f6, f7, f8, f9, t1, t2, t3, t4, t5, t6, t7, t8, t9);
        auto st_holder = makeStencilHolder(eqn_holder);
        std::vector<bool> pin;
        for (const auto& p : params) pin.push_back(p.pinValue);
        auto mat = CSRMatrixGenerator::generate(st_holder, mapper, pin);
        std::vector<Real> x(mat.rhs.size());
        AMGCLBackend<S, Real>::solve(mat, x, params[0].p, params[0].bp, params[0].verbose);
        Meta::static_for<decltype(st_holder)::size>([&]<int i>(Meta::int_<i>) {
            auto target = eqn_holder.template getTarget<i + 1>();
            rangeFor(target->assignableRange, [&](auto&& k) {
                (*target)[k] = x[mapper(DS::ColoredIndex<Meta::RealType<decltype(k)>> {k, i + 1})];
            });
        });
    }

    template <typename S, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6,
              typename F7, typename F8, typename F9, typename F10, typename T1, typename T2, typename T3,
              typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
    void SolveEqns(F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10,
                   T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5, T6&& t6, T7&& t7, T8&& t8, T9&& t9, T10&& t10,
                   auto&& mapper, const std::vector<IJSolverParams<S>>& params) {
        auto eqn_holder = makeEqnHolder(f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, t1, t2, t3, t4, t5, t6, t7,
                                        t8, t9, t10);
        auto st_holder = makeStencilHolder(eqn_holder);
        std::vector<bool> pin;
        for (const auto& p : params) pin.push_back(p.pinValue);
        auto mat = CSRMatrixGenerator::generate(st_holder, mapper, pin);
        std::vector<Real> x(mat.rhs.size());
        AMGCLBackend<S, Real>::solve(mat, x, params[0].p, params[0].bp, params[0].verbose);
        Meta::static_for<decltype(st_holder)::size>([&]<int i>(Meta::int_<i>) {
            auto target = eqn_holder.template getTarget<i + 1>();
            rangeFor(target->assignableRange, [&](auto&& k) {
                (*target)[k] = x[mapper(DS::ColoredIndex<Meta::RealType<decltype(k)>> {k, i + 1})];
            });
        });
    }

}// namespace OpFlow
#endif