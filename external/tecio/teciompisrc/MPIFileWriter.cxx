#include "MPIFileWriter.h"
#include "ThirdPartyHeadersBegin.h"
#include <boost/bind.hpp>
#include <cstdarg>
#include <cstring>
#include <iostream>
#include <limits>
#include <sstream>
#include <vector>
#include <boost/format.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "CodeContract.h"
#include "FileIOStatistics.h"
#include "mpiDatatype.h"
#include "MPIFileIOStream.h"
using namespace tecplot::___3933; namespace tecplot { namespace teciompi { struct MPIFileWriter::Impl { MPIFileIOStream         m_ioStream; std::vector<char>       m_buffer; bool                    m_caching; Impl(std::string const& ___1394, MPI_Comm comm, size_t bufferSizeInMB) : m_ioStream(___1394, comm) , m_caching(false) { setMinimumBufferCapacity(bufferSizeInMB * 1024 * 1024); } ___372 flushBuffer() { ___372 ___3358 = ___4226; if (!m_buffer.empty()) { if (m_caching) ___3358 = (MPI_File_write_all(m_ioStream.fileHandle(), reinterpret_cast<void const*>(&m_buffer.front()), static_cast<int32_t>(m_buffer.size()), MPI_CHAR, MPI_STATUS_IGNORE) == MPI_SUCCESS); else ___3358 = (MPI_File_write(m_ioStream.fileHandle(), reinterpret_cast<void const*>(&m_buffer.front()), static_cast<int32_t>(m_buffer.size()), MPI_CHAR, MPI_STATUS_IGNORE) == MPI_SUCCESS); } m_buffer.clear(); return ___3358; } ___372 appendToBuffer(char const* data, int32_t size) { ___372 ___3358 = ___4226; size_t requiredSize = size + m_buffer.size(); if (requiredSize > m_buffer.capacity()) { if (m_caching) { std::cerr << "Warning: Increasing collective file output cache to " << requiredSize << " bytes." << std::endl; ___478(___1305); try { setMinimumBufferCapacity(requiredSize); } catch (...) { ___3358 = ___1305; } } else { ___3358 = flushBuffer(); } } if (___3358 && size > static_cast<int>(m_buffer.capacity())) ___3358 = ___3358 && (MPI_File_write(m_ioStream.fileHandle(), reinterpret_cast<void const*>(data), size, MPI_CHAR, MPI_STATUS_IGNORE) == MPI_SUCCESS); else m_buffer.insert(m_buffer.end(), data, data + size); ENSURE(VALID_BOOLEAN(___3358)); return ___3358; } void setMinimumBufferCapacity(size_t minimumBufferCapacity) { if (minimumBufferCapacity > m_buffer.capacity()) m_buffer.reserve(minimumBufferCapacity); } void cacheOutput(size_t requiredCacheSize) { if (flushBuffer()) { setMinimumBufferCapacity(requiredCacheSize); m_caching = true; } } void endCaching() { flushBuffer(); m_caching = false; } }; MPIFileWriter::MPIFileWriter(std::string const& ___1394, MPI_Comm comm, size_t bufferSizeInMB) : m_impl(new Impl(___1394, comm, bufferSizeInMB)) {} MPIFileWriter::~MPIFileWriter() { m_impl->flushBuffer(); close(true); } ___372 MPIFileWriter::___2041() const { return m_impl->m_ioStream.fileHandle() != NULL; } ___372 MPIFileWriter::open(bool update) { REQUIRE(!___2041()); int ___2504 = MPI_MODE_CREATE; if (update) ___2504 |= MPI_MODE_RDWR; else ___2504 |= MPI_MODE_WRONLY; ___372 ___2039 = m_impl->m_ioStream.open(___2504); if (___2039) { if (!update) { MPI_File_set_size(m_impl->m_ioStream.fileHandle(), (MPI_Offset)0); MPI_Barrier(m_impl->m_ioStream.comm()); } } return ___2039; } ___372 MPIFileWriter::close(bool ___3361) { int ___3358 = MPI_SUCCESS; if (___2041()) { m_impl->flushBuffer(); ___3358 = m_impl->m_ioStream.close(___3361); } ENSURE(!___2041()); return (___3358 == MPI_SUCCESS ? ___4226 : ___1305); } ___3933::___1393 MPIFileWriter::fileLoc() { REQUIRE(___2041()); return static_cast<___3933::___1393>(m_impl->m_ioStream.fileLoc() + m_impl->m_buffer.size()); } ___372 MPIFileWriter::___3460() { REQUIRE(___2041()); ___372 const flushResult = m_impl->flushBuffer(); ___372 const seekResult = m_impl->m_ioStream.___3460(); return flushResult && seekResult; } ___372 MPIFileWriter::___3459(___3933::___1393 fileLoc) { REQUIRE(___2041()); ___372 const flushResult = m_impl->flushBuffer(); ___372 const seekResult = m_impl->m_ioStream.___3459(fileLoc); return flushResult && seekResult; } ___372 MPIFileWriter::seekToFileEnd() { REQUIRE(___2041()); ___372 const flushResult = m_impl->flushBuffer(); ___372 const seekResult = m_impl->m_ioStream.seekToFileEnd(); return flushResult && seekResult; } std::string const& MPIFileWriter::___1394() const { return m_impl->m_ioStream.___1394(); } void MPIFileWriter::___3494(___372 ___2002) { REQUIRE(VALID_BOOLEAN(___2002)); m_impl->m_ioStream.___3494(___2002); } ___372 MPIFileWriter::___2002() const { return m_impl->m_ioStream.___2002(); } void MPIFileWriter::setDataFileType(DataFileType_e ___844) { REQUIRE(VALID_ENUM(___844, DataFileType_e)); m_impl->m_ioStream.setDataFileType(___844); } DataFileType_e MPIFileWriter::___844() const { return m_impl->m_ioStream.___844(); } class FileIOStatistics& MPIFileWriter::statistics() { return m_impl->m_ioStream.statistics(); } size_t MPIFileWriter::fwrite(void const* ___416, size_t size, size_t count) { REQUIRE(___2041()); REQUIRE(size == 1 || size == 2 || size == 4 || size == 8 || size == 16); ___478(size * count <= static_cast<size_t>(std::numeric_limits<int32_t>::max())); ___372 ___3358 = m_impl->appendToBuffer(reinterpret_cast<char const*>(___416), static_cast<int32_t>(size * count)); if (___3358) return count; else return 0; } int MPIFileWriter::fprintf(char const* format, ...) { REQUIRE(___2041()); std::vector<char> vec(strlen(format) + 1); bool done = false; int numChars = 0; while (!done) { va_list ap; va_start(ap, format);
 #if defined _WIN32
numChars = vsnprintf_s(&vec[0], vec.size(), _TRUNCATE, format, ap); if (numChars > 0) done = true; else vec.resize(vec.size() * 2);
 #else
numChars = vsnprintf(&vec[0], vec.size(), format, ap); if (numChars < static_cast<int>(vec.size())) done = true; else vec.resize(static_cast<size_t>(numChars + 1));
 #endif
va_end (ap); } ___478(numChars < static_cast<int>(vec.size())); ___372 ___3358 = m_impl->appendToBuffer(vec.data(), numChars); if (___3358) return numChars; else return 0; } MPIFileWriter::ScopedCaching::ScopedCaching(MPIFileWriter& fileWriter, size_t cacheSize) : m_fileWriter(fileWriter) { m_fileWriter.m_impl->cacheOutput(cacheSize); } MPIFileWriter::ScopedCaching::~ScopedCaching() { m_fileWriter.m_impl->endCaching(); } }}
