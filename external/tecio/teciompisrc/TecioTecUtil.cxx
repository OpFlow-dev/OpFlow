#include "TecioTecUtil.h"
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <cfloat>
#include <cstring>
#include <limits>
#include <map>
#include <set>
#include <sstream>
#include <boost/foreach.hpp>
#include <boost/shared_ptr.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "FieldData_s.h"
 #if defined TECIOMPI
struct ___2122 {}; struct ___2665 {};
 #else
#include "JobControl_s.h"
#include "Mutex_s.h"
 #endif
using namespace tecplot::___3933; struct StringList_s { std::vector<std::string> m_strings; }; namespace tecplot { namespace tecioszl { namespace { char* copyString(std::string const& str) { char* ___3358 = new char[strlen(str.c_str()) + 1]; strcpy(___3358, str.c_str()); return ___3358; } } ___4016::___4016(___3970& tecioData) : m_tecioData(tecioData) {} ___4016::~___4016() {} void ___4016::___3817(char** ___3855) const { delete[] *___3855; *___3855 = 0; } void ___4016::___3827(___3839* ___3819) const { delete *___3819; *___3819 = 0; } ___2227 ___4016::___3832(___3839 ___3819) const { return (___2227)___3819->m_strings.size(); } char* ___4016::___3833(___3839 ___3819, ___2227 ___3853) const { REQUIRE(0 < ___3853 && ___3853 <= ___3832(___3819)); return copyString(___3819->m_strings[___3853 - 1]); } ___264 ___4016::___235() const { return m_tecioData.dataSetAuxData().get(); } ___264 ___4016::___274(___4636 zone) const { REQUIRE(m_tecioData.validZoneNum(zone)); Zone_s const* zonePtr = m_tecioData.zonePtr(zone); return zonePtr->___2345.get(); } ___264 ___4016::___273(___4352 ___4336) const { REQUIRE(0 < ___4336 && ___4336 <= static_cast<___1172>(m_tecioData.variableNames().size())); return m_tecioData.varAuxData()[___4336 - 1].get(); } int32_t ___4016::___247(___264 ___265) const { return static_cast<int32_t>(___265->m_auxDataItems.size()); } void ___4016::___243(___264 ___265, int32_t index, char** ___2685, ___90* ___4314, AuxDataType_e* type, ___372* ___3361) const { REQUIRE(VALID_REF(___265)); REQUIRE(0 < index && (size_t)index <= ___265->m_auxDataItems.size()); REQUIRE(VALID_REF(___2685) && *___2685 == 0); REQUIRE(VALID_REF(___4314) && *___4314 == 0); REQUIRE(VALID_REF(type)); REQUIRE(VALID_REF(___3361)); AuxData_s::AuxDataItem const& auxDataItem = ___265->m_auxDataItems[index - 1]; *___2685 = copyString(auxDataItem.___2495); *___4314 = reinterpret_cast<___90>(copyString(auxDataItem.___2667)); *type = ___270; *___3361 = auxDataItem.m_retain; } ___372 ___4016::___896() const { return static_cast<___372>(m_tecioData.unflushedZoneSet().size() > 0); } ___372 ___4016::datasetGetTitle(char** datasetTitle) const { *datasetTitle = copyString(m_tecioData.___4177()); return ___4226; } int32_t ___4016::___889() const { return 0; } ___3501 ___4016::datasetGetRelevantZones(double  , double /*solutionTimeMax*/, ___372 /*ignoreStaticZones*/) const { ___478(___1305); return ___3501(0); } ___4636 ___4016::___891() const { REQUIRE(___896()); return static_cast<___4636>(*m_tecioData.unflushedZoneSet().rbegin()); } ___4352 ___4016::___890() const { REQUIRE(___896()); return static_cast<___4352>(m_tecioData.variableNames().size()); } ___4352 ___4016::___4345(char ___214) const { REQUIRE('X' <= ___214 && ___214 <= 'Z'); return static_cast<___4352>(___214 - 'X' + 1); } ___372 ___4016::___4344(___4352 ___4368, char** ___4362) const { REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); REQUIRE(VALID_REF(___4362) && !*___4362); *___4362 = copyString(m_tecioData.variableNames()[___4368 - 1]); return ___4226; } int32_t ___4016::___4343(___4352 ___4368) const { REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); return static_cast<int32_t>(m_tecioData.varAuxData()[___4368]->m_auxDataItems.size()); } ___372 ___4016::___4638(___4636 ___4658) const { return (m_tecioData.zonePtr(___4658) != NULL) ? ___4226 : ___1305; } ___372 ___4016::___4614(___3501* ___1153) const { try { std::set<___3493>* ___3358 = new std::set<___3493>(m_tecioData.unflushedZoneSet()); *___1153 = reinterpret_cast<___3501>(___3358); return ___4226; } catch (...) { return ___1305; } } ZoneType_e ___4016::___4620(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2684; } void ___4016::___4615(___4636 ___4658, ___1844& ___2715) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); ___2715 = zonePtr->___2682; } ___372 ___4016::___4616(___4636 ___4658, char** ___4652) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(VALID_REF(___4652) && !*___4652); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); *___4652 = copyString(zonePtr->___2683); return ___4226; } ___4636 ___4016::___4617(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658));
Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2614; } double ___4016::___4618(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2621; } ___1172 ___4016::___4619(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2622; } int32_t ___4016::___4613(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return static_cast<int32_t>(zonePtr->___2345->m_auxDataItems.size()); } ___372 ___4016::___4640(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return static_cast<___372>(zonePtr->___2684 != ___4704); } ___372 ___4016::___4641(tecplot::___3933::___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return static_cast<___372>(zonePtr->___2684 == ___4704); } ___372 ___4016::___4353(___4352 ASSERT_ONLY(___4368)) const { REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); return ___4226; } ___372 ___4016::varGetEnabled(___3501* enabledVars) const { ___478(___1305); *enabledVars = ___3501(0); return ___4226; } int32_t ___4016::solutionTimeGetNumTimeSteps() const { ___478(___1305); return 0; } double ___4016::solutionTimeGetMinTime() const { ___478(___1305); return 0.0; } double ___4016::solutionTimeGetMaxTime() const { ___478(___1305); return 0.0; } ___372 ___4016::___3768() const { return ___4226; } GeomID_t ___4016::___1592(void) { if (!m_tecioData.geoms().empty()) return reinterpret_cast<GeomID_t>(&m_tecioData.geoms()[0]); return ___4035; } TextID_t ___4016::___4087(void) { if (!m_tecioData.texts().empty()) return reinterpret_cast<TextID_t>(&m_tecioData.texts()[0]); return ___4035; } int32_t ___4016::___797(void) { return (int32_t)m_tecioData.customLabels().size(); } ___372 ___4016::___796(___3839* ___2171, int32_t ___4453) { REQUIRE(0 < ___4453 && ___4453 <= (int32_t)m_tecioData.customLabels().size()); try { *___2171 = new StringList_s; (*___2171)->m_strings = m_tecioData.customLabels()[___4453 - 1]; return ___4226; } catch(...) { return ___1305; } } void ___4016::___858() { } void ___4016::___859() { } void ___4016::___3779(char const* ___3001, ___372 ___3584, ___372 ___3579) const { ___4278(___3001); ___4278(___3584); ___4278(___3579); } void ___4016::___3778(char const* ___3001) const { ___4278(___3001); } ___372 ___4016::___3769(int percentDone) const { ___4278(percentDone); return ___4226; } void ___4016::___3770(void) const { } ___372 ___4016::___1983(void) const { return ___1305; } ___4636 ___4016::___544(___3501 ___4684, ___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); try { Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); boost::shared_ptr<___2730> ___2723 = zonePtr->___2497; if (___2723 && ___2723.use_count() > 1) { std::set<___3493>* ___4671 = reinterpret_cast<std::set<___3493>*>(___4684); if (___4671 == NULL) { ___4636 testZoneNum = ___4658; while (testZoneNum != 1) { --testZoneNum; Zone_s const* testZonePtr = m_tecioData.zonePtr(testZoneNum); if (testZonePtr && testZonePtr->___2497 == ___2723) return testZoneNum; } } else { std::set<___3493>::iterator zoneIt = ___4671->find(___4658); ___478(zoneIt != ___4671->end()); while (zoneIt != ___4671->begin()) { --zoneIt; Zone_s const* testZonePtr = m_tecioData.zonePtr(static_cast<___4636>(*zoneIt)); ___478(testZonePtr != NULL); if (testZonePtr->___2497 == ___2723) return static_cast<___4636>(*zoneIt); } } } return ___4035; } catch (...) { return ___4035; } } ___3501 ___4016::___545(___4636 zone) const { REQUIRE(m_tecioData.validZoneNum(zone)); Zone_s const* zonePtr = m_tecioData.zonePtr(zone); try { std::set<___3493>* ___3358 = new std::set<___3493>; boost::shared_ptr<___2730> ___2728 = zonePtr->___2497; if (___2728) { BOOST_FOREACH(___3493 ___4658, m_tecioData.zoneSet()) { if (m_tecioData.zonePtr(static_cast<___4636>(___4658))->___2497 == ___2728) ___3358->insert(___4658); } } return reinterpret_cast<___3501>(___3358); } catch (...) { return NULL; } } ValueLocation_e ___4016::___910(___4636 ___4658, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size()));
Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2670[___4368 - 1]; } ValueLocation_e ___4016::___911(___1361 ___1351) const { REQUIRE(VALID_REF(___1351)); return ___1351->___2669; } ___372 ___4016::___913( ___4636 ___4658, ___4352 ___4336, double* minVal, double* maxVal) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4336 && ___4336 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); if (zoneIsPartitioned(___4658)) { if (zonePtr->m_partitionMap.empty()) { *minVal = 0.0; *maxVal = 0.0; } else { *minVal = std::numeric_limits<double>::max(); *maxVal = -std::numeric_limits<double>::max(); BOOST_FOREACH(Zone_s::ZoneMap::value_type const& valuePair, zonePtr->m_partitionMap) { double partitionMinVal = 0.0; double partitionMaxVal = 0.0; valuePair.second->___2496[___4336 - 1]->___1759(partitionMinVal, partitionMaxVal); *minVal = std::min(*minVal, partitionMinVal); *maxVal = std::max(*maxVal, partitionMaxVal); } } } else { zonePtr->___2496[___4336 - 1]->___1759(*minVal, *maxVal); } ENSURE(*minVal <= *maxVal); return ___4226; } ___372 ___4016::___912( ___1361 ___1351, double* minVal, double* maxVal) const { ___1351->___1759(*minVal, *maxVal); return ___4226; } FieldDataType_e ___4016::___923(___4636 ___4658, ___4352 ___4368) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2460[___4368 - 1]; } ___1172 ___4016::___921(___4636 ___4658, ___4352 ___4368) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); ___1172 shareCount = 0; BOOST_FOREACH(___3493 testZoneNum, m_tecioData.zoneSet()) if (m_tecioData.zonePtr(static_cast<___4636>(testZoneNum))-> ___2496[___4368 - 1] == zonePtr->___2496[___4368 - 1]) ++shareCount; return shareCount; } ___1361 ___4016::___918(___4636 ___4658, ___4352 ___4368) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); if (zonePtr->___2496[___4368 - 1]->___2669 == ___4330) return ___917(___4658, ___4368); else return ___916(___4658, ___4368); } ___1361 ___4016::___915(___4636 ___4658, ___4352 ___4368) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); if (zonePtr->___2496[___4368 - 1]->___2669 == ___4328) return ___917(___4658, ___4368); else return ___916(___4658, ___4368); } ___1361 ___4016::___917(___4636 ___4658, ___4352 ___4368) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2496[___4368 - 1].get(); } ___1361 ___4016::___916(___4636 ___4658, ___4352 ___4368) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s* zonePtr = m_tecioData.zonePtr(___4658); try { if (zonePtr->___2400[___4368 - 1]->storedValueCount() == 0) { if (zonePtr->___2496[___4368 - 1]->___2669 == ___4328) zonePtr->___965(___4368); else zonePtr->deriveCCValues(___4368); } } catch (std::exception const&) { } return zonePtr->___2400[___4368 - 1].get(); } ___1361 ___4016::___924(___4636 ___4658, ___4352 ___4368) { return ___917(___4658, ___4368); } namespace { double STDCALL fieldValueGetFunction(___1361 const ___1351, ___2227 ___2733) { REQUIRE(VALID_REF(___1351)); REQUIRE(0 <= ___2733); size_t index = static_cast<size_t>(___2733); REQUIRE(___1351->___2668 == 0 || index < ___1351->___2668); if (index < ___1351->___2668) return ___1351->___1780(index); return 0.0; } void STDCALL fieldValueSetFunction(___1361 ___1351, ___2227 ___2733, double ___4298) { REQUIRE(VALID_REF(___1351)); REQUIRE(0 <= ___2733); size_t index = static_cast<size_t>(___2733); REQUIRE(___1351->___2668 == 0 || index < ___1351->___2668);
if (index < ___1351->___2668) ___1351->___3504(index, ___4298); } } double ___4016::___909(___1361 ___1351, ___81 ___2733) { REQUIRE(VALID_REF(___1351)); REQUIRE(0 < ___2733); return fieldValueGetFunction(___1351, ___2733 - 1); } void ___4016::dataValueSetByRef(___1361 ___1351, ___81 ___2733, double ___4298) { REQUIRE(VALID_REF(___1351)); REQUIRE(0 < ___2733); fieldValueSetFunction(___1351, ___2733 - 1, ___4298); } void ___4016::___919(___4636 ___4658, ___4352 ___4368, void** ___880, FieldDataType_e* ___1363) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); *___880 = zonePtr->___2496[___4368 - 1]->getRawPointer(); *___1363 = zonePtr->___2496[___4368 - 1]->___2459; } void ___4016::___925(___4636 ___4658, ___4352 ___4368, void** ___880, FieldDataType_e* ___1363) { ___919(___4658, ___4368, ___880, ___1363); } ___4636 ___4016::___914(___3501 ___4684, ___4636 ___4658, ___4352 ___4336) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); try { boost::shared_ptr<___1362> nativeFD = zonePtr->___2496[___4336 - 1]; if (IMPLICATION(nativeFD, nativeFD.use_count() > 1)) { std::set<___3493>* ___4671 = reinterpret_cast<std::set<___3493>*>(___4684); if (___4671 == NULL) { ___4636 testZoneNum = ___4658; while (testZoneNum != 1) { --testZoneNum; Zone_s const* testZonePtr = m_tecioData.zonePtr(testZoneNum); if (testZonePtr && testZonePtr->___2496[___4336 - 1] == nativeFD) return testZoneNum; } } else { std::set<___3493>::iterator zoneIt = ___4671->find(___4658); REQUIRE(zoneIt != ___4671->end()); while (zoneIt != ___4671->begin()) { --zoneIt; Zone_s const* testZonePtr = m_tecioData.zonePtr(static_cast<___4636>(*zoneIt)); ___478(testZonePtr != NULL); if (testZonePtr->___2496[___4336 - 1] == nativeFD) return static_cast<___4636>(*zoneIt); } } } return ___4035; } catch (...) { return ___4035; } } ___3501 ___4016::___922(___4636 ___4658, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); try { std::set<___3493>* ___3358 = new std::set<___3493>; boost::shared_ptr<___1362> nativeFD = zonePtr->___2496[___4368 - 1]; BOOST_FOREACH(___3493 ___4658, m_tecioData.zoneSet()) { Zone_s* zonePtr = m_tecioData.zonePtr(static_cast<___4636>(___4658)); if (zonePtr->___2496[___4368 - 1] == nativeFD) ___3358->insert(___4658); } return reinterpret_cast<___3501>(___3358); } catch (...) { return NULL; } } ___372 ___4016::___926(___4636 ___4658, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return (zonePtr->___2496[___4368 - 1]->___2668 > 0 ? ___1305 : ___4226); } ___1383 ___4016::___927(___1361 ___1309) { ___4278(___1309); return fieldValueGetFunction; } ___1384 ___4016::___928(___1361 ___1309) { ___4278(___1309); return fieldValueSetFunction; } FieldDataType_e ___4016::___920(___1361 ___1351) { return ___1351->___2459; } ___2727 ___4016::___867(___4636 ___4658) { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2497.get(); } ___2727 ___4016::___869(___4636 ___4658) { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2497.get(); } ___2718 ___4016::___865( ___2727 ___2723, ___465 ___468, ___682 ___683) { REQUIRE(VALID_REF(___2723)); REQUIRE(0 < ___468 && ___468 <= static_cast<___465>(___2723->___2392)); REQUIRE(0 < ___683 && ___683 <= ___2723->___2500); ___465 ___462 = ___468 - 1; int64_t ___2716 = ___2723->___4314(___462 * ___2723->___2500 + ___683 - 1); return (___2718)___2716 + 1; } void ___4016::___870(___2727 ___2723, ___465 ___468, ___682 ___683, ___2718 ___2716) { REQUIRE(VALID_REF(___2723)); REQUIRE(0 < ___468 && ___468 <= static_cast<___465>(___2723->___2392)); REQUIRE(0 < ___683 && ___683 <= ___2723->___2500); ___2723->___3504((___468 - 1) * ___2723->___2500 + ___683 - 1, ___2716 - 1);
} OffsetDataType_e ___4016::dataNodeGetRawItemType(___2727 ___2723) { REQUIRE(VALID_REF(___2723)); return ___2723->getRawItemType(); } int32_t* ___4016::dataNodeGetRawPtrByRef(___2727 ___2723) { REQUIRE(VALID_REF(___2723)); return reinterpret_cast<int32_t*>(___2723->getRawPtr()); } int64_t* ___4016::dataNodeGetRawPtrByRef64(___2727 ___2723) { REQUIRE(VALID_REF(___2723)); return reinterpret_cast<int64_t*>(___2723->getRawPtr()); } ___2742 ___4016::dataNodeToElemMapGetReadableRef(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s* zonePtr = m_tecioData.zonePtr(___4658); if (!zonePtr->m_nodeToElemMap) zonePtr->m_nodeToElemMap.reset(new ___2743(*zonePtr->___2497, zonePtr->___2682.___1670())); return zonePtr->m_nodeToElemMap.get(); } ___465 ___4016::dataNodeToElemMapGetNumElems(___2742 nodeToElemMap, ___2718 ___2709) const { REQUIRE(VALID_REF(nodeToElemMap)); REQUIRE(0 < ___2709 && ___2709 <= nodeToElemMap->m_nodeCount); return nodeToElemMap->m_elemIndex[___2709] - nodeToElemMap->m_elemIndex[___2709 - 1]; } ___465 ___4016::dataNodeToElemMapGetElem(___2742 nodeToElemMap, ___2718 ___2709, ___465 elemOffset) const { REQUIRE(VALID_REF(nodeToElemMap)); REQUIRE(0 < ___2709 && ___2709 <= nodeToElemMap->m_nodeCount); REQUIRE(0 < elemOffset && elemOffset <= nodeToElemMap->m_elemIndex[___2709] - nodeToElemMap->m_elemIndex[___2709 - 1]); return nodeToElemMap->m_elem[nodeToElemMap->m_elemIndex[___2709 - 1] + elemOffset - 1] + 1; } FaceNeighborMode_e ___4016::___836(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2458; } void ___4016::___837( ___1292 ___1274, ___2227 ___1144, int32_t face, int32_t ___2692, ___2227* ___2691, ___4636* ___2695) const { Zone_s const* zonePtr = reinterpret_cast<Zone_s const*>(___1274); REQUIRE(VALID_REF(zonePtr)); Zone_s::___458 ___457; ___457.first = static_cast<int32_t>(___1144); ___457.second = face; Zone_s::___1276::const_iterator iter = zonePtr->___2457.find(___457); ___478(iter != zonePtr->___2457.end()); ___478(0 < ___2692 && ___2692 <= (___2227)iter->second.___2678.size()); *___2691 = iter->second.___2678[___2692 - 1].second; *___2695 = iter->second.___2678[___2692 - 1].first; } ___372 ___4016::___835( ___1292 ___1274, ___2227 ___1144, int32_t face, ___3501 ___4) const { ___4278(___4); Zone_s const* zonePtr = reinterpret_cast<Zone_s const*>(___1274); REQUIRE(VALID_REF(zonePtr)); Zone_s::___458 ___457; ___457.first = static_cast<int32_t>(___1144); ___457.second = face; Zone_s::___1276::const_iterator iter = zonePtr->___2457.find(___457); if (iter == zonePtr->___2457.end()) return ___1305; else return iter->second.___2488; } int32_t ___4016::___838(___1292 ___1274, ___2227 ___1144, int32_t face, ___372*  ) const { Zone_s const* zonePtr = reinterpret_cast<Zone_s const*>(___1274); REQUIRE(VALID_REF(zonePtr)); Zone_s::___458 ___457; ___457.first = static_cast<int32_t>(___1144); ___457.second = face; Zone_s::___1276::const_iterator iter = zonePtr->___2457.find(___457); if (iter == zonePtr->___2457.end()) return 0; else return (int32_t)iter->second.___2678.size(); } ___1292 ___4016::___839(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s* zonePtr = m_tecioData.zonePtr(___4658); return reinterpret_cast<___1292>(zonePtr); } ___372 ___4016::setAddMember(___3501 set, ___3493 ___2401, ___372 showErr) const { std::set<___3493>* setPtr = reinterpret_cast<std::set<___3493>*>(set); REQUIRE(VALID_REF(setPtr)); try { setPtr->insert(___2401); } catch (std::bad_alloc const&) { if (showErr) std::cerr << "Allocation failure adding member to set." << std::endl; return ___1305; } return ___4226; } ___3501 ___4016::setAlloc(___372 showErr) const { std::set<___3493>* ___3358 = NULL; try { ___3358 = new std::set<___3493>(); } catch (std::bad_alloc const&) { if (showErr) std::cerr << "Allocation failure allocating set." << std::endl; } return reinterpret_cast<___3501>(___3358); } void ___4016::___3484(___3501* set) const { REQUIRE(VALID_REF(set)); std::set<___3493>* setPtr = *(reinterpret_cast<std::set<___3493>**>(set)); REQUIRE(VALID_REF_OR_NULL(setPtr)); delete setPtr; *set = NULL; } ___3493 ___4016::___3491(___3501 set, ___3493 ___2401) const { std::set<___3493>* setPtr = reinterpret_cast<std::set<___3493>*>(set); REQUIRE(VALID_REF(setPtr)); std::set<___3493>::iterator it; if (___2401 == ___4039) { it = setPtr->begin();
} else { it = setPtr->find(___2401); if (it != setPtr->end()) ++it; } if (it == setPtr->end()) return ___4039; else return *it; } ___3493 ___4016::setGetPrevMember(___3501 set, ___3493 ___2401) const { std::set<___3493>* setPtr = reinterpret_cast<std::set<___3493>*>(set); REQUIRE(VALID_REF(setPtr)); std::set<___3493>::reverse_iterator it; if (___2401 == ___4039) { it = setPtr->rbegin(); } else { it = setPtr->rbegin(); while (it != setPtr->rend() && *it != ___2401) ++it; if (it != setPtr->rend()) ++it; } if (it == setPtr->rend()) return ___4039; else return *it; } ___3493 ___4016::setGetMemberCount(___3501 set) const { std::set<___3493>* setPtr = reinterpret_cast<std::set<___3493>*>(set); REQUIRE(VALID_REF(setPtr)); return static_cast<___3493>(setPtr->size()); } ___372 ___4016::___3495(___3501 set, ___3493 ___2401) const { std::set<___3493>* setPtr = reinterpret_cast<std::set<___3493>*>(set); REQUIRE(VALID_REF(setPtr)); return setPtr->find(___2401) != setPtr->end(); } ___372 ___4016::setIsEqual(___3501 ___3477, ___3501 ___3478) const { std::set<___3493>* set1Ptr = reinterpret_cast<std::set<___3493>*>(___3477); std::set<___3493>* set2Ptr = reinterpret_cast<std::set<___3493>*>(___3478); REQUIRE(VALID_REF(set1Ptr) && VALID_REF(set2Ptr)); return *set1Ptr == *set2Ptr; } void ___4016::setRemoveMember(___3501 set, ___3493 ___2401) const { std::set<___3493>* setPtr = reinterpret_cast<std::set<___3493>*>(set); REQUIRE(VALID_REF(setPtr)); setPtr->erase(___2401); } void ___4016::___1557(GeomID_t ___1805, int32_t ___3157, ___2227 ___3141, double* x, double* ___4583) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); REQUIRE(___1555->___2466 == GeomType_LineSegs); REQUIRE(0 < ___3157 && ___3157 <= (int32_t)___1555->___2464.size()); REQUIRE(0 < ___3141 && ___3141 <= (___2227)___1555->___2464[___3157 - 1].size()); *x = ___1555->___2464[___3157 - 1][___3141 - 1].x(); *___4583 = ___1555->___2464[___3157 - 1][___3141 - 1].___4583(); } void ___4016::___1558(GeomID_t ___1805, ___2227 ___3141, double* x, double* ___4583) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); REQUIRE(___1555->___2466 == GeomType_LineSegs); REQUIRE(0 < ___3141 && ___3141 < (___2227)___1555->___2464[0].size()); *x = ___1555->___2464[0][___3141 - 1].x(); *___4583 = ___1555->___2464[0][___3141 - 1].___4583(); } void ___4016::___1560(GeomID_t ___1805, int32_t ___3157, ___2227 ___3141, double* x, double* ___4583, double* z) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); REQUIRE(___1555->___2466 == GeomType_LineSegs && ___1555->___2616 == CoordSys_Grid3D); REQUIRE(0 < ___3157 && ___3157 <= (int32_t)___1555->___2464.size()); REQUIRE(0 < ___3141 && ___3141 <= (___2227)___1555->___2464[___3157 - 1].size()); *x = ___1555->___2464[___3157 - 1][___3141 - 1].x(); *___4583 = ___1555->___2464[___3157 - 1][___3141 - 1].___4583(); *z = ___1555->___2464[___3157 - 1][___3141 - 1].z(); } void ___4016::___1561(GeomID_t ___1805, ___2227 ___3141, double* x, double* ___4583, double* z) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); REQUIRE(___1555->___2466 == GeomType_LineSegs && ___1555->___2616 == CoordSys_Grid3D); REQUIRE(0 < ___3141 && ___3141 < (___2227)___1555->___2464[0].size()); *x = ___1555->___2464[0][___3141 - 1].x(); *___4583 = ___1555->___2464[0][___3141 - 1].___4583(); *z = ___1555->___2464[0][___3141 - 1].z(); } double ___4016::___1564(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2340; } ArrowheadAttachment_e ___4016::___1565(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2341; } double ___4016::___1566(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2342; } ArrowheadStyle_e ___4016::___1567(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2343; } double ___4016::___1570(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); REQUIRE(___1555->___2466 == GeomType_Circle); REQUIRE(___1555->___2464.size() == 1); REQUIRE(___1555->___2464[0].size() == 1); return ___1555->___2464[0][0].x(); } int32_t ___4016::___1576(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); REQUIRE(___1555->___2466 == GeomType_Ellipse || ___1555->___2466 == GeomType_Circle); return static_cast<int32_t>(___1555->___2502); } void ___4016::___1577(GeomID_t ___1805, double* ___1824, double* ___4394) const
{ ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); REQUIRE(___1555->___2466 == GeomType_Ellipse); REQUIRE(___1555->___2464.size() == 1); REQUIRE(___1555->___2464.size() == 1); *___1824 = ___1555->___2464[0][0].x(); *___4394 = ___1555->___2464[0][0].___4583(); } void ___4016::___1591(GeomID_t ___1805, double* ___4574, double* ___4591, double* ___4715) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); *___4574 = ___1555->___2617[0]; *___4591 = ___1555->___2617[1]; *___4715 = ___1555->___2617[2]; } Clipping_e ___4016::___1593(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2394; } ___516 ___4016::___1594(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2395; } DrawOrder_e ___4016::___1595(GeomID_t  ) const { return ___1114; } ___516 ___4016::___1596(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2462; } ___372 ___4016::___1597(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2486; } LinePattern_e ___4016::___1598(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2489; } double ___4016::___1599(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2490; } ___372 ___4016::___1600(GeomID_t ___1805, char** macroFunctionCmd) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); *macroFunctionCmd = copyString(___1555->___2491); return ___4226; } GeomID_t ___4016::___1601(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); size_t nextIndex = std::distance(&m_tecioData.geoms()[0], ___1555) + 1; if (nextIndex == m_tecioData.geoms().size()) return ___4035; return reinterpret_cast<GeomID_t>(&m_tecioData.geoms()[nextIndex]); } double ___4016::___1602(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2615; } CoordSys_e ___4016::___1603(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2616; } GeomID_t ___4016::___1604(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); size_t geomIndex = std::distance(&m_tecioData.geoms()[0], ___1555); if (geomIndex == 0) return ___4035; return reinterpret_cast<GeomID_t>(&m_tecioData.geoms()[geomIndex - 1]); } Scope_e ___4016::___1605(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2619; } GeomForm_e ___4016::___1606(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2466; } ___4636 ___4016::___1607(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2677; } ___372 ___4016::___1610(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); return ___1555->___2484; } ___2227 ___4016::___1619(GeomID_t ___1805, int32_t ___3157) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); REQUIRE(___1555->___2466 == GeomType_LineSegs); REQUIRE(0 < ___3157 && ___3157 <= (int32_t)___1555->___2464.size()); return (___2227)___1555->___2464[___3157 - 1].size(); } ___2227 ___4016::___1620(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); REQUIRE(___1555->___2466 == GeomType_LineSegs); return (___2227)___1555->___2464.size(); } ___2227 ___4016::___1626(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); REQUIRE(___1555->___2466 == GeomType_LineSegs); REQUIRE(___1555->___2464.size() == 1); return (___2227)___1555->___2464[0].size(); } void ___4016::___1628(GeomID_t ___1805, double* ___4458, double* ___1826) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); REQUIRE(___1555->___2466 == GeomType_Rectangle); REQUIRE(___1555->___2464.size() == 1); *___4458 = ___1555->___2464[0][0].x(); *___1826 = ___1555->___2464[0][0].___4583(); } double ___4016::___1648(GeomID_t ___1805) const { ___1556 const* ___1555 = reinterpret_cast<___1556*>(___1805); REQUIRE(VALID_REF(___1555)); REQUIRE(___1555->___2466 == GeomType_Square); REQUIRE(___1555->___2464.size() == 1); return ___1555->___2464[0][0].x(); } ___516 ___4016::___4064(TextID_t ___4171) const
{ Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2628; } ___516 ___4016::___4065(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2629; } double ___4016::___4066(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2630; } double ___4016::___4067(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2631; } TextBox_e ___4016::___4068(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2632; } TextAnchor_e ___4016::___4084(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2625; } void ___4016::___4085(TextID_t ___4171, double* ___4574, double* ___4591, double* ___4715) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); REQUIRE(VALID_REF(___4574)); REQUIRE(VALID_REF(___4591)); REQUIRE(VALID_REF(___4715)); *___4574 = ___4042->___2626[0]; *___4591 = ___4042->___2626[1]; *___4715 = ___4042->___2626[2]; } double ___4016::___4086(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2627; } Clipping_e ___4016::___4088(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2633; } ___516 ___4016::___4089(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2634; } double ___4016::___4090(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2635; } double ___4016::___4091(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2637; } ___372 ___4016::___4092(TextID_t ___4171, char** ___2330) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); REQUIRE(VALID_REF(___2330)); if (!___4042->___2638.empty()) { *___2330 = copyString(___4042->___2638); return ___4226; } return ___1305; } TextID_t ___4016::___4093(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); size_t nextIndex = std::distance(&m_tecioData.texts()[0], ___4042) + 1; if (nextIndex == m_tecioData.texts().size()) return ___4035; return reinterpret_cast<TextID_t>(&m_tecioData.texts()[nextIndex]); } CoordSys_e ___4016::___4094(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2639; } TextID_t ___4016::___4095(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); size_t textIndex = std::distance(&m_tecioData.texts()[0], ___4042); if (textIndex == 0) return ___4035; return reinterpret_cast<TextID_t>(&m_tecioData.texts()[textIndex - 1]); } Scope_e ___4016::___4096(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2641; } Units_e ___4016::___4097(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2642; } ___372 ___4016::___4098(TextID_t ___4171, char** ___4126) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); REQUIRE(VALID_REF(___4126)); if (!___4042->___2643.empty()) { *___4126 = copyString(___4042->___2643); return ___4226; } return ___1305; } char* ___4016::___4099(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return copyString(___4042->___2644); } ___372 ___4016::___4100(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2645; } ___372 ___4016::___4101(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2646; } ___4636 ___4016::___4102(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2647; } ___372 ___4016::___4105(TextID_t ___4171) const { Text const* ___4042 = reinterpret_cast<Text*>(___4171); REQUIRE(VALID_REF(___4042)); return ___4042->___2636; } ___372 ___4016::___4304(___1361 ASSERT_ONLY(___1351)) const { REQUIRE(VALID_REF(___1351));
return ___4226; } ___372 ___4016::___4309(___2727 ASSERT_ONLY(___2723)) const { REQUIRE(VALID_REF(___2723)); return ___4226; } PlotType_e ___4016::___1513() const { return ___3115; } ___2664 ___4016::___4152() { return new ___2665; } void ___4016::___4153(___2664* mutex) { delete *mutex; *mutex = NULL; } void ___4016::___4154(___2664 mutex) {
 #if defined TECIOMPI
___478(___1305); ___4278(mutex);
 #else
mutex->lock();
 #endif
} void ___4016::___4155(___2664 mutex) {
 #if defined TECIOMPI
___4278(mutex);
 #else
mutex->unlock();
 #endif
} void ___4016::___4156(___4160 ___2118, ___90 ___2123, ___2120 ___2119) {
 #if defined TECIOMPI
___4278(___2119); ___2118(___2123);
 #else
___2119->addJob(___2118, ___2123);
 #endif
} int ___4016::___4157() {
 #if defined TECIOMPI
return 1;
 #else
return ___2122::___2827();
 #endif
} ___2120 ___4016::___4158() { return new ___2122; } void ___4016::___4159(___2120* ___2119) { delete *___2119; *___2119 = NULL; } void ___4016::___4161(___2120 ___2119) {
 #if defined TECIOMPI
___4278(___2119);
 #else
___2119->wait();
 #endif
} int32_t ___4016::datasetGetNumPartitionFiles() const { return 0; } int32_t ___4016::zoneGetOwnerProcess(tecplot::___3933::___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(!zoneIsPartitioned(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); ___478(IMPLICATION(!zonePtr->m_partitionOwners.empty(), zonePtr->m_partitionOwners.size() == 1)); if (zonePtr->m_partitionOwners.empty()) return 0; return zonePtr->m_partitionOwners[0]; } int32_t ___4016::zonePartitionGetOwnerProcess(tecplot::___3933::___4636 ___4658, tecplot::___3933::___4636 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); ___478(IMPLICATION(!zonePtr->m_partitionOwners.empty(), static_cast<size_t>(partitionNum) <= zonePtr->m_partitionOwners.size())); if (zonePtr->m_partitionOwners.empty()) return 0; return zonePtr->m_partitionOwners[partitionNum - 1]; } ___372 ___4016::zoneIsPartitioned(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); if (zonePtr->m_partitionOwners.empty()) return zonePtr->m_partitionMap.empty() ? ___1305 : ___4226; return (zonePtr->m_partitionOwners.size() > 1); } ___4636 ___4016::zoneGetNumPartitions(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); if (zonePtr->m_partitionOwners.empty()) return static_cast<___4636>(zonePtr->m_partitionMap.size()); return static_cast<___4636>(zonePtr->m_partitionOwners.size()); } namespace { Zone_s* getPartitionPtr(Zone_s::ZoneMap const& partitionMap, ___4636 partitionNum) { REQUIRE(partitionNum > 0); Zone_s::ZoneMap::const_iterator it = partitionMap.find(partitionNum - 1); if (it == partitionMap.end()) return NULL; else return it->second.get(); } } void ___4016::zonePartitionGetIJK(___4636 ___4658, ___4636 partitionNum, ___1844& ___1861) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___1861 = partitionPtr->___2682; } void ___4016::zonePartitionGetIJKOffset(tecplot::___3933::___4636 ___4658, tecplot::___3933::___4636 partitionNum, tecplot::___3933::___1844& ___1862) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(___4641(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___478(partitionPtr != NULL); ___1862 = partitionPtr->m_partitionOffset; } ___372 ___4016::dataValueGetMinMaxByZonePartitionVar( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4336, double* minVal, double* maxVal) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); REQUIRE(0 < ___4336 && ___4336 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); partitionPtr->___2496[___4336 - 1]->___1759(*minVal, *maxVal); return ___4226; } ___1361 ___4016::dataValuePartitionGetReadableNLRef( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); REQUIRE(zonePtr != NULL); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___478(partitionPtr != NULL); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); if (partitionPtr->___2496[___4368 - 1]->___2669 == ___4330) return dataValuePartitionGetReadableNativeRef(___4658, partitionNum, ___4368); else return dataValuePartitionGetReadableDerivedRef(___4658, partitionNum, ___4368); } ___1361 ___4016::dataValuePartitionGetReadableCCRef( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); if (partitionPtr->___2496[___4368 - 1]->___2669 == ___4328) return dataValuePartitionGetReadableNativeRef(___4658, partitionNum, ___4368); else
return dataValuePartitionGetReadableDerivedRef(___4658, partitionNum, ___4368); } ___1361 ___4016::dataValuePartitionGetReadableNativeRef( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___1361 ___3358 = partitionPtr->___2496[___4368 - 1].get(); return ___3358; } ___1361 ___4016::dataValuePartitionGetReadableDerivedRef( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); try { if (partitionPtr->___2400[___4368 - 1]->storedValueCount() == 0) { if (partitionPtr->___2496[___4368 - 1]->___2669 == ___4328) partitionPtr->___965(___4368); else partitionPtr->deriveCCValues(___4368); } } catch (std::exception const&) { } return partitionPtr->___2400[___4368 - 1].get(); } ___1361 ___4016::dataValuePartitionGetWritableNativeRef( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); return dataValuePartitionGetReadableNativeRef(___4658, partitionNum, ___4368); } void ___4016::dataValuePartitionGetReadableRawPtr( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368, void** ___880, FieldDataType_e* ___1363) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); *___880 = partitionPtr->___2496[___4368 - 1]->getRawPointer(); *___1363 = partitionPtr->___2496[___4368 - 1]->___2459; } void ___4016::dataValuePartitionGetWritableRawPtr( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368, void** ___880, FieldDataType_e* ___1363) const { dataValuePartitionGetReadableRawPtr(___4658, partitionNum, ___4368, ___880, ___1363); } ___2727 ___4016::dataNodePartitionGetReadableRef( ___4636 ___4658, ___4636 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___2727 ___3358 = partitionPtr->___2497.get(); return ___3358; } ___2727 ___4016::dataNodePartitionGetWritableRef( ___4636 ___4658, ___4636 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); return dataNodePartitionGetReadableRef(___4658, partitionNum); } ___2742 ___4016::dataNodeToElemMapPartitionGetReadableRef( tecplot::___3933::___4636 ___4658, tecplot::___3933::___4636 partitionNum ) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); if (!partitionPtr->m_nodeToElemMap) partitionPtr->m_nodeToElemMap.reset(new ___2743(*partitionPtr->___2497, partitionPtr->___2682.___1670())); return partitionPtr->m_nodeToElemMap.get(); } GhostInfo_pa ___4016::zoneGhostNodeInfoGetRef(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return &zonePtr->m_ghostNodeInfo; } GhostInfo_pa ___4016::zoneGhostCellInfoGetRef(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return &zonePtr->m_ghostCellInfo; } GhostInfo_pa ___4016::zonePartitionGhostNodeInfoGetRef( tecplot::___3933::___4636 ___4658, tecplot::___3933::___4636 partitionNum) const
{ REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return &partitionPtr->m_ghostNodeInfo; } GhostInfo_pa ___4016::zonePartitionGhostCellInfoGetRef(tecplot::___3933::___4636 ___4658, tecplot::___3933::___4636 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return &partitionPtr->m_ghostCellInfo; } ___81 ___4016::ghostInfoGetNumItemsByRef(GhostInfo_pa ghostInfo) const { REQUIRE(VALID_REF(ghostInfo)); return static_cast<___81>(ghostInfo->m_items.size()); } ___81 ___4016::ghostInfoGetItemByRef( GhostInfo_pa ghostInfo, ___81 itemNum) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(0 < itemNum && itemNum <= static_cast<___81>(ghostInfo->m_items.size())); return static_cast<___81>(ghostInfo->m_items[itemNum - 1]); } ___2090::___2980 ___4016::ghostInfoGetNeighborByRef( GhostInfo_pa ghostInfo, ___81 itemNum) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(0 < itemNum && itemNum <= static_cast<___81>(ghostInfo->m_neighbors.size())); return ghostInfo->m_neighbors[itemNum - 1]; } ___81 ___4016::ghostInfoGetNeighborItemByRef( GhostInfo_pa ghostInfo, ___81 itemNum) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(0 < itemNum && itemNum <= static_cast<___81>(ghostInfo->m_neighborItems.size())); return static_cast<___81>(ghostInfo->m_neighborItems[itemNum - 1]); } }}
