#include "MASTER.h"
#include "GLOBAL.h"
 #if defined _MSC_VER && _MSC_VER <= 1800
 #define FUNCTION_NAME __FUNCTION__
 #else
 #define FUNCTION_NAME __func__
 #endif
#include "ThirdPartyHeadersBegin.h"
#include <boost/assign.hpp>
#include <boost/unordered_map.hpp>
#include <iostream>
#include <memory>
#include "ThirdPartyHeadersEnd.h"
#include "TASSERT.h"
#include "TECIO.h"
#include "CHARTYPE.h"
 #if !defined TECIOMPI
#include "TecioPLT.h"
 #endif
#include "TecioSZL.h"
using namespace tecplot::tecioszl;
 #define ___2882 0
 #define ___1340 1
 #define ___1348 2
 #define ___1343 3
 #define ___1347 4
 #define FEBRICK 5
 #define ___1341 6
 #define ___1342 7
 #define ___1535 0
 #define ___1811 1
 #define ___3638 2
 #if defined MSWIN && defined _DEBUG
 #define ___3184(s) do { OutputDebugStringA(s); } while (0)
 #define ___3185(s,a1) do { char ___416[512]; sprintf(___416,s,a1); OutputDebugStringA(___416); } while (0)
 #define ___3186(s,a1,a2) do { char ___416[512]; sprintf(___416,s,a1,a2); OutputDebugStringA(___416); } while (0)
 #else
 #define ___3184(s) printf(s)
 #define ___3185(s,a1) printf(s,a1)
 #define ___3186(s,a1,a2) printf(s,a1,a2)
 #endif
 #define ___23(n, T, s) (new T[n])
 #define ___1530(a, s) (delete[] a);
 #define ___2380 10
 #if !defined _WIN32
 #   define ___1234
 #endif
namespace { int32_t ___691 = -1; int32_t ___1391[___2380] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; int32_t ___2042[___2380]  = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; boost::unordered_map<void*, int32_t> fileFormatForHandle; int firstOpenFile() { for (int ___1832 = 0; ___1832 < ___2380; ++___1832) { if (!___2042[___1832]) return ___1832; } return -1; } struct FileInfo { int32_t m_fileFormat; void* m_typeSpecificData; explicit FileInfo(int32_t ___1390) : m_fileFormat(___1390) , m_typeSpecificData(NULL) {} }; } int32_t tecFileWriterOpen( char const* ___1394, char const* dataSetTitle, char const* variableList, int32_t     ___1390, int32_t     ___1407, int32_t     defaultVarType, void*       gridFileHandle, void**      fileHandle) { void* gridFileTypeSpecificData = NULL; if (___1407 == ___3638) { if (gridFileHandle) { gridFileTypeSpecificData = ((FileInfo*)gridFileHandle)->m_typeSpecificData; } else { ___3184("Err: (tecFileWriterOpen) invalid parameter gridFileHandle.\n"); return -1; } } try {
 #if !defined TECIOMPI
if (___1390 == FILEFORMAT_PLT) { ___3184("Err: (tecFileWriterOpen) .plt format not yet supported\n"); return -1; } else if (___1390 == FILEFORMAT_SZL) {
 #endif
FileInfo* fileInfo = new FileInfo(___1390); if (tecFileWriterOpen_SZL(___1394, dataSetTitle, variableList, ___1407, defaultVarType, gridFileTypeSpecificData, &fileInfo->m_typeSpecificData) == 0) { *fileHandle = fileInfo; } else { delete fileInfo; return -1; }
 #if !defined TECIOMPI
} else { ___3185("Err: (tecFileWriterOpen) invalid value for fileFormat: %d\n", ___1390); return -1; }
 #endif
} catch (std::exception const& e) { ___3185("tecFileWriterOpen: %s\n", e.what()); return -1; } return 0; } int32_t tecFileSetDiagnosticsLevel(void* fileHandle, int32_t level) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecFileSetDiagnosticsLevel) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecFileSetDiagnosticsLevel) .plt format not yet supported\n"); else if (fileInfo->m_fileFormat == FILEFORMAT_SZL)
 #else
else
 #endif
return tecFileSetDiagnosticsLevel_SZL(fileInfo->m_typeSpecificData, level); return -1; }
 #if defined TECIOMPI
int32_t tecMPIInitialize(void* fileHandle, MPI_Comm communicator, int32_t mainRank) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecMPIInitialize) invalid fileHandle parameter\n"); else return tecMPIInitialize_SZL(fileInfo->m_typeSpecificData, communicator, mainRank); return -1; } EXTERNC tecio_API int32_t tecMPIInitializef(void*fileHandle, int32_t communicator, int32_t mainRank) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecMPIInitialize) invalid fileHandle parameter\n"); else if (!MPI_Comm_f2c(communicator)) ___3184("Err: (tecMPIInitialize) invalid communicator parameter\n"); else return tecMPIInitialize_SZL(fileInfo->m_typeSpecificData, MPI_Comm_f2c(communicator), mainRank); return -1; }
 #endif
int32_t tecZoneCreateIJK( void*          fileHandle, char const*    ___4690, int64_t        imax, int64_t        jmax, int64_t        kmax, int32_t const* varTypes, int32_t const* ___3551, int32_t const* valueLocations, int32_t const* ___2982, int32_t        shareFaceNeighborsFromZone, int64_t        ___2802, int32_t        ___1284, int32_t*       zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneCreateIJK) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneCreateIJK) .plt format not yet supported\n");
 #endif
else return tecZoneCreateIJK_SZL( fileInfo->m_typeSpecificData, ___4690, imax, jmax, kmax, varTypes, ___3551, valueLocations, ___2982, shareFaceNeighborsFromZone, ___2802, ___1284, zone); return -1; } int32_t tecZoneCreateFE( void*          fileHandle, char const*    ___4690, int32_t        ___4692, int64_t        ___2821, int64_t        ___2781, int32_t const* varTypes, int32_t const* ___3551, int32_t const* valueLocations, int32_t const* ___2982, int32_t        ___3549, int64_t        ___2802, int32_t        ___1284, int32_t*       zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneCreateFE) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneCreateFE) .plt format not yet supported\n");
 #endif
else return tecZoneCreateFE_SZL( fileInfo->m_typeSpecificData, ___4690, ___4692, ___2821, ___2781, varTypes, ___3551, valueLocations, ___2982, ___3549, ___2802, ___1284, zone); return -1; } int32_t tecZoneCreatePoly( void*          fileHandle, char const*    ___4690, int32_t        ___4692, int64_t        ___2821, int64_t        numFaces, int64_t        ___2781, int64_t        ___4192, int32_t const* varTypes, int32_t const* ___3551, int32_t const* valueLocations, int32_t const* ___2982, int32_t        ___3549, int64_t        ___2786, int64_t        ___4188, int32_t*       zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneCreatePoly) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneCreatePoly) .plt format not yet supported\n");
 #endif
else return tecZoneCreatePoly_SZL( fileInfo->m_typeSpecificData, ___4690, ___4692, ___2821, numFaces, ___2781, ___4192, varTypes, ___3551, valueLocations, ___2982, ___3549, ___2786, ___4188, zone); return -1; } int32_t tecZoneSetUnsteadyOptions( void*   fileHandle, int32_t zone, double  ___3640, int32_t ___3785) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneSetUnsteadyOptions) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneSetUnsteadyOptions) .plt format not yet supported\n");
 #endif
else return tecZoneSetUnsteadyOptions_SZL(fileInfo->m_typeSpecificData, zone, ___3640, ___3785); return -1; } int32_t tecZoneSetParentZone( void*   fileHandle, int32_t zone, int32_t ___2974) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneSetParentZone) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneSetParentZone) .plt format not yet supported\n");
 #endif
else return tecZoneSetParentZone_SZL(fileInfo->m_typeSpecificData, zone, ___2974); return -1; } int32_t tecZoneMapPartitionsToMPIRanks( void*          fileHandle, int32_t&       zone, int32_t        numPartitions, int32_t const* mpiRanksForPartitions) {
 #if defined TECIOMPI
FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneMapPartitionsToMPIRanks) invalid fileHandle parameter\n"); else if (zone < 0) ___3185("Err: (tecZoneMapPartitionsToMPIRanks) Bad value for parameter zone: %d.\n", zone); else if (numPartitions < 1) ___3185("Err: (tecZoneMapPartitionsToMPIRanks) Bad value for parameter numPartitions: %d.\n", numPartitions); else if (!mpiRanksForPartitions) ___3184("Err: (tecZoneMapPartitionsToMPIRanks) Bad value <NULL> for parameter mpiRanksForPartitions.\n"); else return tecZoneMapPartitionsToMPIRanks_SZL(fileInfo->m_typeSpecificData, zone, numPartitions, mpiRanksForPartitions); return -1;
 #else
___4278(fileHandle); ___4278(zone); ___4278(numPartitions); ___4278(mpiRanksForPartitions); ___3184("Err: (mpiRanksForPartitions) To use the TECIO MPI symbols you must link your application " "with the teciompi library instead of the non-MPI version, tecio.\n"); return -1;
 #endif
} int32_t tecFEPartitionCreate32( void*          fileHandle, int32_t        zone, int32_t        ___2977, int64_t        ___2821, int64_t        ___2781, int64_t        numGhostNodes, int32_t const* ghostNodes, int32_t const* neighborPartitions, int32_t const* neighborPartitionNodes, int64_t        numGhostCells, int32_t const* ghostCells) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecFEPartitionCreate32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecFEPartitionCreate32) .plt format does not support partitions\n");
 #endif
else return tecFEPartitionCreate32_SZL( fileInfo->m_typeSpecificData, zone, ___2977, ___2821, ___2781, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCells, ghostCells); return -1; } int32_t tecFEPartitionCreate64( void*          fileHandle, int32_t        zone, int32_t        ___2977, int64_t        ___2821, int64_t        ___2781, int64_t        numGhostNodes, int64_t const* ghostNodes, int32_t const* neighborPartitions, int64_t const* neighborPartitionNodes, int64_t        numGhostCells, int64_t const* ghostCells) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecFEPartitionCreate64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecFEPartitionCreate64) .plt format does not support partitions\n");
 #endif
else return tecFEPartitionCreate64_SZL( fileInfo->m_typeSpecificData, zone, ___2977, ___2821, ___2781, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCells, ghostCells); return -1; } int32_t tecIJKPartitionCreate( void*   fileHandle, int32_t zone, int32_t ___2977, int64_t imin, int64_t jmin, int64_t kmin, int64_t imax, int64_t jmax, int64_t kmax) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecIJKPartitionCreate) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecIJKPartitionCreate) .plt format does not support partitions\n");
 #endif
else return tecIJKPartitionCreate_SZL( fileInfo->m_typeSpecificData, zone, ___2977, imin, jmin, kmin, imax, jmax, kmax); return -1; } int32_t tecZoneVarWriteDoubleValues( void*         fileHandle, int32_t       zone, int32_t       ___4336, int32_t       ___2977, int64_t       count, double const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneVarWriteDoubleValues) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneVarWriteDoubleValues) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteDoubleValues_SZL(fileInfo->m_typeSpecificData, zone, ___4336, ___2977, count, values); return -1; } int32_t tecZoneVarWriteFloatValues( void*        fileHandle, int32_t      zone, int32_t      ___4336, int32_t      ___2977, int64_t      count, float const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneVarWriteFloatValues) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneVarWriteFloatValues) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteFloatValues_SZL(fileInfo->m_typeSpecificData, zone, ___4336, ___2977, count, values); return -1; } int32_t tecZoneVarWriteInt32Values( void*          fileHandle, int32_t        zone, int32_t        ___4336, int32_t        ___2977, int64_t        count, int32_t const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneVarWriteInt32Values) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneVarWriteInt32Values) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteInt32Values_SZL(fileInfo->m_typeSpecificData, zone, ___4336, ___2977, count, values); return -1; } int32_t tecZoneVarWriteInt16Values( void*          fileHandle, int32_t        zone, int32_t        ___4336, int32_t        ___2977, int64_t        count, int16_t const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneVarWriteInt16Values) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneVarWriteInt16Values) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteInt16Values_SZL(fileInfo->m_typeSpecificData, zone, ___4336, ___2977, count, values); return -1; } int32_t tecZoneVarWriteUInt8Values( void*          fileHandle, int32_t        zone, int32_t        ___4336, int32_t        ___2977, int64_t        count, uint8_t const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneVarWriteUInt8Values) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneVarWriteUInt8Values) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteUInt8Values_SZL(fileInfo->m_typeSpecificData, zone, ___4336, ___2977, count, values); return -1; } int32_t tecZoneNodeMapWrite32( void*          fileHandle, int32_t        zone, int32_t        ___2977, int32_t        nodesAreOneBased, int64_t        count, int32_t const* nodes) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneNodeMapWrite32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneNodeMapWrite32) .plt format not yet supported\n");
 #endif
else return tecZoneNodeMapWrite32_SZL(fileInfo->m_typeSpecificData, zone, ___2977, nodesAreOneBased, count, nodes); return -1; } int32_t tecZoneNodeMapWrite64( void*          fileHandle, int32_t        zone, int32_t        ___2977, int32_t        nodesAreOneBased, int64_t        count, int64_t const* nodes) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneNodeMapWrite64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneNodeMapWrite64) .plt format not yet supported\n");
 #endif
else return tecZoneNodeMapWrite64_SZL(fileInfo->m_typeSpecificData, zone, ___2977, nodesAreOneBased, count, nodes); return -1; } int32_t tecZoneFaceNbrWriteConnections32( void*          fileHandle, int32_t        zone, int32_t const* faceNeighbors) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneFaceNbrWriteConnections32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneFaceNbrWriteConnections32) .plt format not yet supported\n");
 #endif
else return tecZoneFaceNbrWriteConnections32_SZL(fileInfo->m_typeSpecificData, zone, faceNeighbors); return -1; } EXTERNC tecio_API int32_t tecZoneFaceNbrWriteConnections64( void*          fileHandle, int32_t        zone, int64_t const* faceNeighbors) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneFaceNbrWriteConnections64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneFaceNbrWriteConnections64) .plt format not yet supported\n");
 #endif
else return tecZoneFaceNbrWriteConnections64_SZL(fileInfo->m_typeSpecificData, zone, faceNeighbors); return -1; } int32_t tecZoneWritePolyFaces32( void*          fileHandle, int32_t        zone, int32_t        ___2977, int32_t        numFaces, int32_t const* faceNodeCounts, int32_t const* ___1296, int32_t const* faceLeftElems, int32_t const* faceRightElems, int32_t        isOneBased) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneWritePolyFaces32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneWritePolyFaces32) .plt format not yet supported\n");
 #endif
else return tecZoneWritePolyFaces32_SZL( fileInfo->m_typeSpecificData, zone, ___2977, numFaces, faceNodeCounts, ___1296, faceLeftElems, faceRightElems, isOneBased); return -1; } int32_t tecZoneWritePolyFaces64( void*          fileHandle, int32_t        zone, int32_t        ___2977, int64_t        numFaces, int32_t const* faceNodeCounts, int64_t const* ___1296, int64_t const* faceLeftElems, int64_t const* faceRightElems, int32_t        isOneBased) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneWritePolyFaces64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneWritePolyFaces64) .plt format not yet supported\n");
 #endif
else return tecZoneWritePolyFaces64_SZL( fileInfo->m_typeSpecificData, zone, ___2977, numFaces, faceNodeCounts, ___1296, faceLeftElems, faceRightElems, isOneBased); return -1; } int32_t tecZoneWritePolyBoundaryConnections32( void*          fileHandle, int32_t        zone, int32_t        ___2977, int32_t        numBoundaryFaces, int32_t const* faceBoundaryConnectionCounts, int32_t const* faceBoundaryConnectionElems, int32_t const* faceBoundaryConnectionZones, int32_t        isOneBased) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneWritePolyBoundaryConnections32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneWritePolyBoundaryConnections32) .plt format not yet supported\n");
 #endif
else return tecZoneWritePolyBoundaryConnections32_SZL( fileInfo->m_typeSpecificData, zone, ___2977, numBoundaryFaces, faceBoundaryConnectionCounts, faceBoundaryConnectionElems, faceBoundaryConnectionZones, isOneBased); return -1; } int32_t tecZoneWritePolyBoundaryConnections64( void*          fileHandle, int32_t        zone, int32_t        ___2977, int64_t        numBoundaryFaces, int32_t const* faceBoundaryConnectionCounts, int64_t const* faceBoundaryConnectionElems, int32_t const* faceBoundaryConnectionZones, int32_t        isOneBased) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneWritePolyBoundaryConnections64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneWritePolyBoundaryConnections64) .plt format not yet supported\n");
 #endif
else return tecZoneWritePolyBoundaryConnections64_SZL( fileInfo->m_typeSpecificData, zone, ___2977, numBoundaryFaces, faceBoundaryConnectionCounts, faceBoundaryConnectionElems, faceBoundaryConnectionZones, isOneBased); return -1; } int32_t tecDataSetAddAuxData( void*       fileHandle, char const* ___2685, char const* ___4314) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecDataSetAddAuxData) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecDataSetAddAuxData) .plt format not yet supported\n");
 #endif
else return tecDataSetAddAuxData_SZL(fileInfo->m_typeSpecificData, ___2685, ___4314); return -1; } int32_t tecVarAddAuxData( void*       fileHandle, int32_t     ___4336, char const* ___2685, char const* ___4314) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecVarAddAuxData) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecVarAddAuxData) .plt format not yet supported\n");
 #endif
else return tecVarAddAuxData_SZL(fileInfo->m_typeSpecificData, ___4336, ___2685, ___4314); return -1; } int32_t tecZoneAddAuxData( void*       fileHandle, int32_t     zone, char const* ___2685, char const* ___4314) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecZoneAddAuxData) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecZoneAddAuxData) .plt format not yet supported\n");
 #endif
else return tecZoneAddAuxData_SZL(fileInfo->m_typeSpecificData, zone, ___2685, ___4314); return -1; } int32_t tecGeom2DLineSegmentsBegin( void*         fileHandle, double        xOrigin, double        yOrigin, int32_t       numPoints, double const* relativeX, double const* relativeY, int32_t       ___3159) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeom2DLineSegmentsBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeom2DLineSegmentsBegin) .plt format not yet supported\n");
 #endif
else return tecGeom2DLineSegmentsBegin_SZL( fileInfo->m_typeSpecificData, xOrigin, yOrigin, numPoints, relativeX, relativeY, ___3159); return -1; } int32_t tecGeom2DMultiLineSegmentsBegin( void*          fileHandle, double         xOrigin, double         yOrigin, int32_t        ___2835, int32_t const* numSegmentPoints, double const*  relativeX, double const*  relativeY, int32_t        ___3159) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeom2DMultiLineSegmentsBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeom2DMultiLineSegmentsBegin) .plt format not yet supported\n");
 #endif
else return tecGeom2DMultiLineSegmentsBegin_SZL( fileInfo->m_typeSpecificData, xOrigin, yOrigin, ___2835, numSegmentPoints, relativeX, relativeY, ___3159); return -1; } int32_t tecGeom3DLineSegmentsBegin( void*         fileHandle, double        xOrigin, double        yOrigin, double        zOrigin, int32_t       numPoints, double const* relativeX, double const* relativeY, double const* relativeZ) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeom3DLineSegmentsBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeom3DLineSegmentsBegin) .plt format not yet supported\n");
 #endif
else return tecGeom3DLineSegmentsBegin_SZL( fileInfo->m_typeSpecificData, xOrigin, yOrigin, zOrigin, numPoints, relativeX, relativeY, relativeZ); return -1; } int32_t tecGeom3DMultiLineSegmentsBegin( void*          fileHandle, double         xOrigin, double         yOrigin, double         zOrigin, int32_t        ___2835, int32_t const* numSegmentPoints, double const*  relativeX, double const*  relativeY, double const*  relativeZ) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeom3DMultiLineSegmentsBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeom3DMultiLineSegmentsBegin) .plt format not yet supported\n");
 #endif
else return tecGeom3DMultiLineSegmentsBegin_SZL( fileInfo->m_typeSpecificData, xOrigin, yOrigin, zOrigin, ___2835, numSegmentPoints, relativeX, relativeY, relativeZ); return -1; } int32_t tecGeomCircleBegin( void*   fileHandle, double  xCenter, double  yCenter, double  radius, int32_t ___3159) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeomCircleBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeomCircleBegin) .plt format not yet supported\n");
 #endif
else return tecGeomCircleBegin_SZL( fileInfo->m_typeSpecificData, xCenter, yCenter, radius, ___3159); return -1; } int32_t tecGeomEllipseBegin( void*   fileHandle, double  xCenter, double  yCenter, double  ___4458, double  ___1826, int32_t ___3159) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeomEllipseBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeomEllipseBegin) .plt format not yet supported\n");
 #endif
else return tecGeomEllipseBegin_SZL( fileInfo->m_typeSpecificData, xCenter, yCenter, ___4458, ___1826, ___3159); return -1; } int32_t tecGeomRectangleBegin( void*   fileHandle, double  xMin, double  yMin, double  xMax, double  yMax, int32_t ___3159) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeomRectangleBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeomRectangleBegin) .plt format not yet supported\n");
 #endif
else return tecGeomRectangleBegin_SZL( fileInfo->m_typeSpecificData, xMin, yMin, xMax, yMax, ___3159); return -1; } int32_t tecGeomSquareBegin( void*   fileHandle, double  xMin, double  yMin, double  size, int32_t ___3159) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeomSquareBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeomSquareBegin) .plt format not yet supported\n");
 #endif
else return tecGeomSquareBegin_SZL( fileInfo->m_typeSpecificData, xMin, yMin, size, ___3159); return -1; } int32_t tecGeomArrowheadSetInfo( void*   fileHandle, double  ___56, int32_t attachment, double  size, int32_t style) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeomArrowheadSetInfo) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeomArrowheadSetInfo) .plt format not yet supported\n");
 #endif
else return tecGeomArrowheadSetInfo_SZL( fileInfo->m_typeSpecificData, ___56, attachment, size, style); return -1; } int32_t tecGeomEllipseSetNumPoints( void*   fileHandle, int32_t numEllipsePoints) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeomSetNumEllipsePoints) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeomSetNumEllipsePoints) .plt format not yet supported\n");
 #endif
else return tecGeomEllipseSetNumPoints_SZL(fileInfo->m_typeSpecificData, numEllipsePoints); return -1; } int32_t tecGeomSetClipping( void*   fileHandle, int32_t ___495) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeomSetClipping) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeomSetClipping) .plt format not yet supported\n");
 #endif
else return tecGeomSetClipping_SZL( fileInfo->m_typeSpecificData, ___495); return -1; } int32_t tecGeomSetLineInfo( void*   fileHandle, int32_t ___2263, double  ___2986, double  thickness, int32_t color) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeomSetLineInfo) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeomSetLineInfo) .plt format not yet supported\n");
 #endif
else return tecGeomSetLineInfo_SZL( fileInfo->m_typeSpecificData, ___2263, ___2986, thickness, color); return -1; } int32_t tecGeomSetMacroFunctionCmd( void*       fileHandle, char const* macroFunctionCmd) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeomSetMacroFunctionCmd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeomSetMacroFunctionCmd) .plt format not yet supported\n");
 #endif
else return tecGeomSetMacroFunctionCmd_SZL(fileInfo->m_typeSpecificData, macroFunctionCmd); return -1; } int32_t tecGeomSetScope( void*   fileHandle, int32_t ___3442) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeomSetScope) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeomSetScope) .plt format not yet supported\n");
 #endif
else return tecGeomSetScope_SZL(fileInfo->m_typeSpecificData, ___3442); return -1; } int32_t tecGeomAttachToZone( void*   fileHandle, int32_t zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeomAttachToZone) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeomAttachToZone) .plt format not yet supported\n");
 #endif
else return tecGeomAttachToZone_SZL(fileInfo->m_typeSpecificData, zone); return -1; } int32_t tecGeomFill( void*  fileHandle, int32_t ___1411) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeomFill) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeomFill) .plt format not yet supported\n");
 #endif
else return tecGeomFill_SZL(fileInfo->m_typeSpecificData, ___1411); return -1; } int32_t tecGeomEnd(void* fileHandle) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecGeomEnd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecGeomEnd) .plt format not yet supported\n");
 #endif
else return tecGeomEnd_SZL(fileInfo->m_typeSpecificData); return -1; } int32_t tecCustomLabelsAddSet( void*       fileHandle, char const* ___2173) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecCustomLabelsAddSet) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecCustomLabelsAddSet) .plt format not yet supported\n");
 #endif
else return tecCustomLabelsAddSet_SZL(fileInfo->m_typeSpecificData, ___2173); return -1; } int32_t tecText2DBegin( void*       fileHandle, char const* string, double      x, double      ___4583, int32_t     ___3159, double      ___1826, int32_t     sizeUnits) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecText2DBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecText2DBegin) .plt format not yet supported\n");
 #endif
else return tecText2DBegin_SZL( fileInfo->m_typeSpecificData, string, x, ___4583, ___3159, ___1826, sizeUnits); return -1; } int32_t tecText3DBegin( void*       fileHandle, char const* string, double      x, double      ___4583, double      z, double      ___1826, int32_t     sizeUnits) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecText3DBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecText3DBegin) .plt format not yet supported\n");
 #endif
else return tecText3DBegin_SZL( fileInfo->m_typeSpecificData, string, x, ___4583, z, ___1826, sizeUnits); return -1; } int32_t tecTextAttachToZone( void*   fileHandle, int32_t zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecTextAttachToZone) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecTextAttachToZone) .plt format not yet supported\n");
 #endif
else return tecTextAttachToZone_SZL(fileInfo->m_typeSpecificData, zone); return -1; } int32_t tecTextBoxSetInfo( void*   fileHandle, int32_t ___410, int32_t lineColor, int32_t ___1411, double  ___2289, double  margin) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecTextBoxSetInfo) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecTextBoxSetInfo) .plt format not yet supported\n");
 #endif
else return tecTextBoxSetInfo_SZL( fileInfo->m_typeSpecificData, ___410, lineColor, ___1411, ___2289, margin); return -1; } int32_t tecTextSetAnchor(void* fileHandle, int32_t ___38) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecTextSetAnchor) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecTextSetAnchor) .plt format not yet supported\n");
 #endif
else return tecTextSetAnchor_SZL(fileInfo->m_typeSpecificData, ___38); return -1; } int32_t tecTextSetAngle( void*  fileHandle, double ___56) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecTextSetAngle) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecTextSetAngle) .plt format not yet supported\n");
 #endif
else return tecTextSetAngle_SZL(fileInfo->m_typeSpecificData, ___56); return -1; } int32_t tecTextSetClipping(void* fileHandle, int32_t ___495) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecTextSetClipping) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecTextSetClipping) .plt format not yet supported\n");
 #endif
else return tecTextSetClipping_SZL(fileInfo->m_typeSpecificData, ___495); return -1; } int32_t tecTextSetColor( void*  fileHandle, int32_t color) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecTextSetColor) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecTextSetColor) .plt format not yet supported\n");
 #endif
else return tecTextSetColor_SZL(fileInfo->m_typeSpecificData, color); return -1; } int32_t tecTextSetTypeface( void*       fileHandle, char const* family, int32_t     isBold, int32_t     isItalic) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecTextSetTypeface) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecTextSetTypeface) .plt format not yet supported\n");
 #endif
else return tecTextSetTypeface_SZL(fileInfo->m_typeSpecificData, family, isBold, isItalic); return -1; } int32_t tecTextSetLineSpacing( void*  fileHandle, double ___2287) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecTextSetLineSpacing) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecTextSetLineSpacing) .plt format not yet supported\n");
 #endif
else return tecTextSetLineSpacing_SZL(fileInfo->m_typeSpecificData, ___2287); return -1; } int32_t tecTextSetMacroFunctionCmd( void* fileHandle, char const* macroFunctionCmd) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecTextSetMacroFunctionCmd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecTextSetMacroFunctionCmd) .plt format not yet supported\n");
 #endif
else return tecTextSetMacroFunctionCmd_SZL(fileInfo->m_typeSpecificData, macroFunctionCmd); return -1; } int32_t tecTextSetScope( void*   fileHandle, int32_t ___3442) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecTextSetScope) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecTextSetScope) .plt format not yet supported\n");
 #endif
else return tecTextSetScope_SZL(fileInfo->m_typeSpecificData, ___3442); return -1; } int32_t tecTextEnd(void* fileHandle) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecTextEnd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecTextEnd) .plt format not yet supported\n");
 #endif
else return tecTextEnd_SZL(fileInfo->m_typeSpecificData); return -1; } int32_t tecUserRecAdd( void*       fileHandle, char const* userRec) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecUserRecAdd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecUserRecAdd) .plt format not yet supported\n");
 #endif
else return tecUserRecAdd_SZL(fileInfo->m_typeSpecificData, userRec); return -1; } int32_t tecFileWriterFlush( void*          fileHandle, int32_t        numZonesToRetain, int32_t const* zonesToRetain) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3184("Err: (tecFileWriterFlush) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3184("Err: (tecFileWriterFlush) .plt format not yet supported\n");
 #endif
else return tecFileWriterFlush_SZL(fileInfo->m_typeSpecificData, numZonesToRetain, zonesToRetain); return -1; } int32_t tecFileWriterClose(void** fileHandle) { FileInfo* fileInfo = NULL; if (fileHandle) fileInfo = (FileInfo*)(*fileHandle); if (!fileInfo) { ___3184("Err: (tecFileWriterClose) invalid fileHandle parameter\n"); }
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) { ___3184("Err: (tecFileWriterClose) .plt format not yet supported\n"); }
 #endif
else { int32_t ___3358 = tecFileWriterClose_SZL(&fileInfo->m_typeSpecificData); delete fileInfo; *fileHandle = NULL; return ___3358; } return -1; } int32_t STDCALL TECINI142( char const*    ___4177, char const*    ___4350, char const*    ___1394, char const*    ___3447, int32_t const* ___1390, int32_t const* ___1407, int32_t const* ___941, int32_t const* ___2013) { int ___2697 = firstOpenFile(); if (___2697 == -1) { ___3185("Err: (TECINI142) Too many files (%d) opened for writing.\n", ___2697); return (-1); } ___1391[___2697] = *___1390; if (___691 == -1) ___691 = 0; int32_t ___3359;
 #if !defined TECIOMPI
if (___1391[___2697] == FILEFORMAT_PLT) ___3359 = ___3977(___2697, ___4177, ___4350, ___1394, ___3447, ___1407, ___941, ___2013); else
 #endif
___3359 = ___3999(___2697, ___4177, ___4350, ___1394, ___3447, ___1407, ___941, ___2013); if (___3359 >= 0) ___2042[___2697] = 1; return ___3359; } int32_t STDCALL TECINI112( char const*     ___4177, char const*     ___4350, char const*     ___1394, char const*     ___3447, int32_t const* ___1407, int32_t const* ___941, int32_t const* ___2013) { return TECINI142(___4177, ___4350, ___1394, ___3447, &FILEFORMAT_PLT, ___1407, ___941, ___2013); } int32_t STDCALL TECINI111( char const*     ___4178, char const*     ___4351, char const*     ___1439, char const*     ___3448, int32_t const* ___1408, int32_t const* ___942, int32_t const* ___4439) { return TECINI142(___4178, ___4351, ___1439, ___3448, &FILEFORMAT_PLT, ___1408, ___942, ___4439); } int32_t STDCALL TECINI110( char const*     ___4178, char const*     ___4351, char const*     ___1439, char const*     ___3448, int32_t const* ___942, int32_t const* ___4439) { int32_t ___1534 = ___1535; return TECINI142(___4178, ___4351, ___1439, ___3448, &FILEFORMAT_PLT, &___1534, ___942, ___4439); } int32_t STDCALL TECINI100( char const*     ___4178, char const*     ___4351, char const*     ___1439, char const*     ___3448, int32_t const* ___942, int32_t const* ___4439) { int32_t ___1534 = ___1535; return TECINI142(___4178, ___4351, ___1439, ___3448, &FILEFORMAT_PLT, &___1534, ___942, ___4439); } int32_t STDCALL TECINI( char const*     ___4178, char const*     ___4351, char const*     ___1439, char const*     ___3448, int32_t const* ___942, int32_t const* ___4439) { int32_t ___1534 = ___1535; return TECINI142(___4178, ___4351, ___1439, ___3448, &FILEFORMAT_PLT, &___1534, ___942, ___4439); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecini142_( char const*     ___4178, char const*     ___4351, char const*     ___1439, char const*     ___3448, int32_t const* ___1391, int32_t const* ___1408, int32_t const* ___942, int32_t const* ___4439) { return TECINI142(___4178, ___4351, ___1439, ___3448, ___1391, ___1408, ___942, ___4439); } EXTERNC tecio_API int32_t STDCALL tecini112_( char const*     ___4178, char const*     ___4351, char const*     ___1439, char const*     ___3448, int32_t const* ___1408, int32_t const* ___942, int32_t const* ___4439) { return TECINI142(___4178, ___4351, ___1439, ___3448, &FILEFORMAT_PLT, ___1408, ___942, ___4439); } EXTERNC tecio_API int32_t STDCALL tecini111_( char const*     ___4178, char const*     ___4351, char const*     ___1439, char const*     ___3448, int32_t const* ___1408, int32_t const* ___942, int32_t const* ___4439) { return TECINI142(___4178, ___4351, ___1439, ___3448, &FILEFORMAT_PLT, ___1408, ___942, ___4439); } EXTERNC tecio_API int32_t STDCALL tecini110_( char const*     ___4178, char const*     ___4351, char const*     ___1439, char const*     ___3448, int32_t const* ___942, int32_t const* ___4439) { int32_t ___1534 = ___1535; return TECINI142(___4178, ___4351, ___1439, ___3448, &FILEFORMAT_PLT, &___1534, ___942, ___4439); } EXTERNC tecio_API int32_t STDCALL tecini100_( char const*     ___4178, char const*     ___4351, char const*     ___1439, char const*     ___3448, int32_t const* ___942, int32_t const* ___4439) { int32_t ___1534 = ___1535; return TECINI142(___4178, ___4351, ___1439, ___3448, &FILEFORMAT_PLT, &___1534, ___942, ___4439); } EXTERNC tecio_API int32_t STDCALL tecini_( char const*     ___4178, char const*     ___4351, char const*     ___1439, char const*     ___3448, int32_t const* ___942, int32_t const* ___4439) { int32_t ___1534 = ___1535; return TECINI142(___4178, ___4351, ___1439, ___3448, &FILEFORMAT_PLT, &___1534, ___942, ___4439); }
 #endif
int32_t STDCALL TECZNE142( char const*     ___4691, int32_t const* ___4693, int32_t const* ___1910, int32_t const* ___2117, int32_t const* ___2162, int32_t const* ___1836, int32_t const* ___2109, int32_t const* ___2138, double const*   ___3641, int32_t const* ___3786, int32_t const* ___2975, int32_t const* ___2006, int32_t const* ___2803, int32_t const* ___1285, int32_t const* ___4193, int32_t const* ___2787, int32_t const* ___4189, int32_t const* ___2983, int32_t const* ___4327, int32_t const* ___3552, int32_t const* ___3550) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3992(___691, ___4691, ___4693, ___1910, ___2117, ___2162, ___1836, ___2109, ___2138, ___3641, ___3786, ___2975, ___2006, ___2803, ___1285, ___4193, ___2787, ___4189, ___2983, ___4327, ___3552, ___3550); else
 #endif
return ___4014(___691, ___4691, ___4693, ___1910, ___2117, ___2162, ___1836, ___2109, ___2138, ___3641, ___3786, ___2975, ___2006, ___2803, ___1285, ___4193, ___2787, ___4189, ___2983, ___4327, ___3552, ___3550); } int32_t STDCALL TECZNE112( char const*     ___4598, int32_t const* ___4599, int32_t const* ___1910, int32_t const* ___2117, int32_t const* ___2162, int32_t const* ___1836, int32_t const* ___2109, int32_t const* ___2138, double const*   ___3641, int32_t const* ___3786, int32_t const* ___2975, int32_t const* ___2005, int32_t const* ___2801, int32_t const* ___1440, int32_t const* ___2805, int32_t const* ___2799, int32_t const* ___2798, int32_t const* ___2983, int32_t const* ___4327, int32_t const* ___3552, int32_t const* ___3550) { return TECZNE142(___4598, ___4599, ___1910, ___2117, ___2162, ___1836, ___2109, ___2138, ___3641, ___3786, ___2975, ___2005, ___2801, ___1440, ___2805, ___2799, ___2798, ___2983, ___4327, ___3552, ___3550); } int32_t STDCALL TECZNE111( char const*     ___4598, int32_t const* ___4599, int32_t const* ___1910, int32_t const* ___2117, int32_t const* ___2162, int32_t const* ___1836, int32_t const* ___2109, int32_t const* ___2138, double const*   ___3641, int32_t const* ___3786, int32_t const* ___2975, int32_t const* ___2005, int32_t const* ___2801, int32_t const* ___1440, int32_t const* ___2805, int32_t const* ___2799, int32_t const* ___2798, int32_t const* ___2983, int32_t const* ___4327, int32_t const* ___3552, int32_t const* ___3550) { return TECZNE142(___4598, ___4599, ___1910, ___2117, ___2162, ___1836, ___2109, ___2138, ___3641, ___3786, ___2975, ___2005, ___2801, ___1440, ___2805, ___2799, ___2798, ___2983, ___4327, ___3552, ___3550); } int32_t STDCALL TECZNE110( char const*     ___4598, int32_t const* ___4599, int32_t const* ___1910, int32_t const* ___2117, int32_t const* ___2160, int32_t const* ___1836, int32_t const* ___2109, int32_t const* ___2138, double const*   ___3641, int32_t const* ___3786, int32_t const* ___2975, int32_t const* ___2005, int32_t const* ___2801, int32_t const* ___1440, int32_t const* ___2983, int32_t const* ___4327, int32_t const* ___3552, int32_t const* ___3550) { int32_t ___2805      = 0; int32_t ___2799 = 0; int32_t ___2798 = 0; return TECZNE142(___4598, ___4599, ___1910, ___2117, ___2160, ___1836, ___2109, ___2138, ___3641, ___3786, ___2975, ___2005, ___2801, ___1440, &___2805, &___2799, &___2798, ___2983, ___4327, ___3552, ___3550); } int32_t STDCALL TECZNE100( char const*     ___4598, int32_t const* ___4599, int32_t const* ___1910, int32_t const* ___2117, int32_t const* ___2160, int32_t const* ___1836, int32_t const* ___2109, int32_t const* ___2138, int32_t const* ___2005, int32_t const* ___2801, int32_t const* ___1440, int32_t const* ___4327, int32_t const* ___3552, int32_t const* ___3550) { double   ___3641 = 0.0; int32_t ___3786   = ___3788 + 1; int32_t ___2975 = ___333 + 1; int32_t ___2805      = 0; int32_t ___2799 = 0; int32_t ___2798 = 0; return TECZNE142(___4598, ___4599, ___1910, ___2117, ___2160, ___1836, ___2109, ___2138, &___3641, &___3786, &___2975, ___2005, ___2801, ___1440, &___2805, &___2799, &___2798, NULL, ___4327, ___3552, ___3550); }
 #if !defined INDEX_16_BIT 
namespace { ___372 ___2976( ___1172** ___3552, ___1172*  ___3550, char const* ___1134) { ___372 ___2040 = ___4226; REQUIRE(VALID_REF(___3552) && *___3552 == NULL); REQUIRE(VALID_REF(___3550)); REQUIRE(VALID_REF(___1134)); ___1172 ___2848; ___1172 ___2844;
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) { ___2848 = ___3982(___691); ___2844  = ___3981(___691); } else
 #endif
{ ___2848 = ___4004(___691); ___2844  = ___4003(___691); } while (___2040 && *___1134) { while (*___1134 && *___1134 == ' ') ___1134++; if (*___1134 && !strncmp(___1134, "FECONNECT", 9)) { *___3550 = ___2848; } else if (*___1134 && !tecplot::___2012(*___1134)) { ___2040 = ___1305; } else if (*___1134) { char *___2756 = NULL; ___1172 ___4454 = strtol(___1134, &___2756, 10); if (0 < ___4454 && ___4454 < ___2844) { if (!(*___3552)) { *___3552 = ___23(___2844, ___1172, "Variable sharing list"); if (*___3552) memset(*___3552, (char)0, ___2844 * sizeof(___1172)); } if (*___3552) (*___3552)[___4454 - 1] = ___2848; else ___2040 = ___1305; } else { ___2040 = ___1305; } } while (*___1134 && *___1134 != ',') ___1134++; while (*___1134 && *___1134 == ',') ___1134++; } return ___2040; } }
 #endif
 #if !defined INDEX_16_BIT 
int32_t STDCALL TECZNE( char const*     ___4691, int32_t const* ___1908, int32_t const* ___2115, int32_t const* ___2160, char const*     ___4596, char const*     ___1134) { int32_t    ___4693; int32_t    ___2006; int32_t   *___3552 = NULL; int32_t    ___3550; int32_t    ___3359 = 0; if (___4596 == NULL) ___3359 = -1; else if (!strcmp(___4596, "BLOCK")) { ___2006 = 1; ___4693 = ___4704; } else if (!strcmp(___4596, "FEBLOCK")) { ___2006 = 1; switch (*___2160) { case 0: ___4693 = 2; break; case 1: ___4693 = 3; break; case 2: ___4693 = 4; break; case 3: ___4693 = 5; break; } } else if (!strcmp(___4596, "POINT")) { ___2006 = 0; ___4693 = ___4704; } else if (!strcmp(___4596, "FEPOINT")) { ___2006 = 0; switch (*___2160) { case 0: ___4693 = 2; break; case 1: ___4693 = 3; break; case 2: ___4693 = 4; break; case 3: ___4693 = 5; break; } } else ___3359 = -1; ___3550 = 0; if (___3359 == 0 && ___1134 && !___2976(&___3552, &___3550, ___1134)) { ___3359 = -1; } if (___3359 == 0) { int32_t ___1836 = 0; int32_t ___2109 = 0; int32_t ___2138 = 0; int32_t ___2803 = 0; int32_t ___1285   = ___1290; double   ___3641 = 0.0; int32_t ___3786   = ___3788 + 1; int32_t ___2975 = ___333 + 1; int32_t ___2805      = 0; int32_t ___2799 = 0; int32_t ___2798 = 0; ___3359 = TECZNE142((char *)___4691, &___4693, ___1908, ___2115, ___2160, &___1836, &___2109, &___2138, &___3641, &___3786, &___2975, &___2006, &___2803, &___1285, &___2805, &___2799, &___2798, NULL, NULL, ___1134 ? ___3552 : NULL, &___3550); } if (___3552) ___1530(___3552, "Variable sharing list"); return (int32_t) ___3359; }
 #endif 
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL teczne142_( char const*     ___4691, int32_t const* ___4599, int32_t const* ___1910, int32_t const* ___2117, int32_t const* ___2160, int32_t const* ___1836, int32_t const* ___2109, int32_t const* ___2138, double const*   ___3641, int32_t const* ___3786, int32_t const* ___2975, int32_t const* ___2005, int32_t const* ___2801, int32_t const* ___1440, int32_t const* ___2805, int32_t const* ___2799, int32_t const* ___2798, int32_t const* ___2983, int32_t const* ___4327, int32_t const* ___3552, int32_t const* ___3550) { return TECZNE142(___4691, ___4599, ___1910, ___2117, ___2160, ___1836, ___2109, ___2138, ___3641, ___3786, ___2975, ___2005, ___2801, ___1440, ___2805, ___2799, ___2798, ___2983, ___4327, ___3552, ___3550); } EXTERNC tecio_API int32_t STDCALL teczne112_( char const*     ___4691, int32_t const* ___4599, int32_t const* ___1910, int32_t const* ___2117, int32_t const* ___2160, int32_t const* ___1836, int32_t const* ___2109, int32_t const* ___2138, double const*   ___3641, int32_t const* ___3786, int32_t const* ___2975, int32_t const* ___2005, int32_t const* ___2801, int32_t const* ___1440, int32_t const* ___2805, int32_t const* ___2799, int32_t const* ___2798, int32_t const* ___2983, int32_t const* ___4327, int32_t const* ___3552, int32_t const* ___3550) { return TECZNE142(___4691, ___4599, ___1910, ___2117, ___2160, ___1836, ___2109, ___2138, ___3641, ___3786, ___2975, ___2005, ___2801, ___1440, ___2805, ___2799, ___2798, ___2983, ___4327, ___3552, ___3550); } EXTERNC tecio_API int32_t STDCALL teczne111_( char const*     ___4691, int32_t const* ___4599, int32_t const* ___1910, int32_t const* ___2117, int32_t const* ___2160, int32_t const* ___1836, int32_t const* ___2109, int32_t const* ___2138, double const*   ___3641, int32_t const* ___3786, int32_t const* ___2975, int32_t const* ___2005, int32_t const* ___2801, int32_t const* ___1440, int32_t const* ___2805, int32_t const* ___2799, int32_t const* ___2798, int32_t const* ___2983, int32_t const* ___4327, int32_t const* ___3552, int32_t const* ___3550) { return TECZNE142(___4691, ___4599, ___1910, ___2117, ___2160, ___1836, ___2109, ___2138, ___3641, ___3786, ___2975, ___2005, ___2801, ___1440, ___2805, ___2799, ___2798, ___2983, ___4327, ___3552, ___3550); } EXTERNC tecio_API int32_t STDCALL teczne110_( char const*     ___4691, int32_t const* ___4599, int32_t const* ___1910, int32_t const* ___2117, int32_t const* ___2160, int32_t const* ___1836, int32_t const* ___2109, int32_t const* ___2138, double const*   ___3641, int32_t const* ___3786, int32_t const* ___2975, int32_t const* ___2005, int32_t const* ___2801, int32_t const* ___1440, int32_t const* ___2983, int32_t const* ___4327, int32_t const* ___3552, int32_t const* ___3550) { int32_t ___2805      = 0; int32_t ___2799 = 0; int32_t ___2798 = 0; return TECZNE142(___4691, ___4599, ___1910, ___2117, ___2160, ___1836, ___2109, ___2138, ___3641, ___3786, ___2975, ___2005, ___2801, ___1440, &___2805, &___2799, &___2798, ___2983, ___4327, ___3552, ___3550); } EXTERNC tecio_API int32_t STDCALL teczne100_( char const*     ___4691, int32_t const* ___4599, int32_t const* ___1910, int32_t const* ___2117, int32_t const* ___2160, int32_t const* ___1836, int32_t const* ___2109, int32_t const* ___2138, int32_t const* ___2005, int32_t const* ___2801, int32_t const* ___1440, int32_t const* ___4327, int32_t const* ___3552, int32_t const* ___3550) { return TECZNE100(___4691, ___4599, ___1910, ___2117, ___2160, ___1836, ___2109, ___2138, ___2005, ___2801, ___1440, ___4327, ___3552, ___3550); } EXTERNC tecio_API int32_t STDCALL teczne_( char const*     ___4691, int32_t const* ___1908, int32_t const* ___2115, int32_t const* ___2160, char const*     ___4596, char const*     ___1134) { return TECZNE(___4691, ___1908, ___2115, ___2160, ___4596, ___1134); }
 #endif
int32_t STDCALL TECDAT142( int32_t const* N, void const*     ___1352, int32_t const* ___2014) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3972(___691, N, ___1352, ___2014); else
 #endif
return ___3994(___691, N, ___1352, ___2014); } int32_t STDCALL TECDATD142( int32_t const* N, double const*  ___1352) { int32_t ___2013 = 1; return TECDAT142(N, ___1352, &___2013); } int32_t STDCALL TECDATF142( int32_t const* N, float const*   ___1352) { int32_t ___2013 = 0; return TECDAT142(N, ___1352, &___2013); } int32_t STDCALL TECDAT112( int32_t const* N, void const*     ___1352, int32_t const* ___2014) { return TECDAT142(N, ___1352, ___2014); } int32_t STDCALL TECDAT111( int32_t const* N, void const*     ___1352, int32_t const* ___2014) { return TECDAT142(N, ___1352, ___2014); } int32_t STDCALL TECDAT110( int32_t const* N, void const*     ___1352, int32_t const* ___2014) { return TECDAT142(N, ___1352, ___2014); } int32_t STDCALL TECDAT100( int32_t const* N, void const*     ___1352, int32_t const* ___2014) { return TECDAT142(N, ___1352, ___2014); } int32_t STDCALL TECDAT( int32_t const* N, void const*     ___1352, int32_t const* ___2014) { return TECDAT142(N, ___1352, ___2014); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecdat142_( int32_t const* N, void const*     ___1352, int32_t const* ___2014) { return TECDAT142(N, ___1352, ___2014); } EXTERNC tecio_API int32_t STDCALL tecdatd142_( int32_t const* N, double const*  ___1352) { return TECDATD142(N, ___1352); } EXTERNC tecio_API int32_t STDCALL tecdatf142_( int32_t const* N, float const*   ___1352) { return TECDATF142(N, ___1352); } EXTERNC tecio_API int32_t STDCALL tecdat112_( int32_t const* N, void const*     ___1352, int32_t const* ___2014) { return TECDAT142(N, ___1352, ___2014); } EXTERNC tecio_API int32_t STDCALL tecdat111_( int32_t const* N, void const*     ___1352, int32_t const* ___2014) { return TECDAT142(N, ___1352, ___2014); } EXTERNC tecio_API int32_t STDCALL tecdat110_( int32_t const* N, void const*     ___1352, int32_t const* ___2014) { return TECDAT142(N, ___1352, ___2014); } EXTERNC tecio_API int32_t STDCALL tecdat100_( int32_t const* N, void const*     ___1352, int32_t const* ___2014) { return TECDAT142(N, ___1352, ___2014); } EXTERNC tecio_API int32_t STDCALL tecdat_( int32_t const* N, void const*     ___1352, int32_t const* ___2014) { return TECDAT142(N, ___1352, ___2014); }
 #endif
int32_t STDCALL TECNOD142(int32_t const* ___2689) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3979(___691, ___2689); else
 #endif
return ___4001(___691, ___2689); } int32_t STDCALL TECNOD112(int32_t const* ___2689) { return TECNOD142(___2689); } int32_t STDCALL TECNOD111(int32_t const* ___2689) { return TECNOD142(___2689); } int32_t STDCALL TECNOD110(int32_t const* ___2689) { return TECNOD142(___2689); } int32_t STDCALL TECNOD100(int32_t const* ___2689) { return TECNOD142(___2689); } int32_t STDCALL TECNOD(int32_t const* ___2689) { return TECNOD142(___2689); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecnod142_(int32_t const* ___2689) { return TECNOD142(___2689); } EXTERNC tecio_API int32_t STDCALL tecnod112_(int32_t const* ___2689) { return TECNOD142(___2689); } EXTERNC tecio_API int32_t STDCALL tecnod111_(int32_t const* ___2689) { return TECNOD142(___2689); } EXTERNC tecio_API int32_t STDCALL tecnod110_(int32_t const* ___2689) { return TECNOD142(___2689); } EXTERNC tecio_API int32_t STDCALL tecnod100_(int32_t const* ___2689) { return TECNOD142(___2689); } EXTERNC tecio_API int32_t STDCALL tecnod_(int32_t const* ___2689) { return TECNOD142(___2689); }
 #endif
int32_t STDCALL TECNODE142( int32_t const* N, int32_t const* ___2689) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3980(___691, N, ___2689); else
 #endif
return ___4002(___691, N, ___2689); } int32_t STDCALL TECNODE112( int32_t const* N, int32_t const* ___2689) { return TECNODE142(N, ___2689); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecnode142_( int32_t const* N, int32_t const* ___2689) { return TECNODE142(N, ___2689); } EXTERNC tecio_API int32_t STDCALL tecnode112_( int32_t const* N, int32_t const* ___2689) { return TECNODE142(N, ___2689); }
 #endif
int32_t STDCALL TECFLUSH142( int32_t const* numZonesToRetain, int32_t const* zonesToRetain) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) { ___3184("Err: TECFLUSH does not yet support .plt format\n"); return -1; } else
 #endif
return TECIOSZL_FLUSH(___691, numZonesToRetain, zonesToRetain); } int32_t STDCALL TECEND142(void) { int32_t ___3359;
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) ___3359 = ___3973(___691); else
 #endif
___3359 = ___3995(___691); ___2042[___691] = 0; ___691 = 0; while ((___691 < ___2380) && !___2042[___691]) ___691++; if (___691 == ___2380) ___691 = -1; return ___3359; } int32_t STDCALL TECEND112(void) { return TECEND142(); } int32_t STDCALL TECEND111(void) { return TECEND142(); } int32_t STDCALL TECEND110(void) { return TECEND142(); } int32_t STDCALL TECEND100(void) { return TECEND142(); } int32_t STDCALL TECEND(void) { return TECEND142(); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecend142_(void) { return TECEND142(); } EXTERNC tecio_API int32_t STDCALL tecend112_(void) { return TECEND142(); } EXTERNC tecio_API int32_t STDCALL tecend111_(void) { return TECEND142(); } EXTERNC tecio_API int32_t STDCALL tecend110_(void) { return TECEND142(); } EXTERNC tecio_API int32_t STDCALL tecend100_(void) { return TECEND142(); } EXTERNC tecio_API int32_t STDCALL tecend_(void) { return TECEND142(); }
 #endif
int32_t STDCALL TECLAB142(char const* S) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3978(___691, S); else
 #endif
return ___4000(___691, S); } int32_t STDCALL TECLAB112(char const* S) { return TECLAB142(S); } int32_t STDCALL TECLAB111(char const* S) { return TECLAB142(S); } int32_t STDCALL TECLAB110(char const* S) { return TECLAB142(S); } int32_t STDCALL TECLAB100(char const* S) { return TECLAB142(S); } int32_t STDCALL TECLAB(char const* S) { return TECLAB142(S); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL teclab142_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t STDCALL teclab112_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t STDCALL teclab111_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t STDCALL teclab110_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t STDCALL teclab100_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t STDCALL teclab_(char const* S) { return TECLAB142(S); }
 #endif
int32_t STDCALL TECUSR142(char const* S) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3989(___691, S); else
 #endif
return ___4011(___691, S); } int32_t STDCALL TECUSR112(char const* S) { return TECUSR142(S); } int32_t STDCALL TECUSR111(char const* S) { return TECUSR142(S); } int32_t STDCALL TECUSR110(char const* S) { return TECUSR142(S); } int32_t STDCALL TECUSR100(char const* S) { return TECUSR142(S); } int32_t STDCALL TECUSR(char const* S) { return TECUSR142(S); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecusr142_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t STDCALL tecusr112_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t STDCALL tecusr111_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t STDCALL tecusr110_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t STDCALL tecusr100_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t STDCALL tecusr_(char const* S) { return TECUSR142(S); }
 #endif
int32_t STDCALL TECGEO142( double const*  ___4575, double const*  ___4592, double const*  ___4716, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1412, int32_t const* ___2023, int32_t const* ___1652, int32_t const* ___2264, double const*  ___2987, double const*  ___2290, int32_t const* ___2794, int32_t const* ___188, int32_t const* ___176, double const*  ___187, double const*  ___171, int32_t const* ___3443, int32_t const* ___496, int32_t const* ___2836, int32_t const* ___2838, float const*   ___4573, float const*   ___4590, float const*   ___4597, char const*    mfc) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3976(___691, ___4575, ___4592, ___4716, ___3160, ___227, ___4600, Color, ___1412, ___2023, ___1652, ___2264, ___2987, ___2290, ___2794, ___188, ___176, ___187, ___171, ___3443, ___496, ___2836, ___2838, ___4573, ___4590, ___4597, mfc); else
 #endif
return ___3998(___691, ___4575, ___4592, ___4716, ___3160, ___227, ___4600, Color, ___1412, ___2023, ___1652, ___2264, ___2987, ___2290, ___2794, ___188, ___176, ___187, ___171, ___3443, ___496, ___2836, ___2838, ___4573, ___4590, ___4597, mfc); } int32_t STDCALL TECGEO112( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1412, int32_t const* ___2023, int32_t const* ___1652, int32_t const* ___2264, double const*   ___2987, double const*   ___2290, int32_t const* ___2794, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3443, int32_t const* ___496, int32_t const* ___2836, int32_t const* ___2838, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3160, ___227, ___4600, Color, ___1412, ___2023, ___1652, ___2264, ___2987, ___2290, ___2794, ___188, ___176, ___187, ___171, ___3443, ___496, ___2836, ___2838, ___4573, ___4590, ___4597, mfc); } int32_t STDCALL TECGEO111( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1412, int32_t const* ___2023, int32_t const* ___1652, int32_t const* ___2264, double const*   ___2987, double const*   ___2290, int32_t const* ___2794, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3443, int32_t const* ___496, int32_t const* ___2836, int32_t const* ___2838, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3160, ___227, ___4600, Color, ___1412, ___2023, ___1652, ___2264, ___2987, ___2290, ___2794, ___188, ___176, ___187, ___171, ___3443, ___496, ___2836, ___2838, ___4573, ___4590, ___4597, mfc); } int32_t STDCALL TECGEO110( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1412, int32_t const* ___2023, int32_t const* ___1652, int32_t const* ___2264, double const*   ___2987, double const*   ___2290, int32_t const* ___2794, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3443, int32_t const* ___496, int32_t const* ___2836, int32_t const* ___2838, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3160, ___227, ___4600, Color, ___1412, ___2023, ___1652, ___2264, ___2987, ___2290, ___2794, ___188, ___176, ___187, ___171, ___3443, ___496, ___2836, ___2838, ___4573, ___4590, ___4597, mfc); } int32_t STDCALL TECGEO100( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1412, int32_t const* ___2023, int32_t const* ___1652, int32_t const* ___2264, double const*   ___2987, double const*   ___2290, int32_t const* ___2794, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3443, int32_t const* ___496, int32_t const* ___2836, int32_t const* ___2838, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3160, ___227, ___4600, Color, ___1412, ___2023, ___1652, ___2264, ___2987, ___2290, ___2794, ___188, ___176, ___187, ___171, ___3443, ___496, ___2836, ___2838, ___4573, ___4590, ___4597, mfc); } int32_t STDCALL TECGEO( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1412, int32_t const* ___2023, int32_t const* ___1652, int32_t const* ___2264, double const*   ___2987,
double const*   ___2290, int32_t const* ___2794, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3443, int32_t const* ___2836, int32_t const* ___2838, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { int ___496 = (int)___498; return TECGEO142(___4575, ___4592, ___4716, ___3160, ___227, ___4600, Color, ___1412, ___2023, ___1652, ___2264, ___2987, ___2290, ___2794, ___188, ___176, ___187, ___171, ___3443, &___496, ___2836, ___2838, ___4573, ___4590, ___4597, mfc); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecgeo142_( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1412, int32_t const* ___2023, int32_t const* ___1652, int32_t const* ___2264, double const*   ___2987, double const*   ___2290, int32_t const* ___2794, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3443, int32_t const* ___496, int32_t const* ___2836, int32_t const* ___2838, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3160, ___227, ___4600, Color, ___1412, ___2023, ___1652, ___2264, ___2987, ___2290, ___2794, ___188, ___176, ___187, ___171, ___3443, ___496, ___2836, ___2838, ___4573, ___4590, ___4597, mfc); } EXTERNC tecio_API int32_t STDCALL tecgeo112_( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1412, int32_t const* ___2023, int32_t const* ___1652, int32_t const* ___2264, double const*   ___2987, double const*   ___2290, int32_t const* ___2794, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3443, int32_t const* ___496, int32_t const* ___2836, int32_t const* ___2838, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3160, ___227, ___4600, Color, ___1412, ___2023, ___1652, ___2264, ___2987, ___2290, ___2794, ___188, ___176, ___187, ___171, ___3443, ___496, ___2836, ___2838, ___4573, ___4590, ___4597, mfc); } EXTERNC tecio_API int32_t STDCALL tecgeo111_( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1412, int32_t const* ___2023, int32_t const* ___1652, int32_t const* ___2264, double const*   ___2987, double const*   ___2290, int32_t const* ___2794, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3443, int32_t const* ___496, int32_t const* ___2836, int32_t const* ___2838, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3160, ___227, ___4600, Color, ___1412, ___2023, ___1652, ___2264, ___2987, ___2290, ___2794, ___188, ___176, ___187, ___171, ___3443, ___496, ___2836, ___2838, ___4573, ___4590, ___4597, mfc); } EXTERNC tecio_API int32_t STDCALL tecgeo110_( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1412, int32_t const* ___2023, int32_t const* ___1652, int32_t const* ___2264, double const*   ___2987, double const*   ___2290, int32_t const* ___2794, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3443, int32_t const* ___496, int32_t const* ___2836, int32_t const* ___2838, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3160, ___227, ___4600, Color, ___1412, ___2023, ___1652, ___2264, ___2987, ___2290, ___2794, ___188, ___176, ___187, ___171, ___3443, ___496, ___2836, ___2838, ___4573, ___4590, ___4597, mfc); } EXTERNC tecio_API int32_t STDCALL tecgeo100_( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1412, int32_t const* ___2023, int32_t const* ___1652, int32_t const* ___2264, double const*   ___2987, double const*   ___2290, int32_t const* ___2794, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3443, int32_t const* ___496, int32_t const* ___2836,
int32_t const* ___2838, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3160, ___227, ___4600, Color, ___1412, ___2023, ___1652, ___2264, ___2987, ___2290, ___2794, ___188, ___176, ___187, ___171, ___3443, ___496, ___2836, ___2838, ___4573, ___4590, ___4597, mfc); } EXTERNC tecio_API int32_t STDCALL tecgeo_( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1412, int32_t const* ___2023, int32_t const* ___1652, int32_t const* ___2264, double const*   ___2987, double const*   ___2290, int32_t const* ___2794, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3443, int32_t const* ___2836, int32_t const* ___2838, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO(___4575, ___4592, ___4716, ___3160, ___227, ___4600, Color, ___1412, ___2023, ___1652, ___2264, ___2987, ___2290, ___2794, ___188, ___176, ___187, ___171, ___3443, ___2836, ___2838, ___4573, ___4590, ___4597, mfc); }
 #endif
int32_t STDCALL TECTXT142( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1453, double const*   ___1451, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2288, int32_t const* ___4081, int32_t const* ___3443, int32_t const* ___496, char const*     ___3813, char const*     mfc) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3988(___691, ___4575, ___4592, ___4714, ___3160, ___227, ___4600, ___353, ___1453, ___1451, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2288, ___4081, ___3443, ___496, ___3813, mfc); else
 #endif
return ___4010(___691, ___4575, ___4592, ___4714, ___3160, ___227, ___4600, ___353, ___1453, ___1451, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2288, ___4081, ___3443, ___496, ___3813, mfc); } int32_t STDCALL TECTXT112( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1453, double const*   ___1451, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2288, int32_t const* ___4081, int32_t const* ___3443, int32_t const* ___496, char const*     ___3813, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3160, ___227, ___4600, ___353, ___1453, ___1451, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2288, ___4081, ___3443, ___496, ___3813, mfc); } int32_t STDCALL TECTXT111( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1453, double const*   ___1451, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2288, int32_t const* ___4081, int32_t const* ___3443, int32_t const* ___496, char const*     ___3813, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3160, ___227, ___4600, ___353, ___1453, ___1451, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2288, ___4081, ___3443, ___496, ___3813, mfc); } int32_t STDCALL TECTXT110( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1453, double const*   ___1451, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2288, int32_t const* ___4081, int32_t const* ___3443, int32_t const* ___496, char const*     ___3813, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3160, ___227, ___4600, ___353, ___1453, ___1451, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2288, ___4081, ___3443, ___496, ___3813, mfc); } int32_t STDCALL TECTXT100( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1453, double const*   ___1451, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2288, int32_t const* ___4081, int32_t const* ___3443, int32_t const* ___496, char const*     ___3813, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3160, ___227, ___4600, ___353, ___1453, ___1451, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2288, ___4081, ___3443, ___496, ___3813, mfc); } int32_t STDCALL TECTXT( double const*   ___4576, double const*   ___4593, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1453, double const*   ___1451, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2288, int32_t const* ___4081, int32_t const* ___3443, char const*     Text, char const*     mfc) { double    ___4716     = 0.0; int       ___496 = (int)___498; return TECTXT142(___4576, ___4593, &___4716, ___3160, ___227, ___4600, ___353, ___1453, ___1451, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2288, ___4081, ___3443, &___496, Text, mfc); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tectxt142_( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1453, double const*   ___1451, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2288, int32_t const* ___4081, int32_t const* ___3443, int32_t const* ___496, char const*     ___3813, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3160, ___227, ___4600, ___353, ___1453, ___1451, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2288, ___4081, ___3443, ___496, ___3813, mfc); } EXTERNC tecio_API int32_t STDCALL tectxt112_( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1453, double const*   ___1451, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2288, int32_t const* ___4081, int32_t const* ___3443, int32_t const* ___496, char const*     ___3813, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3160, ___227, ___4600, ___353, ___1453, ___1451, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2288, ___4081, ___3443, ___496, ___3813, mfc); } EXTERNC tecio_API int32_t STDCALL tectxt111_( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1453, double const*   ___1451, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2288, int32_t const* ___4081, int32_t const* ___3443, int32_t const* ___496, char const*     ___3813, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3160, ___227, ___4600, ___353, ___1453, ___1451, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2288, ___4081, ___3443, ___496, ___3813, mfc); } EXTERNC tecio_API int32_t STDCALL tectxt110_( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1453, double const*   ___1451, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2288, int32_t const* ___4081, int32_t const* ___3443, int32_t const* ___496, char const*     ___3813, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3160, ___227, ___4600, ___353, ___1453, ___1451, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2288, ___4081, ___3443, ___496, ___3813, mfc); } EXTERNC tecio_API int32_t STDCALL tectxt100_( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1453, double const*   ___1451, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2288, int32_t const* ___4081, int32_t const* ___3443, int32_t const* ___496, char const*     ___3813, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3160, ___227, ___4600, ___353, ___1453, ___1451, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2288, ___4081, ___3443, ___496, ___3813, mfc); } EXTERNC tecio_API int32_t STDCALL tectxt_( double const*   ___4576, double const*   ___4593, int32_t const* ___3160, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1453, double const*   ___1451, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2288, int32_t const* ___4081, int32_t const* ___3443, char const*     Text, char const*     mfc) { return TECTXT(___4576, ___4593, ___3160, ___227, ___4600, ___353, ___1453, ___1451,
___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2288, ___4081, ___3443, Text, mfc); }
 #endif
int32_t STDCALL TECFIL142(int32_t const* F) { if ((*F < 1) || (*F > ___2380)) { ___3186("Err: (TECFIL142) Invalid file %d. Number must be between 1 and %d.\n", *F, ___2380); return (-1); } if (!___2042[*F-1]) { ___3185("Err: (TECFIL142) Invalid file %d. File must first be opened with TECINI.\n", *F); return (-1); } ___691 = *F-1; return 0; } int32_t STDCALL TECFIL112(int32_t const* F) { return TECFIL142(F); } int32_t STDCALL TECFIL111(int32_t const* F) { return TECFIL142(F); } int32_t STDCALL TECFIL110(int32_t const* F) { return TECFIL142(F); } int32_t STDCALL TECFIL100(int32_t const* F) { return TECFIL142(F); } int32_t STDCALL TECFIL(int32_t const* F) { return TECFIL142(F); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecfil142_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t STDCALL tecfil112_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t STDCALL tecfil111_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t STDCALL tecfil110_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t STDCALL tecfil100_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t STDCALL tecfil_(int32_t const* F) { return TECFIL142(F); }
 #endif
void STDCALL TECFOREIGN142(int32_t const* ___2891) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) ___3975(___691, ___2891); else
 #endif
___3997(___691, ___2891); } void STDCALL TECFOREIGN112(int32_t const* ___2891) { TECFOREIGN142(___2891); } void STDCALL TECFOREIGN111(int32_t const* ___2891) { TECFOREIGN142(___2891); } void STDCALL TECFOREIGN110(int32_t const* ___2891) { TECFOREIGN142(___2891); } void STDCALL TECFOREIGN100(int32_t const* ___2891) { TECFOREIGN142(___2891); }
 #if defined ___1234
EXTERNC tecio_API void STDCALL tecforeign142_(int32_t const* ___2891) { TECFOREIGN142(___2891); } EXTERNC tecio_API void STDCALL tecforeign112_(int32_t const* ___2891) { TECFOREIGN142(___2891); } EXTERNC tecio_API void STDCALL tecforeign111_(int32_t const* ___2891) { TECFOREIGN142(___2891); } EXTERNC tecio_API void STDCALL tecforeign110_(int32_t const* ___2891) { TECFOREIGN142(___2891); } EXTERNC tecio_API void STDCALL tecforeign100_(int32_t const* ___2891) { TECFOREIGN142(___2891); }
 #endif
int32_t STDCALL TECAUXSTR142( char const* ___2686, char const* ___4315) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3971(___691, ___2686, ___4315); else
 #endif
return ___3993(___691, ___2686, ___4315); } int32_t STDCALL TECAUXSTR112( char const* ___2686, char const* ___4315) { return TECAUXSTR142(___2686, ___4315); } int32_t STDCALL TECAUXSTR111( char const* ___2686, char const* ___4315) { return TECAUXSTR142(___2686, ___4315); } int32_t STDCALL TECAUXSTR110( char const* ___2686, char const* ___4315) { return TECAUXSTR142(___2686, ___4315); } int32_t STDCALL TECAUXSTR100( char const* ___2686, char const* ___4315) { return TECAUXSTR142(___2686, ___4315); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecauxstr142_( char const* ___2686, char const* ___4315) { return TECAUXSTR142(___2686, ___4315); } EXTERNC tecio_API int32_t STDCALL tecauxstr112_( char const* ___2686, char const* ___4315) { return TECAUXSTR142(___2686, ___4315); } EXTERNC tecio_API int32_t STDCALL tecauxstr111_( char const* ___2686, char const* ___4315) { return TECAUXSTR142(___2686, ___4315); } EXTERNC tecio_API int32_t STDCALL tecauxstr110_( char const* ___2686, char const* ___4315) { return TECAUXSTR142(___2686, ___4315); } EXTERNC tecio_API int32_t STDCALL tecauxstr100_( char const* ___2686, char const* ___4315) { return TECAUXSTR142(___2686, ___4315); }
 #endif
int32_t STDCALL TECZAUXSTR142( char const* ___2686, char const* ___4315) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3991(___691, ___2686, ___4315); else
 #endif
return ___4013(___691, ___2686, ___4315); } int32_t STDCALL TECZAUXSTR112( char const* ___2686, char const* ___4315) { return TECZAUXSTR142(___2686, ___4315); } int32_t STDCALL TECZAUXSTR111( char const* ___2686, char const* ___4315) { return TECZAUXSTR142(___2686, ___4315); } int32_t STDCALL TECZAUXSTR110( char const* ___2686, char const* ___4315) { return TECZAUXSTR142(___2686, ___4315); } int32_t STDCALL TECZAUXSTR100( char const* ___2686, char const* ___4315) { return TECZAUXSTR142(___2686, ___4315); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL teczauxstr142_( char const* ___2686, char const* ___4315) { return TECZAUXSTR142(___2686, ___4315); } EXTERNC tecio_API int32_t STDCALL teczauxstr112_( char const* ___2686, char const* ___4315) { return TECZAUXSTR142(___2686, ___4315); } EXTERNC tecio_API int32_t STDCALL teczauxstr111_( char const* ___2686, char const* ___4315) { return TECZAUXSTR142(___2686, ___4315); } EXTERNC tecio_API int32_t STDCALL teczauxstr110_( char const* ___2686, char const* ___4315) { return TECZAUXSTR142(___2686, ___4315); } EXTERNC tecio_API int32_t STDCALL teczauxstr100_( char const* ___2686, char const* ___4315) { return TECZAUXSTR142(___2686, ___4315); }
 #endif
int32_t STDCALL TECVAUXSTR142( int32_t const* ___4337, char const*     ___2686, char const*     ___4315) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3990(___691, ___4337, ___2686, ___4315); else
 #endif
return ___4012(___691, ___4337, ___2686, ___4315); } int32_t STDCALL TECVAUXSTR112( int32_t const* ___4337, char const*     ___2686, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2686, ___4315); } int32_t STDCALL TECVAUXSTR111( int32_t const* ___4337, char const*     ___2686, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2686, ___4315); } int32_t STDCALL TECVAUXSTR110( int32_t const* ___4337, char const*     ___2686, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2686, ___4315); } int32_t STDCALL TECVAUXSTR100( int32_t const* ___4337, char const*     ___2686, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2686, ___4315); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecvauxstr142_( int32_t const* ___4337, char const*     ___2686, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2686, ___4315); } EXTERNC tecio_API int32_t STDCALL tecvauxstr112_( int32_t const* ___4337, char const*     ___2686, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2686, ___4315); } EXTERNC tecio_API int32_t STDCALL tecvauxstr111_( int32_t const* ___4337, char const*     ___2686, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2686, ___4315); } EXTERNC tecio_API int32_t STDCALL tecvauxstr110_( int32_t const* ___4337, char const*     ___2686, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2686, ___4315); } EXTERNC tecio_API int32_t STDCALL tecvauxstr100_( int32_t const* ___4337, char const*     ___2686, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2686, ___4315); }
 #endif
int32_t STDCALL TECFACE142(int32_t const* ___1258) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3974(___691, ___1258); else
 #endif
return ___3996(___691, ___1258); } int32_t STDCALL TECFACE112(int32_t const* ___1258) { return TECFACE142(___1258); } int32_t STDCALL TECFACE111(int32_t const* ___1258) { return TECFACE142(___1258); } int32_t STDCALL TECFACE110(int32_t const* ___1258) { return TECFACE142(___1258); } int32_t STDCALL TECFACE100(int32_t const* ___1258) { return TECFACE142(___1258); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecface142_(int32_t const* ___1258) { return TECFACE142(___1258); } EXTERNC tecio_API int32_t STDCALL tecface112_(int32_t const* ___1258) { return TECFACE142(___1258); } EXTERNC tecio_API int32_t STDCALL tecface111_(int32_t const* ___1258) { return TECFACE142(___1258); } EXTERNC tecio_API int32_t STDCALL tecface110_(int32_t const* ___1258) { return TECFACE142(___1258); } EXTERNC tecio_API int32_t STDCALL tecface100_(int32_t const* ___1258) { return TECFACE142(___1258); }
 #endif
int32_t STDCALL TECPOLY142( int32_t const* ___1294, int32_t const* ___1297, int32_t const* ___1259, int32_t const* ___1303, int32_t const* ___1253, int32_t const* ___1254, int32_t const* ___1256) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3983(___691, ___1294, ___1297, ___1259, ___1303, ___1253, ___1254, ___1256); else
 #endif
return ___4005(___691, ___1294, ___1297, ___1259, ___1303, ___1253, ___1254, ___1256); } int32_t STDCALL TECPOLY112( int32_t const* ___1294, int32_t const* ___1297, int32_t const* ___1259, int32_t const* ___1303, int32_t const* ___1253, int32_t const* ___1254, int32_t const* ___1256) { return TECPOLY142(___1294, ___1297, ___1259, ___1303, ___1253, ___1254, ___1256); } int32_t STDCALL TECPOLY111( int32_t const* ___1294, int32_t const* ___1297, int32_t const* ___1259, int32_t const* ___1303, int32_t const* ___1253, int32_t const* ___1254, int16_t const* ___1256) { int32_t    ___3359 = 0; ___1172 *___1307 = NULL; int32_t ___4190; int32_t ___4191;
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) { ___4190 = ___3986(___691); ___4191 = ___3987(___691); } else
 #endif
{ ___4190 = ___4008(___691); ___4191 = ___4009(___691); } if (___4190 > 0) { ___23(___4190, ___1172, "32-bit FaceBndryConnectionZones"); if (___1307 != NULL) { for (___2227 face = 0; face < ___4191; face++) ___1307[face] = (___1172)___1256[face]; } else { ___3184("Err: (TECPOLY111) Out of memory allocating temporary data.\n"); return (-1); } } ___3359 = TECPOLY142(___1294, ___1297, ___1259, ___1303, ___1253, ___1254, ___1307); if (___1307 != NULL) ___1530(___1307, "32-bit FaceBndryConnectionZones"); return ___3359; }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecpoly142_( int32_t const* ___1294, int32_t const* ___1297, int32_t const* ___1259, int32_t const* ___1303, int32_t const* ___1255, int32_t const* ___1254, int32_t const* ___1256) { return TECPOLY142(___1294, ___1297, ___1259, ___1303, ___1255, ___1254, ___1256); } EXTERNC tecio_API int32_t STDCALL tecpoly112_( int32_t const* ___1294, int32_t const* ___1297, int32_t const* ___1259, int32_t const* ___1303, int32_t const* ___1255, int32_t const* ___1254, int32_t const* ___1256) { return TECPOLY142(___1294, ___1297, ___1259, ___1303, ___1255, ___1254, ___1256); } EXTERNC tecio_API int32_t STDCALL tecpoly111_( int32_t const* ___1294, int32_t const* ___1297, int32_t const* ___1259, int32_t const* ___1303, int32_t const* ___1255, int32_t const* ___1254, int16_t const* ___1256) { return TECPOLY111(___1294, ___1297, ___1259, ___1303, ___1255, ___1254, ___1256); }
 #endif
int32_t STDCALL TECPOLYFACE142( int32_t const* ___2806, int32_t const* ___1294, int32_t const* ___1297, int32_t const* ___1259, int32_t const* ___1303) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3985(___691, ___2806, ___1294, ___1297, ___1259, ___1303); else
 #endif
return ___4007(___691, ___2806, ___1294, ___1297, ___1259, ___1303); } int32_t STDCALL TECPOLYFACE112( int32_t const* ___2806, int32_t const* ___1294, int32_t const* ___1297, int32_t const* ___1259, int32_t const* ___1303) { return TECPOLYFACE142(___2806, ___1294, ___1297, ___1259, ___1303); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecpolyface142_( int32_t const* ___2806, int32_t const* ___1294, int32_t const* ___1297, int32_t const* ___1259, int32_t const* ___1303) { return TECPOLYFACE142(___2806, ___1294, ___1297, ___1259, ___1303); } EXTERNC tecio_API int32_t STDCALL tecpolyface112_( int32_t const* ___2806, int32_t const* ___1294, int32_t const* ___1297, int32_t const* ___1259, int32_t const* ___1303) { return TECPOLYFACE142(___2806, ___1294, ___1297, ___1259, ___1303); }
 #endif
int32_t STDCALL TECPOLYBCONN142( int32_t const* ___2778, int32_t const* ___1253, int32_t const* ___1254, int32_t const* ___1256) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) return ___3984(___691, ___2778, ___1253, ___1254, ___1256); else
 #endif
return ___4006(___691, ___2778, ___1253, ___1254, ___1256); } int32_t STDCALL TECPOLYBCONN112( int32_t const* ___2778, int32_t const* ___1253, int32_t const* ___1254, int32_t const* ___1256) { return TECPOLYBCONN142(___2778, ___1253, ___1254, ___1256); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecpolybconn142_( int32_t const* ___2778, int32_t const* ___1253, int32_t const* ___1254, int32_t const* ___1256) { return TECPOLYBCONN142(___2778, ___1253, ___1254, ___1256); } EXTERNC tecio_API int32_t STDCALL tecpolybconn112_( int32_t const* ___2778, int32_t const* ___1253, int32_t const* ___1254, int32_t const* ___1256) { return TECPOLYBCONN142(___2778, ___1253, ___1254, ___1256); }
 #endif
int32_t STDCALL TECFEPTN142( int32_t const* ___2977, int32_t const* numnodes, int32_t const* numcells, int32_t const* ngnodes, int32_t const* gnodes, int32_t const* gnpartitions, int32_t const* gnpnodes, int32_t const* ngcells, int32_t const* gcells) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) { ___3184("Err: (TECFEPTN142) Can be called only for SZL data (FileFormat = 1).\n"); return 9; } else
 #endif
return TECIOSZL_FEPTN( ___691, ___2977, numnodes, numcells, ngnodes, gnodes, gnpartitions, gnpnodes, ngcells, gcells); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecfeptn142_( int32_t const* ___2977, int32_t const* numnodes, int32_t const* numcells, int32_t const* ngnodes, int32_t const* gnodes, int32_t const* gnpartitions, int32_t const* gnpnodes, int32_t const* ngcells, int32_t const* gcells) { return TECFEPTN142( ___2977, numnodes, numcells, ngnodes, gnodes, gnpartitions, gnpnodes, ngcells, gcells); }
 #endif
int32_t STDCALL TECIJKPTN142( int32_t const* ___2977, int32_t const* imin, int32_t const* jmin, int32_t const* kmin, int32_t const* imax, int32_t const* jmax, int32_t const* kmax) {
 #if !defined TECIOMPI
if (___1391[___691] == FILEFORMAT_PLT) { ___3184("Err: (TECIJKPTN142) Can be called only for SZL data (FileFormat = 1).\n"); return 9; } else
 #endif
return TECIOSZL_IJKPTN( ___691, ___2977, imin, jmin, kmin, imax, jmax, kmax); }
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecijkptn142_( int32_t const* ___2977, int32_t const* imin, int32_t const* jmin, int32_t const* kmin, int32_t const* imax, int32_t const* jmax, int32_t const* kmax) { return TECIJKPTN142( ___2977, imin, jmin, kmin, imax, jmax, kmax); }
 #endif
int32_t STDCALL TECMPIINIT142(void* communicator, int32_t const* mainrank) {
 #   if !defined TECIOMPI
___4278(communicator); ___4278(mainrank); ___3184("Err: (TECMPIINIT142) To use the TECIO MPI symbols you must link your application " "with the teciompi library instead of the non-MPI version, tecio.\n"); return -1;
 #   else
if (!communicator) return 1; else if (!mainrank || *mainrank < 0) return 2; return TECIOSZL_MPIINIT(&___691, communicator, mainrank);
 #   endif
}
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecmpiinit142_(void* communicator, int32_t const* mainrank) { return TECMPIINIT142(communicator, mainrank); }
 #endif
int32_t STDCALL TECZNEMAP142(int32_t const* npartitions, int32_t const* ptnranks) {
 #   if !defined TECIOMPI
___4278(npartitions); ___4278(ptnranks); ___3184("Err: (TECZNEMAP142) To use the TECIO MPI symbols you must link your application " "with the teciompi library instead of the non-MPI version, tecio.\n"); return -1;
 #   else
if (!npartitions) ___3184("Err: (TECZNEMAP142) Bad value <NULL> for parameter npartitions.\n"); else if (*npartitions < 1) ___3185("Err: (TECZNEMAP142) Bad value for parameter npartitions: %d.\n", *npartitions); else if (!ptnranks) ___3184("Err: (TECZNEMAP142) Bad value <NULL> for parameter ptnranks.\n"); else return TECIOSZL_ZNEMAP(___691, npartitions, ptnranks); return -1;
 #   endif
}
 #if defined ___1234
EXTERNC tecio_API int32_t STDCALL tecznemap142_(int32_t* npartitions, int32_t* ptnworkers) { return TECZNEMAP142(npartitions, ptnworkers); }
 #endif
EXTERNC tecio_API int32_t STDCALL convertrawdata(char const* ___1394) { return tecioszl_convertrawdata(___1394); } namespace { bool validFileHandle(void* fileHandle, char const* routine) { if (fileFormatForHandle.find(fileHandle) == fileFormatForHandle.end()) { std::cerr << "Invalid file handle passed to routine " << routine << std::endl; return false; } else { return true; } } } int32_t tecCustomLabelsGetNumSets(void* fileHandle, int32_t* numSets) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(numSets)) std::cerr << "Invalid 'numSets' parameter to tecCustomLabelsGetNumSets. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_CustomLabelsGetNumSets(fileHandle, numSets); else ___478(!"Not implemented for .plt files"); return -1; } namespace { int32_t numCustomLabelSets(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t numSets; if (tecCustomLabelsGetNumSets(fileHandle, &numSets) == 0) return numSets; return 0; } } int32_t tecCustomLabelsGetSet(void* fileHandle, int32_t ___4453, char** labelSet) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4453 <= 0 || numCustomLabelSets(fileHandle) < ___4453) std::cerr << "Invalid 'whichSet' parameter to tecCustomLabelsGetSet. Must be 0 < whichSet <= numSets (" << numCustomLabelSets(fileHandle) << ")." << std::endl; else if (!VALID_REF(labelSet) || *labelSet != NULL) std::cerr << "Invalid 'labelSet' parameter to tecCustomLabelsGetSet. Must be a valid memory reference and point to NULL." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_CustomLabelsGetSet(fileHandle, ___4453, labelSet); else ___478(!"Not implemented for .plt files"); return -1; } namespace { int32_t numDataSetAuxDataItems(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3358; tecDataSetAuxDataGetNumItems(fileHandle, &___3358); return ___3358; } } int32_t tecDataSetAuxDataGetItem(void* fileHandle, int32_t whichItem, char** ___2685, char** ___4314) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (whichItem <= 0 || numDataSetAuxDataItems(fileHandle) < whichItem) std::cerr << "Invalid 'whichItem' parameter to tecDataSetAuxDataGetItem. Must be 0 < whichItem <= numItems." << std::endl; else if (!VALID_REF(___2685) || *___2685 != NULL) std::cerr << "Invalid 'name' parameter to tecDataSetAuxDataGetItem. Must be a valid memory reference and point to NULL." << std::endl; else if (!VALID_REF(___4314) || *___4314 != NULL) std::cerr << "Invalid 'value' parameter to tecDataSetAuxDataGetItem. Must be a valid memory reference and point to NULL." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_DataSetAuxDataGetItem(fileHandle, whichItem, ___2685, ___4314); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecDataSetAuxDataGetNumItems(void* fileHandle, int32_t* ___2812) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(___2812)) std::cerr << "Invalid 'numItems' parameter to tecDataSetAuxDataGetNumItems. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_DataSetAuxDataGetNumItems(fileHandle, ___2812); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecDataSetGetNumVars(void* fileHandle, int32_t* ___2843) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(___2843)) std::cerr << "Invalid 'numVars' parameter to tecDataSetGetNumVars. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_DataSetGetNumVars(fileHandle, ___2843); else ___478(!"Not implemented for .plt files"); return -1; } namespace { int32_t ___2843(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3358 = 0; if (tecDataSetGetNumVars(fileHandle, &___3358) == 0) return ___3358; return 0; } } int32_t tecDataSetGetNumZones(void* fileHandle, int32_t* ___2846) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(___2846)) std::cerr << "Invalid 'numZones' parameter to tecDataSetGetNumZones. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_DataSetGetNumZones(fileHandle, ___2846); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecDataSetGetTitle(void* fileHandle, char** ___4177) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(___4177) || *___4177 != NULL) std::cerr << "Invalid 'title' parameter to tecDataSetGetTitle. Must be a valid memory reference and point to NULL." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_DataSetGetTitle(fileHandle, ___4177); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecFileGetType(void* fileHandle, int32_t* ___1407) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1;
if (!VALID_REF(___1407)) std::cerr << "Invalid '___1407' parameter to tecFileGetType. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_FileGetType(fileHandle, ___1407); else ___478(!"Not ___1907 for .plt files"); return -1; } int32_t tecFileReaderClose(void** fileHandle) { int32_t returnCode = -1; if (validFileHandle(*fileHandle, "tecFileReaderClose")) { if (fileFormatForHandle[*fileHandle] == FILEFORMAT_SZL) returnCode = tecioSZL_FileReaderClose(fileHandle); else ___478(!"Not ___1907 for .plt"); fileFormatForHandle.erase(*fileHandle); } return returnCode; } int32_t tecFileReaderOpen(char const* ___1394, void** fileHandle) { int32_t ___3358 = 0; if (!___1394 || strlen(___1394) == 0) { std::cerr << "tecFileReaderOpen: Bad ___1394 parameter."; ___3358 = -1; } if (!fileHandle) { std::cerr << "tecFileReaderOpen: Bad fileHandle parameter."; ___3358 = -1; } *fileHandle = NULL; switch (tecioSZL_FileReaderOpen(___1394, fileHandle)) { case TecioSZLFileOpenResult_OK: fileFormatForHandle[*fileHandle] = FILEFORMAT_SZL; break; case TecioSZLFileOpenResult_ErrorOpeningFile: std::cerr << "tecFileReaderOpen: Error opening file \"" << ___1394 << "\" for reading." << std::endl; ___3358 = -1; break; case TecioSZLFileOpenResult_BadFormat: std::cerr << "tecFileReaderOpen: File \"" << ___1394 << "\" does not appear to be a .szplt file"; ___3358 = -1; break; case TecioSZLFileOpenResult_OutOfMemory: std::cerr << "Error reading file \"" << ___1394 << ".\" Out of memory." << std::endl; ___3358 = -1; break; default: ___478(___1305); ___3358 = -1; break; } ENSURE(EQUIVALENCE(___3358 == 0, VALID_REF(*fileHandle))); return ___3358; } namespace { int32_t numGeoms(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3358; if (tecGeomGetNumGeoms(fileHandle, &___3358) == 0) return ___3358; return 0; } bool validGeom(void* fileHandle, int32_t ___1555, char const* routineName) { REQUIRE(VALID_REF(fileHandle)); if (___1555 <= 0 || numGeoms(fileHandle) < ___1555) { std::cerr << "Invalid '___1555' parameter to " << routineName << ". Must be 0 < ___1555 <= numGeoms (" << numGeoms(fileHandle) << ")." << std::endl; return false; } return true; } } int32_t tecGeomArrowheadGetAngle(void* fileHandle, int32_t ___1555, double* ___56) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(___56)) std::cerr << "Invalid '___56' parameter to tecGeomArrowheadGetAngle. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomArrowheadGetAngle(fileHandle, ___1555, ___56); else ___478(!"Not ___1907 for .plt files"); return -1; } int32_t tecGeomArrowheadGetAttach(void* fileHandle, int32_t ___1555, int32_t* attachment) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(attachment)) std::cerr << "Invalid 'attachment' parameter to tecGeomArrowheadGetAttach. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomArrowheadGetAttach(fileHandle, ___1555, attachment); else ___478(!"Not ___1907 for .plt files"); return -1; } int32_t tecGeomArrowheadGetSize(void* fileHandle, int32_t ___1555, double* arrowheadSize) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(arrowheadSize)) std::cerr << "Invalid 'arrowheadSize' parameter to tecGeomArrowheadGetSize. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomArrowheadGetSize(fileHandle, ___1555, arrowheadSize); else ___478(!"Not ___1907 for .plt files"); return -1; } int32_t tecGeomArrowheadGetStyle(void* fileHandle, int32_t ___1555, int32_t* arrowheadStyle) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(arrowheadStyle)) std::cerr << "Invalid 'arrowheadStyle' parameter to tecGeomArrowheadGetStyle. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomArrowheadGetStyle(fileHandle, ___1555, arrowheadStyle); else ___478(!"Not ___1907 for .plt files"); return -1; } namespace { GeomType_e ___1651(void* fileHandle, int32_t ___1555) { int32_t type; if (tecGeomGetType(fileHandle, ___1555, &type) == 0) return (GeomType_e)type; return GeomType_Invalid; } } int32_t tecGeomCircleGetRadius(void* fileHandle, int32_t ___1555, double* radius) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (___1651(fileHandle, ___1555) != GeomType_Circle) std::cerr << "Invalid '___1555' parameter to tecGeomCircleGetRadius. The referenced geometry must be a circle." << std::endl; else if (!VALID_REF(radius)) std::cerr << "Invalid 'radius' parameter to tecGeomCircleGetRadius. Must be a valid memory reference." << std::endl;
else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomCircleGetRadius(fileHandle, ___1555, radius); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomEllipseGetNumPoints(void* fileHandle, int32_t ___1555, int32_t* numEllipsePoints) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (___1651(fileHandle, ___1555) != GeomType_Ellipse && ___1651(fileHandle, ___1555) != GeomType_Circle) std::cerr << "Invalid 'geom' parameter to tecGeomEllipseGetNumPoints. The referenced geometry must be an ellipse or a circle." << std::endl; else if (!VALID_REF(numEllipsePoints)) std::cerr << "Invalid 'numEllipsePoints' parameter to tecGeomEllipseGetNumPoints. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomEllipseGetNumPoints(fileHandle, ___1555, numEllipsePoints); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomEllipseGetSize(void* fileHandle, int32_t ___1555, double* horizontalAxis, double* verticalAxis) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (___1651(fileHandle, ___1555) != GeomType_Ellipse) std::cerr << "Invalid 'geom' parameter to tecGeomEllipseGetSize. The referenced geometry must be an ellipse." << std::endl; else if (!VALID_REF(horizontalAxis)) std::cerr << "Invalid 'horizontalAxis' parameter to tecGeomEllipseGetSize. Must be a valid memory reference." << std::endl; else if (!VALID_REF(verticalAxis)) std::cerr << "Invalid 'verticalAxis' parameter to tecGeomEllipseGetSize. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomEllipseGetSize(fileHandle, ___1555, horizontalAxis, verticalAxis); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomGetAnchorPos(void* fileHandle, int32_t ___1555, double* x, double* ___4583, double* z) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(x)) std::cerr << "Invalid 'x' parameter to tecGeomGetAnchorPos. Must be a valid memory reference." << std::endl; else if (!VALID_REF(___4583)) std::cerr << "Invalid 'y' parameter to tecGeomGetAnchorPos. Must be a valid memory reference." << std::endl; else if (!VALID_REF(z)) std::cerr << "Invalid 'z' parameter to tecGeomGetAnchorPos. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomGetAnchorPos(fileHandle, ___1555, x, ___4583, z); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomGetClipping(void* fileHandle, int32_t ___1555, int32_t* ___495) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(___495)) std::cerr << "Invalid 'clipping' parameter to tecGeomGetClipping. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomGetClipping(fileHandle, ___1555, ___495); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomGetColor(void* fileHandle, int32_t ___1555, int32_t* color) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(color)) std::cerr << "Invalid 'color' parameter to tecGeomGetColor. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomGetColor(fileHandle, ___1555, color); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomGetCoordMode(void* fileHandle, int32_t ___1555, int32_t* coordMode) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(coordMode)) std::cerr << "Invalid 'coordMode' parameter to tecGeomGetCoordMode. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomGetCoordMode(fileHandle, ___1555, coordMode); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomGetFillColor(void* fileHandle, int32_t ___1555, int32_t* ___1411) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(___1411)) std::cerr << "Invalid 'fillColor' parameter to tecGeomGetFillColor. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomGetFillColor(fileHandle, ___1555, ___1411); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomGetLinePattern(void* fileHandle, int32_t ___1555, int32_t* ___2263) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(___2263)) std::cerr << "Invalid 'linePattern' parameter to tecGeomGetLinePattern. Must be a valid memory reference." << std::endl;
else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomGetLinePattern(fileHandle, ___1555, ___2263); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomGetLineThickness(void* fileHandle, int32_t ___1555, double* ___2289) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(___2289)) std::cerr << "Invalid 'lineThickness' parameter to tecGeomGetLineThickness. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomGetLineThickness(fileHandle, ___1555, ___2289); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomGetMacroFunctionCmd(void* fileHandle, int32_t ___1555, char** macroFunctionCmd) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(macroFunctionCmd) || *macroFunctionCmd != NULL) std::cerr << "Invalid 'macroFunctionCmd' parameter to tecGeomGetMacroFunctionCmd. Must be a valid memory reference and point to NULL." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomGetMacroFunctionCmd(fileHandle, ___1555, macroFunctionCmd); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomGetNumGeoms(void* fileHandle, int32_t* numGeoms) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(numGeoms)) std::cerr << "Invalid 'numGeoms' parameter to tecGeomGetNumGeoms. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomGetNumGeoms(fileHandle, numGeoms); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomGetPatternLength(void* fileHandle, int32_t ___1555, double* ___2986) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(___2986)) std::cerr << "Invalid 'patternLength' parameter to tecGeomGetPatternLength. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomGetPatternLength(fileHandle, ___1555, ___2986); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomGetScope(void* fileHandle, int32_t ___1555, int32_t* ___3442) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(___3442)) std::cerr << "Invalid 'scope' parameter to tecGeomGetScope. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomGetScope(fileHandle, ___1555, ___3442); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomGetType(void* fileHandle, int32_t ___1555, int32_t* type) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(type)) std::cerr << "Invalid 'type' parameter to tecGeomGetType. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomGetType(fileHandle, ___1555, type); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomGetZone(void* fileHandle, int32_t ___1555, int32_t* zone) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(zone)) std::cerr << "Invalid 'zone' parameter to tecGeomGetZone. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomGetZone(fileHandle, ___1555, zone); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomIsAttached(void* fileHandle, int32_t ___1555, int32_t* ___2004) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(___2004)) std::cerr << "Invalid 'isAttached' parameter to tecGeomIsAttached. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomIsAttached(fileHandle, ___1555, ___2004); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomIsFilled(void* fileHandle, int32_t ___1555, int32_t* ___2022) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (!VALID_REF(___2022)) std::cerr << "Invalid 'isFilled' parameter to tecGeomIsFilled. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomIsFilled(fileHandle, ___1555, ___2022); else ___478(!"Not implemented for .plt files"); return -1; } namespace { int32_t ___2835(void* fileHandle, int32_t ___1555) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3358; if (tecGeomLineGetSegmentCount(fileHandle, ___1555, &___3358) == 0) return ___3358; return 0; } int32_t segmentPointCount(void* fileHandle, int32_t ___1555, int32_t segment)
{ REQUIRE(VALID_REF(fileHandle)); REQUIRE(___1555 > 0); REQUIRE(segment > 0); int32_t pointCount; if (tecGeomLineSegmentGetPointCount(fileHandle, ___1555, segment, &pointCount) == 0) return pointCount; return 0; } } int32_t tecGeomLineGetPoint(void* fileHandle, int32_t ___1555, int32_t segment, int32_t index, double* x, double* ___4583, double* z) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (___1651(fileHandle, ___1555) != GeomType_LineSegs && ___1651(fileHandle, ___1555) != GeomType_LineSegs3D) std::cerr << "Invalid 'geom' parameter to tecGeomLineGetPoint. Must be a line-type geometry." << std::endl; else if (segment <= 0 || ___2835(fileHandle, ___1555) < segment) std::cerr << "Invalid 'segment' parameter to tecGeomLineSegmentGetPointCount. Must be 0 < segment <= numSegments (" << ___2835(fileHandle, ___1555) << ")." << std::endl; else if (index < 1 || segmentPointCount(fileHandle, ___1555, segment) < index) std::cerr << "Invalid 'index' parameter to tecGeomLineGetPoint. Must be 0 < index < segmentPointCount (" << segmentPointCount(fileHandle, ___1555, segment) << " for this segment)." << std::endl; else if (!VALID_REF(x)) std::cerr << "Invalid 'x' parameter to tecGeomLineGetPoint. Must be a valid memory reference." << std::endl; else if (!VALID_REF(___4583)) std::cerr << "Invalid 'y' parameter to tecGeomLineGetPoint. Must be a valid memory reference." << std::endl; else if (!VALID_REF(z)) std::cerr << "Invalid 'z' parameter to tecGeomLineGetPoint. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomLineGetPoint(fileHandle, ___1555, segment, index, x, ___4583, z); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomLineGetSegmentCount(void* fileHandle, int32_t ___1555, int32_t* segmentCount) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (___1651(fileHandle, ___1555) != GeomType_LineSegs && ___1651(fileHandle, ___1555) != GeomType_LineSegs3D) std::cerr << "Invalid 'geom' parameter to tecGeomLineGetSegmentCount. Must be a line-type geometry." << std::endl; else if (!VALID_REF(segmentCount)) std::cerr << "Invalid 'segmentCount' parameter to tecGeomLineGetSegmentCount. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomLineGetSegmentCount(fileHandle, ___1555, segmentCount); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomLineSegmentGetPointCount(void* fileHandle, int32_t ___1555, int32_t segment, int32_t* pointCount) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (___1651(fileHandle, ___1555) != GeomType_LineSegs && ___1651(fileHandle, ___1555) != GeomType_LineSegs3D) std::cerr << "Invalid 'geom' parameter to tecGeomLineSegmentGetPointCount. Must be a line-type geometry." << std::endl; else if (segment <= 0 || ___2835(fileHandle, ___1555) < segment) std::cerr << "Invalid 'segment' parameter to tecGeomLineSegmentGetPointCount. Must be 0 < segment <= numSegments (" << ___2835(fileHandle, ___1555) << ")." << std::endl; else if (!VALID_REF(pointCount)) std::cerr << "Invalid 'pointCount' parameter to tecGeomLineSegmentGetPointCount. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomLineSegmentGetPointCount(fileHandle, ___1555, segment, pointCount); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomRectangleGetSize(void* fileHandle, int32_t ___1555, double* ___4458, double* ___1826) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (___1651(fileHandle, ___1555) != GeomType_Rectangle) std::cerr << "Invalid 'geom' parameter to tecGeomRectangleGetSize. The referenced geometry must be a rectangle." << std::endl; else if (!VALID_REF(___4458)) std::cerr << "Invalid 'width' parameter to tecGeomRectangleGetSize. Must be a valid memory reference." << std::endl; else if (!VALID_REF(___1826)) std::cerr << "Invalid 'height' parameter to tecGeomRectangleGetSize. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_GeomRectangleGetSize(fileHandle, ___1555, ___4458, ___1826); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecGeomSquareGetSize(void* fileHandle, int32_t ___1555, double* size) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1555, FUNCTION_NAME)) return -1; if (___1651(fileHandle, ___1555) != GeomType_Square) std::cerr << "Invalid 'geom' parameter to tecGeomSquareGetSize. The referenced geometry must be a square." << std::endl; else if (!VALID_REF(size)) std::cerr << "Invalid 'size' parameter to tecGeomSquareGetSize. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL)
return tecioSZL_GeomSquareGetSize(fileHandle, ___1555, size); else ___478(!"Not implemented for .plt files"); return -1; } void tecStringFree(char** string) { delete[] *string; *string = NULL; } int32_t tecStringLength(char const* string) { if (!VALID_REF(string)) return -1; return static_cast<int32_t>(strlen(string)); } namespace { int32_t numTexts(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3358; if (tecTextGetNumTexts(fileHandle, &___3358) == 0) return ___3358; return 0; } bool validText(void* fileHandle, int32_t ___4042, char const* routineName) { REQUIRE(VALID_REF(fileHandle)); if (___4042 < 0 || numTexts(fileHandle) < ___4042) { std::cerr << "Invalid 'text' parameter passed to " << routineName << ". must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; return false; } return true; } } int32_t tecTextBoxGetColor(void* fileHandle, int32_t ___4042, int32_t* ___402) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validText(fileHandle, ___4042, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextBoxGetColor. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(___402)) std::cerr << "Invalid 'boxColor' parameter to tecTextBoxGetColor. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextBoxGetColor(fileHandle, ___4042, ___402); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextBoxGetFillColor(void* fileHandle, int32_t ___4042, int32_t* ___404) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextBoxGetFillColor. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(___404)) std::cerr << "Invalid 'boxFillColor' parameter to tecTextBoxGetFillColor. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextBoxGetFillColor(fileHandle, ___4042, ___404); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextBoxGetLineThickness(void* fileHandle, int32_t ___4042, double* ___406) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextBoxGetLineThickness. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(___406)) std::cerr << "Invalid 'boxLineThickness' parameter to tecTextBoxGetLineThickness. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextBoxGetLineThickness(fileHandle, ___4042, ___406); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextBoxGetMargin(void* fileHandle, int32_t ___4042, double* ___408) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextBoxGetMargin. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(___408)) std::cerr << "Invalid 'boxMargin' parameter to tecTextBoxGetMargin. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextBoxGetMargin(fileHandle, ___4042, ___408); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextBoxGetType(void* fileHandle, int32_t ___4042, int32_t* ___410) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextBoxGetType. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(___410)) std::cerr << "Invalid 'boxType' parameter to tecTextBoxGetType. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextBoxGetType(fileHandle, ___4042, ___410); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetAnchor(void* fileHandle, int32_t ___4042, int32_t* ___38) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetAnchor. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(___38)) std::cerr << "Invalid 'anchor' parameter to tecTextGetAnchor. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetAnchor(fileHandle, ___4042, ___38); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetAnchorPos(void* fileHandle, int32_t ___4042, double* x, double* ___4583, double* z) { if (!validFileHandle(fileHandle, FUNCTION_NAME))
return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetAnchorPos. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(x)) std::cerr << "Invalid 'x' parameter to tecTextGetAnchorPos. Must be a valid memory reference." << std::endl; else if (!VALID_REF(___4583)) std::cerr << "Invalid 'y' parameter to tecTextGetAnchorPos. Must be a valid memory reference." << std::endl; else if (!VALID_REF(z)) std::cerr << "Invalid 'z' parameter to tecTextGetAnchorPos. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetAnchorPos(fileHandle, ___4042, x, ___4583, z); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetAngle(void* fileHandle, int32_t ___4042, double* ___56) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetAngle. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(___56)) std::cerr << "Invalid 'angle' parameter to tecTextGetAngle. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetAngle(fileHandle, ___4042, ___56); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetClipping(void* fileHandle, int32_t ___4042, int32_t* ___495) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetClipping. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(___495)) std::cerr << "Invalid 'clipping' parameter to tecTextGetClipping. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetClipping(fileHandle, ___4042, ___495); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetColor(void* fileHandle, int32_t ___4042, int32_t* color) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetColor. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(color)) std::cerr << "Invalid 'color' parameter to tecTextGetColor. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetColor(fileHandle, ___4042, color); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetCoordMode(void* fileHandle, int32_t ___4042, int32_t* coordMode) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetCoordMode. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(coordMode)) std::cerr << "Invalid 'coordMode' parameter to tecTextGetCoordMode. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetCoordMode(fileHandle, ___4042, coordMode); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetHeight(void* fileHandle, int32_t ___4042, double* ___1826) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetHeight. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(___1826)) std::cerr << "Invalid 'height' parameter to tecTextGetHeight. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetHeight(fileHandle, ___4042, ___1826); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetLineSpacing(void* fileHandle, int32_t ___4042, double* ___2287) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetLineSpacing. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(___2287)) std::cerr << "Invalid 'lineSpacing' parameter to tecTextGetLineSpacing. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetLineSpacing(fileHandle, ___4042, ___2287); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetMacroFunctionCmd(void* fileHandle, int32_t ___4042, char** macroFunctionCmd) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetMacroFunctionCmd. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(macroFunctionCmd) || *macroFunctionCmd != NULL)
std::cerr << "Invalid 'macroFunctionCmd' parameter to tecTextGetMacroFunctionCmd. Must be a valid memory reference and point to NULL." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetMacroFunctionCmd(fileHandle, ___4042, macroFunctionCmd); else ___478(!"Not implemented for .plt files"); return -1; } EXTERNC tecio_API int32_t tecTextGetNumTexts(void* fileHandle, int32_t* numTexts) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(numTexts)) std::cerr << "Invalid 'numTexts' parameter to tecTextGetNumTexts. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetNumTexts(fileHandle, numTexts); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetScope(void* fileHandle, int32_t ___4042, int32_t* ___3442) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetScope. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(___3442)) std::cerr << "Invalid 'scope' parameter to tecTextGetScope. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetScope(fileHandle, ___4042, ___3442); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetSizeUnits(void* fileHandle, int32_t ___4042, int32_t* sizeUnits) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetSizeUnits. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(sizeUnits)) std::cerr << "Invalid 'sizeUnits' parameter to tecTextGetSizeUnits. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetSizeUnits(fileHandle, ___4042, sizeUnits); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetString(void* fileHandle, int32_t ___4042, char** string) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetString. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(string) || *string != NULL) std::cerr << "Invalid 'string' parameter to tecTextGetString. Must be a valid memory reference and point to NULL." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetString(fileHandle, ___4042, string); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetTypeface(void* fileHandle, int32_t ___4042, char** typeface) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetTypeface. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(typeface) || *typeface != NULL) std::cerr << "Invalid 'typeface' parameter to tecTextGetTypeface. Must be a valid memory reference and point to NULL." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetTypeface(fileHandle, ___4042, typeface); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextGetZone(void* fileHandle, int32_t ___4042, int32_t* zone) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextGetZone. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(zone)) std::cerr << "Invalid 'zone' parameter to tecTextGetZone. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextGetZone(fileHandle, ___4042, zone); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextIsAttached(void* fileHandle, int32_t ___4042, int32_t* ___2004) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextIsAttached. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(___2004)) std::cerr << "Invalid 'isAttached' parameter to tecTextIsAttached. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextIsAttached(fileHandle, ___4042, ___2004); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextIsBold(void* fileHandle, int32_t ___4042, int32_t* isBold) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextIsBold. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl;
else if (!VALID_REF(isBold)) std::cerr << "Invalid 'isBold' parameter to tecTextIsBold. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextIsBold(fileHandle, ___4042, isBold); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecTextIsItalic(void* fileHandle, int32_t ___4042, int32_t* isItalic) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4042 < 0 || numTexts(fileHandle) < ___4042) std::cerr << "Invalid 'text' parameter to tecTextIsItalic. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; else if (!VALID_REF(isItalic)) std::cerr << "Invalid 'isItalic' parameter to tecTextIsItalic. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_TextIsItalic(fileHandle, ___4042, isItalic); else ___478(!"Not implemented for .plt files"); return -1; } namespace { int32_t numVarAuxDataItems(void* fileHandle, int32_t ___4336) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(___4336 > 0); int32_t ___2812; if (tecVarAuxDataGetNumItems(fileHandle, ___4336, &___2812) == 0) return ___2812; return 0; } } int32_t tecVarAuxDataGetItem(void* fileHandle, int32_t ___4336, int32_t whichItem, char** ___2685, char** ___4314) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4336 <= 0 || ___2843(fileHandle) < ___4336) std::cerr << "Invalid 'var' parameter to tecVarAuxDataGetItem. Must be 0 < var <= numVars." << std::endl; else if (whichItem < 0 || numVarAuxDataItems(fileHandle, ___4336) < whichItem) std::cerr << "Invalid 'whichItem' parameter to tecVarAuxDataGetItem. Must be 0 < whichItem <= numItems (" << numVarAuxDataItems(fileHandle, ___4336) << ")." << std::endl; else if (!VALID_REF(___2685) || *___2685 != NULL) std::cerr << "Invalid 'name' parameter to tecVarAuxDataGetItem. Must be a valid reference and point to NULL." << std::endl; else if (!VALID_REF(___4314) || *___4314 != NULL) std::cerr << "Invalid 'value' parameter to tecVarAuxDataGetItem. Must be a valid reference and point to NULL." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_VarAuxDataGetItem(fileHandle, whichItem, ___4336, ___2685, ___4314); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecVarAuxDataGetNumItems(void* fileHandle, int32_t ___4336, int32_t* ___2812) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4336 <= 0 || ___2843(fileHandle) < ___4336) std::cerr << "Invalid 'var' parameter to tecVarAuxDataGetNumItems. Must be 0 < var <= numVars." << std::endl; else if (!VALID_REF(___2812)) std::cerr << "Invalid 'numItems' parameter to tecVarAuxDataGetNumItems. Must be a valid reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_VarAuxDataGetNumItems(fileHandle, ___4336, ___2812); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecVarGetName(void* fileHandle, int32_t ___4336, char** ___2685) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4336 <= 0 || ___2843(fileHandle) < ___4336) std::cerr << "Invalid 'var' parameter to tecVarGetName. Must be 0 < var <= numVars." << std::endl; else if (!VALID_REF(___2685) || *___2685 != NULL) std::cerr << "Invalid 'name' parameter to tecVarGetName. Must be a valid reference and point to NULL." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_VarGetName(fileHandle, ___4336, ___2685); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecVarIsEnabled(void* fileHandle, int32_t ___4336, int32_t* isEnabled) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4336 <= 0 || ___2843(fileHandle) < ___4336) std::cerr << "Invalid 'var' parameter to tecVarIsEnabled. Must be 0 < var <= numVars." << std::endl; else if (!VALID_REF(isEnabled)) std::cerr << "Invalid 'isEnabled' parameter to tecVarIsEnabled. Must be a valid reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_VarIsEnabled(fileHandle, ___4336, isEnabled); else ___478(!"Not implemented for .plt files"); return -1; } namespace { int32_t ___2846(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3358 = 0; if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) tecioSZL_DataSetGetNumZones(fileHandle, &___3358); else ___478(!"Not implemented for .plt files"); return ___3358; } } namespace { int32_t numZoneAuxDataItems(void* fileHandle, int32_t zone) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(0 < zone && zone <= ___2846(fileHandle)); int32_t ___3358 = 0; if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) tecioSZL_ZoneAuxDataGetNumItems(fileHandle, zone, &___3358); else ___478(!"Not implemented for .plt files"); return ___3358; } } int32_t tecZoneAuxDataGetItem(void* fileHandle, int32_t zone, int32_t whichItem, char** ___2685, char** ___4314) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneAuxDataGetItem. Must be 0 < zone <= numZones." << std::endl;
else if (whichItem <= 0 || numZoneAuxDataItems(fileHandle, zone) < whichItem) std::cerr << "Invalid 'whichItem' parameter to tecZoneAuxDataGetItem. Must be 0 < whichItem <= numItems." << std::endl; else if (!VALID_REF(___2685) || *___2685 != NULL) std::cerr << "Invalid 'name' parameter to tecZoneAuxDataGetItem. Must be a valid memory reference and point to NULL." << std::endl; else if (!VALID_REF(___4314) || *___4314 != NULL) std::cerr << "Invalid 'value' parameter to tecZoneAuxDataGetItem. Must be a valid memory reference and point to NULL." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneAuxDataGetItem(fileHandle, zone, whichItem, ___2685, ___4314); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneAuxDataGetNumItems(void* fileHandle, int32_t zone, int32_t* ___2812) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneAuxDataGetNumItems. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(___2812)) std::cerr << "Invalid 'numItems' parameter to tecZoneAuxDataGetNumItems. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneAuxDataGetNumItems(fileHandle, zone, ___2812); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneConnectivityGetSharedZone(void* fileHandle, int32_t zone, int32_t* sharedZone) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneConnectivityGetSharedZone. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(sharedZone)) std::cerr << "Invalid 'sharedZone' parameter to tecZoneConnectivityGetSharedZone. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneConnectivityGetSharedZone(fileHandle, zone, sharedZone); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneFaceNbrGetConnections(void* fileHandle, int32_t zone, int32_t* connections) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrGetConnections. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(connections)) std::cerr << "Invalid 'connections' parameter to tecZoneFaceNbrGetConnections. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneFaceNbrGetConnections(fileHandle, zone, connections); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneFaceNbrGetConnections64(void* fileHandle, int32_t zone, int64_t* connections) { ___4278(fileHandle); ___4278(zone); ___4278(connections); ___478(!"Not implemented"); return -1; } int32_t tecZoneFaceNbrGetMode(void* fileHandle, int32_t zone, int32_t* ___2504) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrGetMode. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(___2504)) std::cerr << "Invalid 'mode' parameter to tecZoneFaceNbrGetMode. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneFaceNbrGetMode(fileHandle, zone, ___2504); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneFaceNbrGetNumConnections(void* fileHandle, int32_t zone, int64_t* numConnections) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrGetNumConnections. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(numConnections)) std::cerr << "Invalid 'numConnections' parameter to tecZoneFaceNbrGetNumConnections. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneFaceNbrGetNumConnections(fileHandle, zone, numConnections); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneFaceNbrGetNumValues(void* fileHandle, int32_t zone, int64_t* numValues) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrGetNumValues. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(numValues)) std::cerr << "Invalid 'numValues' parameter to tecZoneFaceNbrGetNumValues. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneFaceNbrGetNumValues(fileHandle, zone, numValues); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneFaceNbrsAre64Bit(void* fileHandle, int32_t zone, int32_t* are64Bit) { if (!validFileHandle(fileHandle, FUNCTION_NAME))
return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrsAre64Bit. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(are64Bit)) std::cerr << "Invalid 'are64Bit' parameter to tecZoneFaceNbrsAre64Bit. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneFaceNbrsAre64Bit(fileHandle, zone, are64Bit); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneGetIJK(void* fileHandle, int32_t zone, int64_t* iMax, int64_t* jMax, int64_t* kMax) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneGetIJK. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(iMax)) std::cerr << "Invalid 'iMax' parameter to tecZoneGetIJK. Must be a valid memory reference." << std::endl; else if (!VALID_REF(jMax)) std::cerr << "Invalid 'jMax' parameter to tecZoneGetIJK. Must be a valid memory reference." << std::endl; else if (!VALID_REF(kMax)) std::cerr << "Invalid 'kMax' parameter to tecZoneGetIJK. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneGetIJK(fileHandle, zone, iMax, jMax, kMax); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneGetParentZone(void* fileHandle, int32_t zone, int32_t* ___2974) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneGetParentZone. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(___2974)) std::cerr << "Invalid 'parentZone' parameter to tecZoneGetParentZone. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneGetParentZone(fileHandle, zone, ___2974); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneGetSolutionTime(void* fileHandle, int32_t zone, double* ___3640) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneGetSolutionTime. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(___3640)) std::cerr << "Invalid 'solutionTime' parameter to tecZoneGetSolutionTime. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneGetSolutionTime(fileHandle, zone, ___3640); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneGetStrandID(void* fileHandle, int32_t zone, int32_t* ___3785) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneGetStrandID. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(___3785)) std::cerr << "Invalid 'strandID' parameter to tecZoneGetStrandID. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneGetStrandID(fileHandle, zone, ___3785); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneGetTitle(void* fileHandle, int32_t zone, char** ___4177) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneGetTitle. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(___4177) || *___4177 != NULL) std::cerr << "Invalid 'title' parameter to tecZoneGetTitle. Must be a valid memory reference and point to NULL." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneGetTitle(fileHandle, zone, ___4177); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneGetType(void* fileHandle, int32_t zone, int32_t* type) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneGetType. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(type)) std::cerr << "Invalid 'type' parameter to tecZoneGetType. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneGetType(fileHandle, zone, type); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneIsEnabled(void* fileHandle, int32_t zone, int32_t* isEnabled) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneIsEnabled. Must be 0 < zone <= numZones." << std::endl; else if (!VALID_REF(isEnabled)) std::cerr << "Invalid 'isEnabled' parameter to tecZoneIsEnabled. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL)
return tecioSZL_ZoneIsEnabled(fileHandle, zone, isEnabled); else ___478(!"Not implemented for .plt files"); return -1; } namespace { bool zoneHasNodeMap(void* fileHandle, int32_t zone) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); int32_t type; tecZoneGetType(fileHandle, zone, &type); return (1 <= type && type <= 5); } int64_t zoneNumCells(void* fileHandle, int32_t zone) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0 && zoneHasNodeMap(fileHandle, zone)); int64_t iMax; int64_t jMax; int64_t kMax; if (tecZoneGetIJK(fileHandle, zone, &iMax, &jMax, &kMax) == 0) return jMax; else return 0; } int32_t nodeMapGetNumValues(void* fileHandle, int32_t zone, int64_t ___2781, int64_t* numValues) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0 && zoneHasNodeMap(fileHandle, zone)); int64_t iMax; int64_t jMax; int64_t kMax; if (tecZoneGetIJK(fileHandle, zone, &iMax, &jMax, &kMax) == 0) { *numValues = ___2781 * kMax; return 0; } return -1; } } int32_t tecZoneNodeMapGet(void* fileHandle, int32_t zone, int64_t startCell, int64_t ___2781, int32_t* ___2723) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneNodeMapGet. Must be 0 < zone <= numZones." << std::endl; else if (!zoneHasNodeMap(fileHandle, zone)) std::cerr << "Invalid 'zone' parameter to tecZoneNodeMapGetNumValues. Must be a line segment, triangular, quadrilateral, tetrahedral or brick zone." << std::endl; else if (startCell <= 0) std::cerr << "Invalid 'startCell' parameter to tecZoneNodeMapGet. Must be > 0." << std::endl; else if (___2781 <= 0 || zoneNumCells(fileHandle, zone) < startCell + ___2781 - 1) std::cerr << "Invalid 'numCells' parameter to tecZoneNodeMapGet. Must be 0 < numCells <= zoneNumCells - startCell + 1." << std::endl; else if (!VALID_REF(___2723)) std::cerr << "Invalid 'nodeMap' parameter to tecZoneNodeMapGet. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneNodeMapGet(fileHandle, zone, startCell, ___2781, ___2723); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneNodeMapGet64(void* fileHandle, int32_t zone, int64_t startCell, int64_t ___2781, int64_t* ___2723) { ___4278(fileHandle); ___4278(zone); ___4278(startCell); ___4278(___2781); ___4278(___2723); ___478(!"Not implemented"); return 1; } int32_t tecZoneNodeMapGetNumValues(void* fileHandle, int32_t zone, int64_t ___2781, int64_t* numValues) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneNodeMapGetNumValues. Must be 0 < zone <= numZones." << std::endl; else if (!zoneHasNodeMap(fileHandle, zone)) std::cerr << "Invalid 'zone' parameter to tecZoneNodeMapGetNumValues. Must be a line segment, triangular, quadrilateral, tetrahedral or brick zone." << std::endl; else if (___2781 <= 0) std::cerr << "Invalid 'numCells' parameter to tecZoneNodeMapGetNumValues. Must be > 0." << std::endl; else if (!VALID_REF(numValues)) std::cerr << "Invalid 'numValues' parameter to tecZoneNodeMapGetNumValues. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return nodeMapGetNumValues(fileHandle, zone, ___2781, numValues); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneNodeMapIs64Bit(void* fileHandle, int32_t zone, int32_t* is64Bit) { ___4278(fileHandle); ___4278(zone); *is64Bit = 0; return 0; } int32_t tecZonePolyGetBoundaryConnectionCounts(void* fileHandle, int32_t zone, int64_t startConnection, int64_t numConnections, int32_t* connectionCounts) { ___4278(fileHandle); ___4278(zone); ___4278(startConnection); ___4278(numConnections); ___4278(connectionCounts); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetBoundaryConnections(void* fileHandle, int32_t zone, int64_t startConnection, int64_t numConnections, int32_t* connectedElements, int32_t* connectedZones) { ___4278(fileHandle); ___4278(zone); ___4278(startConnection); ___4278(numConnections); ___4278(connectedElements); ___4278(connectedZones); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetFaceElems(void* fileHandle, int32_t zone, int64_t startFace, int64_t numFaces, int32_t* leftElems, int32_t* rightElems) { ___4278(fileHandle); ___4278(zone); ___4278(startFace); ___4278(numFaces); ___4278(leftElems); ___4278(rightElems); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetFaceNodeCounts(void* fileHandle, int32_t zone, int64_t startFace, int64_t numFaces, int32_t* nodeCounts) { ___4278(fileHandle); ___4278(zone); ___4278(startFace); ___4278(numFaces); ___4278(nodeCounts); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetFaceNodes(void* fileHandle, int32_t zone, int64_t startFace, int64_t numFaces, int32_t* ___1296)
{ ___4278(fileHandle); ___4278(zone); ___4278(startFace); ___4278(numFaces); ___4278(___1296); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetNumConnectedBoundaryFaces(void* fileHandle, int32_t zone, int64_t* numFaces) { ___4278(fileHandle); ___4278(zone); ___4278(numFaces); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetTotalNumFaceNodes(void* fileHandle, int32_t zone, int64_t* ___2821) { ___4278(fileHandle); ___4278(zone); ___4278(___2821); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetTotalNumBoundaryConnections(void* fileHandle, int32_t zone, int64_t* numConnections) { ___4278(fileHandle); ___4278(zone); ___4278(numConnections); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } namespace { int32_t zoneVarGetNumValues(void* fileHandle, int32_t zone, int32_t ___4336, int64_t* numValues) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4336 > 0); REQUIRE(VALID_REF(numValues)); *numValues = 0; int32_t isPassive = 0; int32_t ___3358 = tecZoneVarIsPassive(fileHandle, zone, ___4336, &isPassive); if (___3358 == 0 && isPassive == 0) { int64_t iMax; int64_t jMax; int64_t kMax; ___3358 = tecZoneGetIJK(fileHandle, zone, &iMax, &jMax, &kMax); if (___3358 == 0) { int32_t ___4692; ___3358 = tecZoneGetType(fileHandle, zone, &___4692); if (___3358 == 0) { int64_t ___2821; int64_t ___2781; if (___4692 == 0) { ___2821 = iMax * jMax * kMax; ___2781 = std::max((int64_t)1, iMax - 1) * std::max((int64_t)1, jMax - 1) * std::max((int64_t)1, kMax - 1); } else { ___2821 = iMax; ___2781 = jMax; } int32_t ___4326; ___3358 = tecZoneVarGetValueLocation(fileHandle, zone, ___4336, &___4326); if (___3358 == 0) { if (___4326 == 0) *numValues = ___2781; else *numValues = ___2821; } } } } return ___3358; } int64_t zoneVarNumValues(void* fileHandle, int32_t zone, int32_t ___4336) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4336 > 0); int64_t numValues; zoneVarGetNumValues(fileHandle, zone, ___4336, &numValues); return numValues; } FieldDataType_e zoneVarType(void* fileHandle, int32_t zone, int32_t ___4336) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4336 > 0); int32_t type; tecZoneVarGetType(fileHandle, zone, ___4336, &type); return static_cast<FieldDataType_e>(type); } bool checkZoneVarGetValuesParameters(char const* routine, FieldDataType_e type, void* fileHandle, int32_t zone, int32_t ___4336, int64_t startIndex, int64_t numValues, void* values) { REQUIRE(VALID_REF(routine)); REQUIRE(VALID_ENUM(type, FieldDataType_e)); int32_t nZones = ___2846(fileHandle); int64_t nValues = zoneVarNumValues(fileHandle, zone, ___4336); FieldDataType_e actualType = zoneVarType(fileHandle, zone, ___4336); boost::unordered_map<FieldDataType_e, char const*> varTypeNames = boost::assign::map_list_of (FieldDataType_Float, "float") (FieldDataType_Double, "double") (FieldDataType_Int32, "int32_t") (FieldDataType_Int16, "int16_t") (FieldDataType_Byte, "uint8_t") (___1365, "bit"); if (!validFileHandle(fileHandle, routine)) return false; else if (zone <= 0 || nZones < zone) std::cerr << "Invalid 'zone' parameter to " << routine << ". Must be 0 < zone <= " << nZones << "." << std::endl; else if (___4336 <= 0 || ___2843(fileHandle) < ___4336) std::cerr << "Invalid 'var' parameter to " << routine << ". Must be 0 < var <= " << ___2843(fileHandle) << "." << std::endl; else if (actualType != type) std::cerr << routine << " called for non-" << varTypeNames[type] << " variable. Variable " << ___4336 << " of zone " << zone << " is of type " << varTypeNames[actualType] << "." << std::endl; else if (startIndex <= 0 || nValues < startIndex) std::cerr << "Invalid 'startIndex' parameter to " << routine << " for zone " << zone << ", var " << ___4336 << ". Must be 0 < startIndex <= numVarValues (" << nValues << ")." << std::endl; else if (numValues <= 0 || nValues - startIndex + 1 < numValues) std::cerr << "Invalid 'numValues' parameter to " << routine << " for zone " << zone << ", var " << ___4336 << ". Must be 0 < numValues <= numVarValues - startIndex + 1 (" << nValues - startIndex + 1 << ")." << std::endl; else if (!VALID_REF(values)) std::cerr << "Invalid 'values' parameter to " << routine << ". Must be a valid memory reference." << std::endl; else return true; return false; } } int32_t tecZoneVarGetDoubleValues(void* fileHandle, int32_t zone, int32_t ___4336, int64_t startIndex, int64_t numValues, double* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetDoubleValues", FieldDataType_Double, fileHandle, zone, ___4336, startIndex, numValues, values)) return -1; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneVarGetDoubleValues(fileHandle, zone, ___4336, startIndex, numValues, values); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneVarGetFloatValues(void* fileHandle, int32_t zone, int32_t ___4336, int64_t startIndex, int64_t numValues, float* values)
{ if (!checkZoneVarGetValuesParameters("tecZoneVarGetFloatValues", FieldDataType_Float, fileHandle, zone, ___4336, startIndex, numValues, values)) return -1; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneVarGetFloatValues(fileHandle, zone, ___4336, startIndex, numValues, values); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneVarGetInt16Values(void* fileHandle, int32_t zone, int32_t ___4336, int64_t startIndex, int64_t numValues, int16_t* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetInt16Values", FieldDataType_Int16, fileHandle, zone, ___4336, startIndex, numValues, values)) return -1; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneVarGetInt16Values(fileHandle, zone, ___4336, startIndex, numValues, values); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneVarGetInt32Values(void* fileHandle, int32_t zone, int32_t ___4336, int64_t startIndex, int64_t numValues, int32_t* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetInt32Values", FieldDataType_Int32, fileHandle, zone, ___4336, startIndex, numValues, values)) return -1; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneVarGetInt32Values(fileHandle, zone, ___4336, startIndex, numValues, values); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneVarGetNumValues(void* fileHandle, int32_t zone, int32_t ___4336, int64_t* numValues) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneVarGetNumValues. Must be 0 < zone <= numZones." << std::endl; else if (___4336 <= 0 || ___2843(fileHandle) < ___4336) std::cerr << "Invalid 'var' parameter to tecZoneVarGetNumValues. Must be 0 < var <= numVars." << std::endl; else if (!VALID_REF(numValues)) std::cerr << "Invalid 'numValues' parameter to tecZoneVarGetNumValues. Must be a valid memory reference." << std::endl; else return zoneVarGetNumValues(fileHandle, zone, ___4336, numValues); return -1; } int32_t tecZoneVarGetSharedZone(void* fileHandle, int32_t zone, int32_t ___4336, int32_t* sharedZone) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneVarGetSharedZone. Must be 0 < zone <= numZones." << std::endl; else if (___4336 <= 0 || ___2843(fileHandle) < ___4336) std::cerr << "Invalid 'var' parameter to tecZoneVarGetSharedZone. Must be 0 < var <= numVars." << std::endl; else if (!VALID_REF(sharedZone)) std::cerr << "Invalid 'sharedZone' parameter to tecZoneVarGetSharedZone. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneVarGetSharedZone(fileHandle, zone, ___4336, sharedZone); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneVarGetType(void* fileHandle, int32_t zone, int32_t ___4336, int32_t* type) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneVarGetType. Must be 0 < zone <= numZones." << std::endl; else if (___4336 <= 0 || ___2843(fileHandle) < ___4336) std::cerr << "Invalid 'var' parameter to tecZoneVarGetType. Must be 0 < var <= numVars." << std::endl; else if (!VALID_REF(type)) std::cerr << "Invalid 'type' parameter to tecZoneVarGetType. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneVarGetType(fileHandle, zone, ___4336, type); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneVarGetUInt8Values(void* fileHandle, int32_t zone, int32_t ___4336, int64_t startIndex, int64_t numValues, uint8_t* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetUInt8Values", FieldDataType_Byte, fileHandle, zone, ___4336, startIndex, numValues, values)) return -1; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneVarGetUInt8Values(fileHandle, zone, ___4336, startIndex, numValues, values); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneVarGetValueLocation(void* fileHandle, int32_t zone, int32_t ___4336, int32_t* location) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneVarGetValueLocation. Must be 0 < zone <= numZones." << std::endl; else if (___4336 <= 0 || ___2843(fileHandle) < ___4336) std::cerr << "Invalid 'var' parameter to tecZoneVarGetValueLocation. Must be 0 < var <= numVars." << std::endl; else if (!VALID_REF(location)) std::cerr << "Invalid 'location' parameter to tecZoneVarGetValueLocation. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneVarGetValueLocation(fileHandle, zone, ___4336, location); else ___478(!"Not implemented for .plt files"); return -1; } int32_t tecZoneVarIsPassive(void* fileHandle, int32_t zone, int32_t ___4336, int32_t* isPassive)
{ if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2846(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneVarIsPassive. Must be 0 < zone <= numZones." << std::endl; else if (___4336 <= 0 || ___2843(fileHandle) < ___4336) std::cerr << "Invalid 'var' parameter to tecZoneVarIsPassive. Must be 0 < var <= numVars." << std::endl; else if (!VALID_REF(isPassive)) std::cerr << "Invalid 'isPassive' parameter to tecZoneVarIsPassive. Must be a valid memory reference." << std::endl; else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) return tecioSZL_ZoneVarIsPassive(fileHandle, zone, ___4336, isPassive); else ___478(!"Not implemented for .plt files"); return -1; }
