#include "stdafx.h"
#include "MASTER.h"
#include "ThirdPartyHeadersBegin.h"
#include <memory>
#include "ThirdPartyHeadersEnd.h"
 #define ___856
#include "GLOBAL.h"
#include "TASSERT.h"
#include "ALLOC.h"
#include "AUXDATA.h"
#include "DATASET.h"
#include "FILESTREAM.h"
#include "TecplotVersion.h"
#include "FileSystem.h"
#include "GEOM2.h"
#include "GEOM.h"
#include "INPUT.h"
#include "SET.h"
#include "TEXT.h"
#include "DATAIO4.h"
#include "DATASET0.h"
#include "CHARTYPE.h"
#include "STRUTIL.h"
#include "ARRLIST.h"
#include "STRLIST.h"
#include "Q_MSG.h"
 #if defined ___1994
#include <ieeefp.h>
 #endif
using namespace tecplot;
 #if defined MSWIN
 #if !defined TECPLOTKERNEL
 #pragma warning(disable : 4244)
 #endif
 #pragma warning(disable: 4789)
 #endif
 #if defined DECALPHA || defined ___534
 #define _IEEE_FP_INEXACT
 #define _IEEE_FP
 #endif
 #if defined SUN41
 #define SEEK_SET 0
 #define SEEK_CUR 1
 #define SEEK_END 2
 #endif
static char FilterFloatChar(float X) { char C; if (((X >= 32.0) && (X <= 127.0)) || ((X >= 160.0) && (X <= 255.0)) || (X == 0.0)) C = (char)X; else C = '?'; return (C); } double ___1762(___1405   *___1401, FieldDataType_e ___1364, double          VMin, double          VMax, ___372      *___2040) { double X = 0.0; REQUIRE(VALID_REF(___2040) && VALID_BOOLEAN(*___2040)); REQUIRE(!(*___2040) || VALID_FIELD_DATA_TYPE(___1364)); REQUIRE(!(*___2040) || VALID_REF(___1401)); if (*___2040) { switch (___1364) { case FieldDataType_Float : { float XX; *___2040 = (___4198(&XX, 4, 1, ___1401->File) == 1); if (!___1401->___2007) ___3367(&XX); if (*___2040) X = XX; else X = 0.0; } break; case FieldDataType_Double : { double XX; *___2040 = (___4198(&XX, sizeof(double), 1, ___1401->File) == 1); if (!___1401->___2007) ___3370(&XX); if (*___2040) X = XX; else X = 0.0; } break; case FieldDataType_Int32  : { int32_t ___2165; *___2040 = (___4198(&___2165, sizeof(int32_t), 1, ___1401->File) == 1); if (!___1401->___2007) ___3367(&___2165); if (*___2040) X = (double)___2165; } break; case FieldDataType_Int16  : { int16_t S; *___2040 = (___4198(&S, sizeof(int16_t), 1, ___1401->File) == 1); if (!___1401->___2007) ___3364(&S); if (*___2040) X = (double)S; } break; case FieldDataType_Byte  : { uint8_t B; *___2040 = (___4198(&B, sizeof(uint8_t), 1, ___1401->File) == 1); if (*___2040) X = (double)B; } break; case ___1365 : { uint8_t B; *___2040 = (___4198(&B, sizeof(uint8_t), 1, ___1401->File) == 1); if (*___2040) X = (double)(B & (uint8_t)01); } break; default: ___478(___1305); break; } if (*___2040) { if ((X < VMin) || (X > VMax)) { *___2040 = ___1305; } } } return X; } template <typename SRC_INT_TYPE> ___2227 ___1750( ___1405* ___1400, short         pltFileVersion, ___2227     minValue, ___2227     maxValue, ___372*    ___2039) { REQUIRE(VALID_REF(___2039) && VALID_BOOLEAN(*___2039)); REQUIRE(!(*___2039) || (0 < pltFileVersion && pltFileVersion <= TecplotSDKBinaryFileVersion)); REQUIRE(!(*___2039) || (VALID_REF(___1400) && VALID_REF(___1400->File))); REQUIRE(!(*___2039) || minValue <= maxValue); SRC_INT_TYPE intValue = 0; if (*___2039) { if (pltFileVersion <= 63) { if (*___2039) { float X = (float)___1762(___1400, FieldDataType_Float, (double)minValue - 1.0e-10, (double)maxValue + 1.0e-10, ___2039); if (*___2039) { if (___1(X) < (float)___2182) intValue = (SRC_INT_TYPE)X; else *___2039 = ___1305; } else *___2039 = ___1305; } } else { *___2039 = (___4198(&intValue, sizeof(intValue), 1, ___1400->File) == 1); if (*___2039 && !___1400->___2007) { if (sizeof(intValue) == 2) ___3364(&intValue); else if (sizeof(intValue) == 4) ___3367(&intValue); else if (sizeof(intValue) == 8) ___3370(&intValue); } } if (static_cast<___2227>(intValue) < minValue || maxValue < static_cast<___2227>(intValue)) *___2039 = ___1305; } return intValue; } template ___2227 ___1750<int32_t>(___1405*, short, ___2227, ___2227, ___372*); template ___2227 ___1750<int64_t>(___1405*, short, ___2227, ___2227, ___372*); static ___372 ReallocString(char      **___3813, size_t    NewLength) { ___372 ___2040; char *___2700; REQUIRE(VALID_REF(___3813)); REQUIRE(*___3813 == NULL || VALID_REF(*___3813)); REQUIRE((*___3813 != NULL && NewLength >= strlen(*___3813)) || (*___3813 == NULL && NewLength >= 0)); ___2700 = ___23(NewLength + 1, char, "reallocated string"); ___2040 = (___2700 != NULL); if (___2040) { if (*___3813 == NULL) { ___2700[0] = '\0'; } else { strcpy(___2700, *___3813); ___1530(*___3813, "old string"); } *___3813 = ___2700; } ENSURE(VALID_BOOLEAN(___2040)); ENSURE(IMPLICATION(___2040, VALID_REF(*___3813))); return ___2040; } namespace { ___372 ___3289(___1405  *___1401, short          ___2104, int            ___2351, char         **TargetStr, ___372      ___3203) { ___372 ___2040 = ___4226; REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(0 < ___2104 && ___2104 <= TecplotSDKBinaryFileVersion); REQUIRE(IMPLICATION(___2104 < 63 || ___3203, ___2351 >= 0)); REQUIRE(IMPLICATION(___3203, VALID_REF(TargetStr))); REQUIRE(VALID_BOOLEAN(___3203)); if (___2104 < 63) { float X; if (___3203) { *TargetStr = ___23(___2351 + 1, char, "target string"); ___2040 = (*TargetStr != NULL); } if (___2040) { ___2227 ___1832; for (___1832 = 0; ___2040 && ___1832 < ___2351; ___1832++) { X = (float)___1762(___1401, FieldDataType_Float, 0.0, 127.0, &___2040); if (!___2040) break; if (___3203) (*TargetStr)[___1832] = FilterFloatChar(X); } if (___3203) (*TargetStr)[___1832] = '\0'; } else { ___1177(___4217("Cannot allocate memory for string during read", "'string' meaning the computer science data type")); } } else { size_t const MAX_STRBUFFER_LEN = 4095; static char  StrBuffer[MAX_STRBUFFER_LEN+1]; size_t       StrBufferLen = 0; size_t       TargetStrLen = 0; int          ___1832 = 0; ___2227    CharValue = 0; if (___3203)
*TargetStr = NULL; do { CharValue = ___1750<int32_t>(___1401, ___2104, 0, 255, &___2040); if (___2040 && ___3203) { if (CharValue != '\0' && (___1832 < ___2351 || ___2351 == 0)) { StrBuffer[StrBufferLen] = (char)CharValue; StrBufferLen++; } if (CharValue == '\0' || StrBufferLen == MAX_STRBUFFER_LEN) { if (StrBufferLen != 0 || *TargetStr == NULL) { StrBuffer[StrBufferLen] = '\0'; TargetStrLen += StrBufferLen; ___2040 = ReallocString(TargetStr, TargetStrLen); if (___2040) strcat(*TargetStr, StrBuffer); StrBufferLen = 0; } } } ___1832++; } while (___2040 && (char)CharValue != '\0'); if (!___2040       && ___3203 && *TargetStr != NULL) { ___1530(*TargetStr, "failed read string"); *TargetStr = NULL; } } ENSURE(IMPLICATION(___3203, (VALID_REF(*TargetStr) || *TargetStr == NULL))); ENSURE(VALID_BOOLEAN(___2040)); return (___2040); } } static void ReadDoubleBlock(___1405 *___1401, ___372     ___1099, double       *___417, ___2227     ___3685, ___2227     ___2842, ___372    *___2040) { if (___1099) { double *DPtr = ___417 + ___3685; *___2040 = (___4198(DPtr, sizeof(double), ___2842, ___1401->File) == (size_t)___2842); if (!___1401->___2007 && *___2040) { ___2227 N; for (N = 0; N < ___2842; N++) ___3370(&DPtr[N]); } } else *___2040 = (___4200(___1401->File, ___2842 * sizeof(double), SEEK_CUR) == 0); } static void ReadFloatBlock(___1405 *___1401, ___372     ___1099, float        *___417, ___2227     ___3685, ___2227     ___2842, ___372    *___2040) { if (___1099) { float *FPtr = ___417 + ___3685; *___2040 = (___4198(FPtr, sizeof(float), ___2842, ___1401->File) == (size_t)___2842); if (!___1401->___2007 && *___2040) { ___2227 N; for (N = 0; N < ___2842; N++) ___3367(&FPtr[N]); } } else *___2040 = (___4200(___1401->File, ___2842 * sizeof(float), SEEK_CUR) == 0); } static void ReadBitBlock(___1405 *___1401, ___372     ___1099, uint8_t       *___417, ___2227     ___2842, ___372    *___2040) { ___2227 NumBytes = (___2842 + 7) / 8; if (___1099) { *___2040 = (___4198(___417, sizeof(uint8_t), NumBytes, ___1401->File) == (size_t)NumBytes); } else *___2040 = (___4200(___1401->File, NumBytes * sizeof(uint8_t), SEEK_CUR) == 0); } void ___3277(___1405 *___1401, ___372     ___1099, uint8_t       *___417, ___2227     ___3685, ___2227     ___2842, ___372    *___2040) { if (___1099) { *___2040 = (___4198(___417 + ___3685, sizeof(uint8_t), ___2842, ___1401->File) == (size_t)___2842); } else *___2040 = (___4200(___1401->File, ___2842 * sizeof(uint8_t), SEEK_CUR) == 0); } void ___3290(___1405 *___1401, ___372     ___1099, int16_t      *___417, ___2227     ___3685, ___2227     ___2842, ___372    *___2040) { if (___1099) { int16_t *___1986 = ___417 + ___3685; *___2040 = (___4198(___1986, sizeof(int16_t), ___2842, ___1401->File) == (size_t)___2842); if (!___1401->___2007 && *___2040) { ___2227 N; for (N = 0; N < ___2842; N++) ___3364(&___1986[N]); } } else *___2040 = (___4200(___1401->File, ___2842 * sizeof(int16_t), SEEK_CUR) == 0); } void ___3291(___1405 *___1401, ___372     ___1099, int32_t      *___417, ___2227     ___3685, ___2227     ___2842, ___372    *___2040) { REQUIRE(VALID_REF(___1401)); REQUIRE(VALID_BOOLEAN(___1099)); REQUIRE(VALID_REF(___417)); REQUIRE(___3685 >= 0); REQUIRE(___2842 >= 0); REQUIRE(VALID_REF(___2040) && VALID_BOOLEAN(*___2040)); if (___1099) { ___2227 EndIndex = ___3685 + ___2842; for (___2227 ValueIndex = ___3685; *___2040 && ValueIndex < EndIndex; ValueIndex++) { int16_t ___4315; *___2040 = (___4198(&___4315, sizeof(int16_t), 1, ___1401->File) == 1); if (!___1401->___2007 && *___2040) ___3364(&___4315); ___417[ValueIndex] = (int32_t)___4315; } } else *___2040 = (___4200(___1401->File, ___2842 * sizeof(int16_t), SEEK_CUR) == 0); } void ___3292(___1405 *___1401, ___372     ___1099, int32_t      *___417, ___2227     ___3685, ___2227     ___2842, ___372    *___2040) { if (___1099) { int32_t *___1986 = ___417 + ___3685; *___2040 = (___4198(___1986, sizeof(int32_t), ___2842, ___1401->File) == (size_t)___2842); if (!___1401->___2007 && *___2040) { ___2227 N; for (N = 0; N < ___2842; N++) ___3367(&___1986[N]); } } else *___2040 = (___4200(___1401->File, ___2842 * sizeof(int32_t), SEEK_CUR) == 0); } void ReadInt64Block(___1405 *___1401, ___372     ___1099, int64_t      *___417, ___2227     ___3685, ___2227     ___2842, ___372    *___2040) { REQUIRE(VALID_REF(___1401)); REQUIRE(VALID_BOOLEAN(___1099)); REQUIRE(VALID_REF(___417)); REQUIRE(___3685 >= 0); REQUIRE(___2842 >= 1); REQUIRE(VALID_REF(___2040)); if (___1099) { int64_t *___1986 = ___417 + ___3685; *___2040 = (___4198(___1986, sizeof(int64_t), ___2842, ___1401->File) == (size_t)___2842); if (!___1401->___2007 && *___2040)
{ ___2227 N; for (N = 0; N < ___2842; N++) ___3370(&___1986[N]); } } else *___2040 = (___4200(___1401->File, ___2842 * sizeof(int64_t), SEEK_CUR) == 0); ENSURE(VALID_BOOLEAN(*___2040)); } void ___3296(___1405   *___1401, ___372       ___1099, void           *___417, FieldDataType_e ___1364, ___2227       ___3685, ___2227       ___2842, ___372      *___2040) { REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(VALID_BOOLEAN(___1099)); REQUIRE(!___1099 || VALID_REF(___417)); REQUIRE(VALID_FIELD_DATA_TYPE(___1364)); REQUIRE(___3685 >= 0); REQUIRE(___2842 >= 0); REQUIRE(VALID_REF(___2040) && VALID_BOOLEAN(*___2040)); switch (___1364) { case FieldDataType_Float : { ReadFloatBlock(___1401, ___1099, (float *)___417, ___3685, ___2842, ___2040); } break; case FieldDataType_Double : { ReadDoubleBlock(___1401, ___1099, (double *)___417, ___3685, ___2842, ___2040); } break; case ___1365 : { if (___3685 != 0) { ___1177(___4217("Internal Error: Attempt to read bit data at non-zero offset", "see Tecplot User's manual for a definition of 'bit' data")); *___2040 = ___1305; } else ReadBitBlock(___1401, ___1099, (uint8_t *)___417, ___2842, ___2040); } break; case FieldDataType_Byte : { ___3277(___1401, ___1099, (uint8_t *)___417, ___3685, ___2842, ___2040); } break; case FieldDataType_Int16 : { ___3290(___1401, ___1099, (int16_t *)___417, ___3685, ___2842, ___2040); } break; case FieldDataType_Int32 : { ___3292(___1401, ___1099, (int32_t *)___417, ___3685, ___2842, ___2040); } break; case ___1366 : case ___1368 : default: ___478(___1305); break; } ENSURE(VALID_BOOLEAN(*___2040)); } void ___3276(___1405   *___1401, ___1361    ___1352, ___372       ___1099, FieldDataType_e ___1367, ___2227       ___3685, ___2227       EndIndex, ___372      *___2040) { REQUIRE(VALID_REF(___2040) && VALID_BOOLEAN(*___2040)); REQUIRE(IMPLICATION(___2040, VALID_REF(___1401))); REQUIRE(IMPLICATION(___2040, VALID_FIELD_DATA_TYPE(___1367))); REQUIRE(VALID_BOOLEAN(___1099)); REQUIRE(IMPLICATION(___1099, VALID_REF(___1352))); ___372 ReadByBlock = IMPLICATION(___1099, ___1726(___1352) == ___1367); REQUIRE(ReadByBlock || (___1367 != ___1365)); if (*___2040) { ___2227 ___2842 = EndIndex - ___3685 + 1; if (ReadByBlock) { void *data_array; if (___1099) data_array = ___1732(___1352); else data_array = NULL; ___3296(___1401, ___1099, data_array, ___1367, ___3685, ___2842, ___2040); } else { ___2227 N; for (N = 0; *___2040 && (N < ___2842); N++) { double D = ___1762(___1401, ___1367, -___2179, ___2179, ___2040); if (___1099) ___3490(___1352, N + ___3685, D); } } } } void ___3278(___1405         *___843, ___1361          ___1352, FieldDataType_e       ___1367, ___2227             ___2810, ___2227             ___2815, ___2227             ___2818, ___372            *___2040) { REQUIRE(IMPLICATION(*___2040, VALID_REF(___843))); REQUIRE(IMPLICATION(*___2040, VALID_FIELD_DATA_TYPE(___1367))); REQUIRE(VALID_REF(___1352)); REQUIRE(___2810 >= 0); REQUIRE(___2815 >= 0); REQUIRE(___2818 >= 0); REQUIRE(VALID_REF(___2040) && VALID_BOOLEAN(*___2040)); if (*___2040) { ___2227 ___2106, ___2135; ___2227 ___2807  = ___2810 * ___2815; ___2227 ___1839      = MAX(___2810 - 1, 1); ___2227 ___2111      = MAX(___2815 - 1, 1); ___2227 ___2139      = MAX(___2818 - 1, 1); ___2227 ___2842 = (___1839 * ___2111 * ___2139); ___372 IsLinear  = ((___2815 == 1 && ___2818 == 1) || (___2810 == 1 && ___2818 == 1) || (___2810 == 1 && ___2815 == 1)); if (IsLinear) ___3276(___843, ___1352, ___4226, ___1367, 0, ___2842 - 1, ___2040); else for (___2135 = 0; ___2135 < ___2139 && ___2040; ___2135++) for (___2106 = 0; ___2106 < ___2111 && ___2040; ___2106++) { ___2227 ___463 = 0 + (___2106 * ___2810) + (___2135 * ___2807); ___3276(___843, ___1352, ___4226, ___1367, ___463, ___463 + ___1839 - 1, ___2040); } } ENSURE(VALID_BOOLEAN(*___2040)); } static void AdjustCustomColor(short         ___2104, ___516 *___351) { REQUIRE(0 < ___2104 && ___2104 <= TecplotSDKBinaryFileVersion); REQUIRE(VALID_REF(___351)); if ((___2104 < 70) && (*___351 >= 15) && (*___351 <= 22)) *___351 -= 7; } ___372 ___3287(___1405   *___1401, short           ___2104, char          **___903, DataFileType_e *___1408, int            *NumVars, ___3839  *___4366) { ___1172   ___718; ___372    ___2040 = ___4226; REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(0 < ___2104 && ___2104 <= TecplotSDKBinaryFileVersion); REQUIRE(VALID_REF(___903) || (___903 == NULL)); REQUIRE(VALID_REF(___1408) || (___1408 == NULL));
REQUIRE(VALID_REF(NumVars)); REQUIRE(VALID_REF(___4366) || (___4366 == NULL)); *NumVars      = 0; if (___903) *___903 = NULL; if (___2104 >= 109) { if (___1408) *___1408 = (DataFileType_e)___1750<int32_t>(___1401, ___2104, 0, ___848, &___2040); else ___1750<int32_t>(___1401, ___2104, 0, ___848, &___2040); } if (___3289(___1401, ___2104, ((___2104 < 63) ? 80 : ___2355), ___903, (___372)(___903 != NULL))) { if (___903) ___4225(*___903); *NumVars = ___1750<int32_t>(___1401, ___2104, 0, ___2391, &___2040); } else ___2040 = ___1305; if (___2040 && (*NumVars > ___2382)) { ___1177(___4217("Too many variables")); ___2040 = ___1305; } if (___2040 && ___4366) { if (*NumVars > 0) { *___4366 = ___3821(); ___2040 = (*___4366 != NULL); if (___2040) ___2040 = ___3843(*___4366, *NumVars - 1, NULL); if (!___2040) { if (*___4366 != NULL) ___3828(___4366); ___1177(___4217("Out of space while allocating var names")); } } } for (___718 = 0; ___2040 && (___718 < *NumVars); ___718++) { char *VName = NULL; ___2040 = ___3289(___1401, ___2104, ((___2104 < 63) ? 5 : ___2356), ___4366 ? &VName : NULL, (___372)(___4366 != NULL)); if (___2040 && ___4366) { if (VName == NULL) { VName = ___23(1, char, "empty variable name"); strcpy(VName, ""); } ___4225(VName); ___2040 = ___3353(&VName); ___2040 = ___2040 && ___3843(*___4366, ___718, VName); if (VName != NULL) ___1530(VName, "variable name"); } if (!___2040) { if (___4366 && *___4366) ___3828(___4366); ___1177(___4217("Out of space while allocating variable names")); } } ENSURE(VALID_BOOLEAN(___2040)); return (___2040); } static ___372 ReadInPresetZoneColor(___1405 *___1401, short         ___2104, ___4683   *___4677) { ___372 ___2040 = ___4226; ___2227 ZoneColor; REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(0 < ___2104 && ___2104 <= TecplotSDKBinaryFileVersion); REQUIRE(VALID_REF(___4677)); ZoneColor = ___1750<int32_t>(___1401, ___2104, -1, ___2195, &___2040); if (___2040) { if (VALID_BASIC_COLOR(ZoneColor)) { ___4677->___4647.___3174 = (___1172)ZoneColor; AdjustCustomColor(___2104, &___4677->___4647.___3174); } else if (ZoneColor != -1) ___2040 = ___1305; } ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } static void ConvertCommonTimeToSolutionTime(___4683 *___4677) { REQUIRE(VALID_REF(___4677)); REQUIRE(___4677->___230 == NULL || VALID_REF(___4677->___230)); int32_t ___2096; if (___4677->___230 != NULL && ___246(___4677->___230, AuxData_Common_Time, &___2096)) { const char    *SameName; ___90     ___4315; AuxDataType_e  ___4236; ___372      ___3362; ___244(___4677->___230, ___2096, &SameName, &___4315, &___4236, &___3362); ___478(ustrcmp(AuxData_Common_Time, SameName) == 0); ___478(___4236 == ___270); char *EndPtr = NULL; double ___3641 = strtod((const char *)___4315, &EndPtr); if (EndPtr != (char *)___4315) { while (tecplot::isspace(*EndPtr)) EndPtr++; } if (EndPtr != (char *)___4315 && *EndPtr == '\0') { ___4677->___3641 = ___3641; ___4677->___3786     = ___3787; ___237(___4677->___230, ___2096); } } } ___372 ___3295(___1405 *___1401, short         ___2104, ___4683   *___4677, ___3501        ___2075, ___1172    NumVars, ___90    ___263, ___372    *___2053, ___2227    *___1441) { ___1172 ___4337; ___372  ___2040 = ___4226; ___2227  I1; REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(0 < ___2104 && ___2104 <= TecplotSDKBinaryFileVersion); REQUIRE(VALID_REF(___4677)); REQUIRE(___2075 == NULL || VALID_REF(___2075)); REQUIRE(NumVars >= 0); REQUIRE(VALID_REF(___2053)); REQUIRE(VALID_REF(___1441)); ___3541(___4677); if (___2075 != NULL) { ___493(___2075); ___2040 = ___1201(___2075, NumVars, ___1305); } if (___2040) ___2040 = ___3289(___1401, ___2104, ((___2104 < 63) ? 10 : ___2358), &___4677->___2686, ___4226); if (___2040 && ___4677->___2686 == NULL) { ___4677->___2686 = ___23(1, char, "empty zone name"); ___2040 = (___4677->___2686 != NULL); if (___2040) strcpy(___4677->___2686, ""); } if (___2040) ___4225(___4677->___2686); if (___2104 < 101) { ___372    IsZoneFinite; DataFormat_e ZoneDataFormat; I1 = ___1750<int32_t>(___1401, ___2104, 0, 3, &___2040); if ((I1 < 0) || (I1 > 3)) { return (___1305); } ZoneDataFormat = (DataFormat_e)I1; IsZoneFinite = (ZoneDataFormat == ___852 || ZoneDataFormat == ___851); ___4677->___4647.___2027 = (ZoneDataFormat == ___853 || ZoneDataFormat == ___851); if (___2104 > 62) ___2040 = ReadInPresetZoneColor(___1401, ___2104, ___4677);
if (___2104 < 60) ___1762(___1401, FieldDataType_Float, -___2179, ___2179, &___2040); if (___2040) { ___4677->___2830 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); ___4677->___2831 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); if (___2104 >= 60) ___4677->___2832 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); else ___4677->___2832 = 1; } if (___2040) { if (!((___4677->___2830 == 0) && (___4677->___2831 == 0) && (___4677->___2832 == 0)) && ((___4677->___2830 <= 0) || (___4677->___2831 <= 0) || (___4677->___2832 < 0)  || ((!IsZoneFinite && (___4677->___2832 == 0))))) { ___1177(___4217("Datafile is corrupted")); ___2040 = ___1305; } if (IsZoneFinite) { if (___2104 >= 61) { ___4677->___4236 = (ZoneType_e)(___4677->___2832 + 1); switch (___4677->___4236) { case ___4702: ___4677->___2832 = 3; break; case ___4700:     ___4677->___2832 = 4; break; case ___4701:    ___4677->___2832 = 4; break; case ___4695:    ___4677->___2832 = 8; break; case ___4696:  ___4677->___2832 = 2; break; default: { ___1177(___4217("Datafile corrupted: Invalid element type for FE DataSet")); ___2040 = ___1305; } } } else { ___4677->___4236 = ___4700; ___4677->___2832 = 4; } } else { ___4677->___4236 = ___4704; ___4677->___1834 = ___4677->___2830 - 1; ___4677->___2107 = ___4677->___2831 - 1; ___4677->___2136 = ___4677->___2832 - 1; } } *___2053 = ___1305; *___1441  = 0; } else { if (___2040 && (___2104 >= 107)) { ___4677->___2975 = ___1750<int32_t>(___1401, ___2104, -1, ___2391 - 1, &___2040); if (!___2040) ___1177(___4217("Invalid datafile: parent zone assignment must be to an existing zone within the same datafile.")); } if (___2040 && (___2104 >= 106)) { ___4677->___3786     = ___1750<int32_t>(___1401, ___2104, -2, ___2391 - 1, &___2040); ___4677->___3641 = ___1762(___1401, FieldDataType_Double, -___2179, ___2179, &___2040); if (!___2040) ___1177(___4217("Invalid datafile: bad StrandID or SolutionTime")); } ___2040 = ___2040 && ReadInPresetZoneColor(___1401, ___2104, ___4677); I1 = (ZoneType_e)___1750<int32_t>(___1401, ___2104, 0, 7, &___2040); switch (I1) { case 0: ___4677->___4236 = ___4704;      break; case 1: ___4677->___4236 = ___4696;    break; case 2: ___4677->___4236 = ___4702;   break; case 3: ___4677->___4236 = ___4700;       break; case 4: ___4677->___4236 = ___4701;      break; case 5: ___4677->___4236 = ___4695;      break; case 6: ___4677->___4236 = ___4698;    break; case 7: ___4677->___4236 = ___4699; break; default: { ___1177(___4217("Invalid datafile: unknown zone type.")); ___2040 = ___1305; } break; } if (___2104 < 112) ___4677->___4647.___2027 = ((DataPacking_e)___1750<int32_t>(___1401, ___2104, 0, 1, &___2040) == ___874); else ___4677->___4647.___2027 = ___4226; if ((___372)___1750<int32_t>(___1401, ___2104, 0, 1, &___2040) && ___2040) { for (___4337 = 0; ___4337 < NumVars && ___2040; ___4337++) { if ((___372)___1750<int32_t>(___1401, ___2104, 0, 1, &___2040) && ___2040 && ___2075 != NULL) { ___2040 = (___4677->___4647.___2027); if (___2040) ___2040 = ___17(___2075, ___4337, ___1305); else ___1177(___4217("Invalid datafile: cell centered " "variable must be in block format.", "See the Tecplot User's Manual for a definition of 'block format'")); } } } if (___2104 >= 108 && ___2040) { *___2053 = ___1750<int32_t>(___1401, ___2104, 0, 1, &___2040); if (*___2053 && (___4677->___4236 == ___4704 || ___4677->___4236 == ___4696)) { ___2040 = ___1305; ___1177(___4217("Invalid datafile: raw face neighbors may not be " "supplied for ordered or FE line segment zones.")); } } else *___2053 = ___1305; ___4677->___228 = !(*___2053); *___1441 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); if (*___1441 != 0) ___4677->___1440 = (FaceNeighborMode_e)___1750<int32_t>(___1401, ___2104, 0, 3, &___2040); if (___2104 >= 108 && ___2040) { ___372 FaceNeighborsComplete = ___1305; if (*___1441 != 0 && ___4677->___4236 != ___4704) FaceNeighborsComplete = (___372)___1750<int32_t>(___1401, ___2104, 0, 1, &___2040); if (FaceNeighborsComplete) ___4677->___228 = ___1305; } if (___4677->___4236 == ___4704) { ___4677->___2830 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); ___4677->___2831 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); ___4677->___2832 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); if (___2040 && !(___4677->___2830 == 0 && ___4677->___2831 == 0 && ___4677->___2832 == 0)  && (___4677->___2830 == 0 || ___4677->___2831 == 0 || ___4677->___2832 == 0)) { ___1177(___4217("Invalid data file: incorrect specification of I, J, or K points for ordered data set."));
___2040 = ___1305; } } else { ___4677->___2830 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); if (___4677->___4236 == ___4698 || ___4677->___4236 == ___4699) { ___4677->___2832 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); if (___2104 >= 111) { ___4677->___2805      = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); ___4677->___2799 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); if (___4677->___2799 > 0) { ___478(___2104 <= 112 && ___4677->___2799 >= 2); ___4677->___2799 -= 1; } ___4677->___2800 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); } } else { switch (___4677->___4236) { case ___4702: ___4677->___2832 = 3; break; case ___4700:     ___4677->___2832 = 4; break; case ___4701:    ___4677->___2832 = 4; break; case ___4695:    ___4677->___2832 = 8; break; case ___4696:  ___4677->___2832 = 2; break; default : { ___1177(___4217("Invalid data file: invalid element type for FE data set.")); ___2040 = ___1305; } } } ___4677->___2831 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); ___4677->___1834 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); ___4677->___2107 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); ___4677->___2136 = ___1750<int32_t>(___1401, ___2104, 0, ___2182, &___2040); } for (I1 = ___1750<int32_t>(___1401, ___2104, 0, 1, &___2040); ___2040 && I1 != 0; I1 = ___1750<int32_t>(___1401, ___2104, 0, 1, &___2040)) { if (___4677->___230 == NULL) ___4677->___230 = ___231(___263); ___2040 = (___4677->___230 != NULL); if (___2040) ___2040 = ___3285(___1401, ___2104, ___4677->___230); } } if (___2104 < 106 && ___2040) ConvertCommonTimeToSolutionTime(___4677); ENSURE(VALID_BOOLEAN(___2040)); return (___2040); } ___372 ___3286(___1405  *___1401, short          ___2104, ___372      ___2868, ___3839 *___791) { ___2227 NumLabels; short     ___1832; ___372 ___2040 = ___4226; REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(___2104 > 0); REQUIRE(VALID_BOOLEAN(___2868)); REQUIRE(!(___2868) || VALID_REF(___791)); NumLabels = (short)___1750<int32_t>(___1401, ___2104, 0, ___2181, &___2040); if (___2040 && NumLabels != 0 && ___2868) { *___791 = ___3821(); ___2040 = (*___791 != NULL); if (!___2040) ___1177(___4217("Cannot allocate memory for Custom Labels.")); } for (___1832 = 0; ___2040 && (___1832 < NumLabels); ___1832++) { char *TLabel = NULL; ___2040 = ___3289(___1401, ___2104, 1024, &TLabel, ___2868); ___4225(TLabel); if (___2040 && ___2868) { ___2040 = ___3823(*___791, TLabel); if (TLabel != NULL) ___1530(TLabel, "custom label"); if (!___2040) ___1177(___4217("Cannot allocate memory for Custom Label.")); } } if (!___2040) ___1177(___4217("Invalid custom axis label record in binary datafile")); ENSURE(VALID_BOOLEAN(___2040)); ENSURE(!(___2040 && NumLabels != 0 && ___2868) || ___3848(*___791)); return ___2040; } ___372 ___3294( ___1405* ___1401, short         ___2104, char**        ___4285) { if (!___3289(___1401, ___2104, 0, ___4285, (___372)(___4285 != NULL))) { ___1177(___4217("Invalid USERREC record in binary datafile")); return (___1305); } return (___4226); } ___372 ___3285(___1405 *___1401, short         ___2104, ___264    ___230) { ___372 ___2040; ___372 DoCollectData; char      *AuxName  = NULL; ___2227 AuxValueType; char      *AuxValue = NULL; REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(0 < ___2104 && ___2104 <= TecplotSDKBinaryFileVersion); REQUIRE(___230 == NULL || VALID_REF(___230)); DoCollectData = (___230 != NULL); ___2040 = ___3289(___1401, ___2104, ___2356, &AuxName, DoCollectData); if (___2040 && DoCollectData && !___249(AuxName)) { ___1177(___4217("Invalid auxiliary data name.")); ___2040 = ___1305; } if (___2040) { AuxValueType = ___1750<int32_t>(___1401, ___2104, 0, 0, &___2040); if (___2040 && (AuxValueType != (___2227)___270)) { ___1177(___4217("Unsupported auxiliary data type")); ___2040 = ___1305; } } if (___2040) ___2040 = ___3289(___1401, ___2104, ___2353, &AuxValue, DoCollectData); if (___2040 && DoCollectData) ___2040 = ___267(___230, AuxName, (___90)AuxValue, ___270, ___4226); if (AuxName != NULL) ___1530(AuxName, "data set auxiliary data item name"); if (AuxValue != NULL) ___1530(AuxValue, "data set auxiliary data item value"); ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } static void GetZoneAttachment(___1405 *___1401, short         ___2104, ___1172   *Z, ___372    *IsAttached, ___372    *___2040) { REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(VALID_REF(Z));
REQUIRE(VALID_REF(IsAttached)); REQUIRE(VALID_REF(___2040) && VALID_BOOLEAN(*___2040)); if (___2104 >= 47) *Z = (___1172)___1750<int32_t>(___1401, ___2104, -1, ___2391, ___2040); else *Z = 0; if (___2104 < 70) (*Z)--; if (*Z == -1) { *Z          = 0; *IsAttached = ___1305; } else *IsAttached = ___4226; ENSURE(VALID_BOOLEAN(*IsAttached)); ENSURE(VALID_BOOLEAN(*___2040)); ENSURE(*Z >= 0); } static ___372 ReadMacroFunctionCommand(___1405  *___1401, short          ___2104, ___372      ___2868, char         **___2331) { ___372 ___3359 = ___1305; REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(___2104 > 0); REQUIRE(VALID_BOOLEAN(___2868)); REQUIRE(VALID_REF(___2331)); ___3359 = ___3289(___1401, ___2104, 0, ___2331, ___2868); ENSURE(VALID_BOOLEAN(___3359)); return (___3359); } ___372 ___3288(___1405 *___1401, short         ___2104, ___372     ___2868, ___1632       *___1556, ___2227     ___2366) { ___2227        ___1832; ___2227        S; FieldDataType_e  FFT; ___372        ___2040 = ___4226; ___4218 ErrMsgString = ___4217("Invalid geometry record"); REQUIRE(VALID_REF(___1556)); if (___2104 < 70) FFT = FieldDataType_Float; else FFT = FieldDataType_Double; if (___2104 < 101) ___1832 = ___1750<int32_t>(___1401, ___2104, 0, 1, &___2040); else ___1832 = ___1750<int32_t>(___1401, ___2104, 0, 4, &___2040); if (___1832 == 0) ___1556->___3167 = CoordSys_Grid; else if (___1832 == 1) ___1556->___3167 = CoordSys_Frame; else if (___1832 == 4) ___1556->___3167 = CoordSys_Grid3D; else { ErrMsgString = ___4217("Invalid geometry coordinate system"); ___2040 = ___1305; } ___1556->___3443 = (Scope_e)___1750<int32_t>(___1401, ___2104, 0, 1, &___2040); if (___2104 >= 102) ___1556->___1113 = (DrawOrder_e)___1750<int32_t>(___1401, ___2104, 0, 1, &___2040); ___1556->position.setXOrTheta(___1762(___1401, FFT, -___2179, ___2179, &___2040)); ___1556->position.setYOrR(___1762(___1401, FFT, -___2179, ___2179, &___2040)); if (___2104 >= 45) ___1556->position.setZ(___1762(___1401, FFT, -___2179, ___2179, &___2040)); else ___1556->position.setZ(0.0); GetZoneAttachment(___1401, ___2104, &___1556->___4600, &___1556->___227, &___2040); ___1556->___351 = (int32_t)___1750<int32_t>(___1401, ___2104, 0, 255, &___2040); AdjustCustomColor(___2104, &___1556->___351); if (___2104 > 47) { ___1556->___1410 = (int32_t)___1750<int32_t>(___1401, ___2104, 0, 255, &___2040); ___1556->___2023  = (___372)___1750<int32_t>(___1401, ___2104, 0, 1, &___2040); AdjustCustomColor(___2104, &___1556->___1410); } else { ___1556->___1410 = ___1556->___351; ___1556->___2023  = ___1305; } if (___2104 < 101) { ___1556->___1652 = (GeomType_e)___1750<int32_t>(___1401, ___2104, 0, 5, &___2040); if (___1556->___1652 == GeomType_LineSegs3D) { ___1556->___1652         = GeomType_LineSegs; ___1556->___3167 = CoordSys_Grid3D; } } else { ___1556->___1652 = (GeomType_e)___1750<int32_t>(___1401, ___2104, 0, 4, &___2040); } if (___1556->___3167 == CoordSys_Grid3D && ___1556->___1652 != GeomType_LineSegs) { ErrMsgString = ___4217("Mismatch between geometry coordinate system and geometry type"); ___2040 = ___1305; } if (___2104 > 41) { ___1556->___2264 = (LinePattern_e)___1750<int32_t>(___1401, ___2104, 0, ___2266, &___2040); } else { ___1556->___2264  = (LinePattern_e)((int)___1556->___1652 % 2); ___1556->___1652     = (GeomType_e)((int)___1556->___1652 / 10); } if ((___2104 < 49) && ((short)(___1556->___1652) == 2)) { ___1556->___1652 = GeomType_Rectangle; ___1556->___2023 = ___4226; } if ((___2104 < 70) && ((short)(___1556->___1652) > 1)) ___1556->___1652 = (GeomType_e)((short)___1556->___1652 + 1); ___3355(&___1556->___2331, NULL, ___4226); ___1556->___1890 = ___1900; if (___2104 >= 70) { ___1556->___2987       = ___1762(___1401, FFT, PatternLengthInputSpec.___2470, PatternLengthInputSpec.___2346, &___2040); ___1556->___2290       = ___1762(___1401, FFT, LineThicknessInputSpec.___2470, LineThicknessInputSpec.___2346, &___2040); ___1556->___2794       = (int32_t)___1750<int32_t>(___1401, ___2104, 2, ___2384, &___2040); ___1556->___188      = (ArrowheadStyle_e)___1750<int32_t>(___1401, ___2104, 0, ___190, &___2040); ___1556->___176 = (ArrowheadAttachment_e)___1750<int32_t>(___1401, ___2104, 0, ___178, &___2040); ___1556->___187  = ___1762(___1401, FFT, ArrowheadSizeInputSpec.___2470, ArrowheadSizeInputSpec.___2346, &___2040); ___1556->___171 = ___1762(___1401, FFT, ArrowheadAngleInputSpec.___2470, ArrowheadAngleInputSpec.___2346, &___2040); if (___2104 >= 75) { ___2040 = ReadMacroFunctionCommand(___1401, ___2104, ___2868, &___1556->___2331); } } else { ___1556->___2290        = 0.001; ___1556->___2987        = 0.02; ___1556->___188       = ___192; ___1556->___176  = ___181;
___1556->___187        = 0.05; ___1556->___171       = 12.0 / ___954; } if (___2104 < 41) { ___1762(___1401, FieldDataType_Float, -___2179, ___2179, &___2040); ___1762(___1401, FieldDataType_Float, -___2179, ___2179, &___2040); ___1762(___1401, FieldDataType_Float, -___2179, ___2179, &___2040); } if (___2104 < 70) ___1556->___907 = FieldDataType_Float; else ___1556->___907 = (FieldDataType_e)___1750<int32_t>(___1401, ___2104, 1, 2, &___2040); ___478(VALID_GEOM_FIELD_DATA_TYPE(___1556->___907)); ___1556->___496 = ___498; if (___2104 >= 101) { ___1556->___496 = (Clipping_e)___1750<int32_t>(___1401, ___2104, 0, 2, &___2040); if (___1556->___496 == (Clipping_e)2) ___1556->___496 = ___497; } if (___2104 < 50 || ___1556->___1652 == GeomType_LineSegs) { ___1556->___2836 = (int32_t)___1750<int32_t>(___1401, ___2104, 1, ___2371, &___2040); S = -1; ___1832 = 0; while ((S + 1 < ___1556->___2836) && !feof(___1401->File) && ___2040) { S++; ___1556->___2838[S] = ___1750<int32_t>(___1401, ___2104, 1, ___2182, &___2040); if ((___1832 + ___1556->___2838[S] > ___2366) && ___2868) { ErrMsgString = ___4217("Geometry is too big"); ___2040 = ___1305; } else { ___3276(___1401, ___1556->___1573.___1548.___4293, ___2868, ___1556->___907, ___1832, ___1832 + ___1556->___2838[S] - 1, &___2040); ___3276(___1401, ___1556->___1573.___1548.___4295, ___2868, ___1556->___907, ___1832, ___1832 + ___1556->___2838[S] - 1, &___2040); if (GEOM_USES_V3(___1556)) ___3276(___1401, ___1556->___1573.___1548.___4297, ___2868, ___1556->___907, ___1832, ___1832 + ___1556->___2838[S] - 1, &___2040); ___1832 += ___1556->___2838[S]; } } if (___2040 && (___1556->___1652 == GeomType_Rectangle)) { if (___2868) { ___675(___1556->___1573.___1548.___4293, 0, ___1556->___1573.___1548.___4293, 2); ___675(___1556->___1573.___1548.___4295, 0, ___1556->___1573.___1548.___4295, 2); } } } else if (___1556->___1652 == GeomType_Rectangle || ___1556->___1652 == GeomType_Ellipse) { double XX, YY; XX = ___1762(___1401, ___1556->___907, -___2179, ___2179, &___2040); YY = ___1762(___1401, ___1556->___907, -___2179, ___2179, &___2040); if (___2868) { ___3490(___1556->___1573.___4580.___4569, 0, XX); ___3490(___1556->___1573.___4580.___4586, 0, YY); } ___1556->___2836 = 1; ___1556->___2838[0]   = 1; } else { double XX; ___478((___1556->___1652 == GeomType_Square) || (___1556->___1652 == GeomType_Circle)); XX = ___1762(___1401, ___1556->___907, -___2179, ___2179, &___2040); if (___2868) { ___3490(___1556->___1573.___4580.___4569, 0, XX); } ___1556->___2836  = 1; ___1556->___2838[0] = 1; } if (!___2040) ___1177(ErrMsgString); return (___2040); } ___372 ___3293(___1405 *___1401, short         ___2104, ___372     ___2868, ___4118       *Text, ___2227     ___2387) { ___2227        ___1832; FieldDataType_e  FFT; int32_t      TextLength = 0; ___372        ___2040 = ___4226; ___4218 ErrMsgString = ___4217("Invalid text record"); REQUIRE(VALID_REF(Text)); if (___2104 < 70) FFT = FieldDataType_Float; else FFT = FieldDataType_Double; if (___2104 < 101) ___1832 = ___1750<int32_t>(___1401, ___2104, 0, 1, &___2040); else ___1832 = ___1750<int32_t>(___1401, ___2104, 0, 4, &___2040); if (___1832 == 0) Text->___3167 = CoordSys_Grid; else if (___1832 == 1) Text->___3167 = CoordSys_Frame; else if (___1832 == 4) Text->___3167 = CoordSys_Grid3D; else { ErrMsgString = ___4217("Invalid text coordinate system."); ___2040 = ___1305; } Text->___3443   = (Scope_e)___1750<int32_t>(___1401, ___2104, 0, 1, &___2040); Text->___52.___1548.___4292 = ___1762(___1401, FFT, -___2179, ___2179, &___2040); Text->___52.___1548.___4294 = ___1762(___1401, FFT, -___2179, ___2179, &___2040); if (___2104 >= 101) Text->___52.___1548.___4296 = ___1762(___1401, FFT, -___2179, ___2179, &___2040); else Text->___52.___1548.___4296 = 0.0; if (___2104 > 40) { Text->___4121.___1444 = (Font_e)___1750<int32_t>(___1401, ___2104, 0, ___1446, &___2040); } else { Text->___4121.___1444 = ___1454; } if (___2104 < 43) ___1762(___1401, FFT, -___2179, ___2179, &___2040); if (___2104 < 70) { if (Text->___3167 == CoordSys_Grid) Text->___4121.___3601 = ___4269; else Text->___4121.___3601 = ___4268; } else Text->___4121.___3601 = (Units_e)___1750<int32_t>(___1401, ___2104, 0, ___4271, &___2040); Text->___4121.___1827 = ___1762(___1401, FFT, -___2179, ___2179, &___2040); if (___2104 > 47) { Text->___401.___411 = (TextBox_e)___1750<int32_t>(___1401, ___2104, 0, ___4069, &___2040); if (___2104 < 70) { if (Text->___401.___411 == ___4069) Text->___401.___411 = ___4063; else if (Text->___401.___411 == ___4063) Text->___401.___411 = ___4069; } Text->___401.___2338     = ___1762(___1401, FFT, TextBoxMarginInputSpec.___2470, TextBoxMarginInputSpec.___2346, &___2040); if (___2104 >= 70) Text->___401.___2290 = ___1762(___1401, FFT,
LineThicknessInputSpec.___2470, LineThicknessInputSpec.___2346, &___2040); else Text->___401.___2290 = 0.01; Text->___401.___351     = (___516)___1750<int32_t>(___1401, ___2104, 0, 255, &___2040); Text->___401.___1410 = (___516)___1750<int32_t>(___1401, ___2104, 0, 255, &___2040); AdjustCustomColor(___2104, &Text->___401.___351); AdjustCustomColor(___2104, &Text->___401.___1410); } else { Text->___401.___411    = ___4075; Text->___401.___2338     = 0.0; Text->___401.___351     = ___4455; Text->___401.___1410 = ___364; } if (___2104 < 70) { Text->___57       = ___1750<int32_t>(___1401, ___2104, -720, 720, &___2040) / ___954; Text->___2288 = 1; Text->___39      = ___4050; } else { Text->___57       = ___1762(___1401, FFT, TextAngleInputSpec.___2470, TextAngleInputSpec.___2346, &___2040); Text->___2288 = ___1762(___1401, FFT, TextLineSpacingInputSpec.___2470, TextLineSpacingInputSpec.___2346, &___2040); Text->___39      = (TextAnchor_e)___1750<int32_t>(___1401, ___2104, 0, ___4048, &___2040); } GetZoneAttachment(___1401, ___2104, &Text->___4600, &Text->___227, &___2040); Text->___351   = (___516)___1750<int32_t>(___1401, ___2104, 0, 255, &___2040); AdjustCustomColor(___2104, &Text->___351); if (___2104 < 70) TextLength = (short)___1750<int32_t>(___1401, ___2104, 0, 5000, &___2040); ___3355(&Text->___2331, NULL, ___4226); Text->___496 = ___498; if (___2104 < 70) { short ___1832, S; for (___1832 = 0; ___1832 < TextLength; ___1832++) { S = (short)___1750<int32_t>(___1401, ___2104, 0, 1000, &___2040); if (___2868 && (___1832 <= ___2387)) Text->Text[___1832] = (char)S; } if (___2868) Text->Text[MIN(TextLength, ___2387)] = '\0'; } else { char *S = NULL; if (___2104 >= 75) { ___2040 = ReadMacroFunctionCommand(___1401, ___2104, ___2868, &Text->___2331); } if (___2104 >= 101) { Text->___496 = (Clipping_e)___1750<int32_t>(___1401, ___2104, 0, 2, &___2040); if (Text->___496 == (Clipping_e)2) Text->___496 = ___497; } if (___3289(___1401, ___2104, ___2387, &S, ___2868)) { REQUIRE(!(S || ___2868) || VALID_REF(Text->Text)); if (S) { if (___2040) { strcpy(Text->Text, S); } ___1530(S, "Release temp string for new text label"); } else if (___2868) Text->Text[0] = '\0'; } else ___2040 = ___1305; } if (!___2040) ___1177(ErrMsgString); return (___2040); } static ___372 CompareVersion(float      ___4408, char      *VersionString, ___372  ___2007) { char *VersionBuf = (char *) & ___4408; REQUIRE(VALID_REF(VersionString)); if (___2007) return ((VersionString[0] == VersionBuf[0]) && (VersionString[1] == VersionBuf[1]) && (VersionString[2] == VersionBuf[2]) && (VersionString[3] == VersionBuf[3])); else return ((VersionString[3] == VersionBuf[0]) && (VersionString[2] == VersionBuf[1]) && (VersionString[1] == VersionBuf[2]) && (VersionString[0] == VersionBuf[3])); } static float ValidVersions[] = {7.0F, 6.3F, 6.2F, 6.1F, 6.0F, 5.0F, 4.7F, 4.6F, 4.5F, 4.4F, 4.3F, 4.2F, 4.1F, 4.0F };
 #define NUMVALIDVERSIONS ((int)(sizeof(ValidVersions)/sizeof(ValidVersions[0])))
static ___372 GetDoubleVersion(char      *VersionString, float     *FInputVersion, ___372  ___2007) { int  ___1832; REQUIRE(VALID_REF(FInputVersion)); for (___1832 = 0; ___1832 < NUMVALIDVERSIONS; ___1832++) if (CompareVersion(ValidVersions[___1832], VersionString, ___2007)) { *FInputVersion = ValidVersions[___1832]; return (___4226); } return (___1305); } static short GetNewInputVersion(___1405 *___1401) { char       Buf[4] = { 0, 0, 0, 0 }; short      ___2104 = 0; short      ___1832; ___2227  OneValue; ___372  ___2040 = ___4226; REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(___1401->___2007); if (___4198(Buf, 4, 1, ___1401->File) != 1) return (0); if (strncmp(Buf, "#!TD", 4)) return (0); if (___4198(Buf, 4, 1, ___1401->File) != 1) return (0); if (Buf[0] != 'V') return (0); ___1832 = 1; while ((___1832 < 4) && tecplot::___2012(Buf[___1832])) ___2104 = ___2104 * 10 + Buf[___1832++] - '0'; if (___2104 < 70) return (0); else if (___2104 > TecplotSDKBinaryFileVersion) { ___1177(___4217("Binary file version newer than Tecplot version. " "Upgrade Tecplot or use an older Preplot to produce " "the datafile.")); return (___2104); } OneValue = ___1750<int32_t>(___1401, ___2104, -___2182, ___2182, &___2040); if (!___2040) return (0); ___1401->___2007 = (OneValue == 1); return (___2104); } short ___1749(___1405 *___1401) { ___372    ___2040 = ___4226; float        FInputVersion; short        ___2104; char         VersionString[4]; ___1398 ___3686 = 0; ___3686 = ___4201(___1401->File); ___2104 = GetNewInputVersion(___1401); if (___2104 > TecplotSDKBinaryFileVersion) return ___2104; else if (___2104 == 0) { rewind(___1401->File); ___2040 = (___4200(___1401->File, ___3686, SEEK_SET) == 0); if (___2040 && ___4198(VersionString, 4, 1, ___1401->File) == 1) { if (!GetDoubleVersion(VersionString, &FInputVersion, ___1401->___2007)) { ___1401->___2007 = !___1401->___2007; ___2040 = GetDoubleVersion(VersionString, &FInputVersion, ___1401->___2007); } if (___2040) ___2104 = ___3422(FInputVersion * 10); } } if (___2040) return (___2104); else return ((short)0); } ___372 ___4486( ___1405*  ___1401, uint8_t const* ___429, ___2227      ___2842) { REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(VALID_REF(___429)); REQUIRE(___2842 >= 0); ___372 ___2040 = ___4202(___429, sizeof(uint8_t), (size_t)___2842, ___1401->File) == (size_t)___2842; ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } static inline ___372 WriteBinaryByte(___1405 *___1401, uint8_t        ByteValue) { REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); ___372 ___2040 = ___4486(___1401, &ByteValue, 1); ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } template <typename T> void CopyAndReverseUnalignedBytes(T            *___1123, const uint8_t *___3658) { REQUIRE(VALID_REF(___1123)); REQUIRE(VALID_REF(___3658)); size_t typeSize = sizeof(T); for (size_t ___1841 = 0; ___1841 < typeSize; ___1841++) ((uint8_t *)(___1123))[___1841] = ((uint8_t *)(___3658))[typeSize-1-___1841]; } template <typename T> void CopyUnalignedBytes(T            *___1123, const uint8_t *___3658) { REQUIRE(VALID_REF(___1123)); REQUIRE(VALID_REF(___3658)); for (size_t ___1841 = 0; ___1841 < sizeof(T); ___1841++) ((uint8_t *)(___1123))[___1841] = ((uint8_t *)(___3658))[___1841]; } template <typename T> ___372 WriteBinaryDataUnaligned(___1405    *___1401, const uint8_t    *ValueBuffer, const ___372  ValueInNativeOrder) { REQUIRE(VALID_REF(___1401) && VALID_FILE_HANDLE(___1401->File)); REQUIRE(VALID_REF(ValueBuffer)); REQUIRE(VALID_BOOLEAN(ValueInNativeOrder)); T DataValue; if (ValueInNativeOrder != ___1401->___2007) CopyAndReverseUnalignedBytes<T>(&DataValue, ValueBuffer); else CopyUnalignedBytes<T>(&DataValue, ValueBuffer); ___372 ___2040 = ___4202(&DataValue, sizeof(T), 1, ___1401->File) == 1; ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } ___372 ___4488(___1405 *___1401, int16_t       ___4315) { REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE("Value can be any int16_t"); return WriteBinaryDataUnaligned<int16_t>(___1401, (uint8_t *) & ___4315, ___4226 ); } ___372 ___4490(___1405 *___1401, int32_t       ___4315) { REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); return WriteBinaryDataUnaligned<int32_t>(___1401, (uint8_t *) & ___4315, ___4226 ); } ___372 WriteBinaryInt64(___1405 *___1401, int64_t       ___4315) { REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE("Value can be any int64_t"); return WriteBinaryDataUnaligned<int64_t>(___1401, (uint8_t *) & ___4315, ___4226 ); } template <typename T> ___372 WriteBinaryBlockUnaligned(___1405    *___1401, const uint8_t    *___4332, const ___2227  ___2842, const ___372  ___4333) { ___372 ___2040 = ___4226;
___372 WriteEachValueSeparately; REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(VALID_REF(___4332)); REQUIRE(___2842 >= 0); REQUIRE(VALID_BOOLEAN(___4333)); WriteEachValueSeparately = (___4333 != ___1401->___2007); if (WriteEachValueSeparately) { for (___2227 NIndex = 0; ___2040 && NIndex < ___2842; NIndex++) { ___2040 = WriteBinaryDataUnaligned<T>(___1401, ___4332 + NIndex * sizeof(T), ___4333); } } else {
 #if 1
size_t NumBytesToWrite = ___2842 * sizeof(T); size_t NumBytesWritten = ___4202(___4332, sizeof(uint8_t), NumBytesToWrite, ___1401->File); ___2040 = NumBytesToWrite == NumBytesWritten;
 #else
___2040 = ___4486(___1401, ___4332, ___2842 * sizeof(T));
 #endif
} ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } ___372 ___4489( ___1405*  ___1401, uint8_t const* ___1963, ___2227      ___2842, ___372      ___4333) { REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(VALID_REF(___1963)); REQUIRE(___2842 >= 0); REQUIRE(VALID_BOOLEAN(___4333)); ___372 ___2040 = WriteBinaryBlockUnaligned<int16_t>(___1401, ___1963, ___2842, ___4333); ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } ___372 ___4491( ___1405*  ___1401, uint8_t const* ___1968, ___2227      ___2842, ___372      ___4333) { REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(VALID_REF(___1968)); REQUIRE(___2842 >= 0); REQUIRE(VALID_BOOLEAN(___4333)); ___372 ___2040 = WriteBinaryBlockUnaligned<int32_t>(___1401, ___1968, ___2842, ___4333); ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } ___372 WriteBinaryInt64BlockUnaligned( ___1405*  ___1401, uint8_t const* Int64Values, ___2227      ___2842, ___372      ___4333) { REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(VALID_REF(Int64Values)); REQUIRE(___2842 >= 0); REQUIRE(VALID_BOOLEAN(___4333)); ___372 ___2040 = WriteBinaryBlockUnaligned<int64_t>(___1401, Int64Values, ___2842, ___4333); ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } ___372 ___4493(___1405    *___1401, double           ___3425, FieldDataType_e  ___1364) { ___372 ___2040 = ___1305; REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE((___1364 == FieldDataType_Float)  || (___1364 == FieldDataType_Double) || (___1364 == FieldDataType_Byte)); switch (___1364) { case FieldDataType_Float : { float FloatVal = ___650(___3425); ___2040 = WriteBinaryDataUnaligned<float>(___1401, (uint8_t *) & FloatVal, ___4226 ); } break; case FieldDataType_Double : { double DoubleVal = ___489(___3425); ___2040 = WriteBinaryDataUnaligned<double>(___1401, (uint8_t *) & DoubleVal, ___4226 ); } break; case FieldDataType_Byte : { uint8_t B; if (___3425 > 255) B = 255; else if (___3425 < 0) B = 0; else B = (uint8_t)___3425; ___2040 = WriteBinaryByte(___1401, B); } break; default: ___478(___1305); break; } ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } ___372 ___4513(___1405    *___1401, FieldDataType_e  ___1310, ___372        ___4485) { if (___4485) return (___4490(___1401, (___2227)___1310)); else { short S = 0; switch (___1310) { case FieldDataType_Float :  S = fprintf(___1401->File, "SINGLE "); break; case FieldDataType_Double : S = fprintf(___1401->File, "DOUBLE "); break; case FieldDataType_Int32 :  S = fprintf(___1401->File, "LONGINT "); break; case FieldDataType_Int16 :  S = fprintf(___1401->File, "SHORTINT "); break; case FieldDataType_Byte :   S = fprintf(___1401->File, "BYTE "); break; case ___1365 :    S = fprintf(___1401->File, "BIT "); break; default: ___478(___1305); } return (___1482(S)); } } template <typename T> ___372 WriteBinaryByteValues( ___1405*  ___1401, uint8_t const* ___429, ___2227      ___2842 ) { REQUIRE(VALID_REF(___1401) && VALID_FILE_HANDLE(___1401->File)); REQUIRE(VALID_REF(___429)); REQUIRE(___2842 >= 1); ___372 ___2040; if (___2842 == 1) ___2040 = WriteBinaryDataUnaligned<T>(___1401, ___429, ___4226); else ___2040 = WriteBinaryBlockUnaligned<T>(___1401, ___429, ___2842, ___4226); ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } template <typename T> ___372 WriteBinaryFieldDataBlockOfType( ___1405* ___1401, ___1361  ___1352, ___2227     ___3686, ___2227     ___2842) { ___372 ___2040 = ___1305; if (___2019(___1352)) { uint8_t *ByteArray = ___1681(___1352) + ___3686 * sizeof(T); ___2040 = WriteBinaryByteValues<T>( ___1401, ByteArray, (___2227)___2842 ); } else { for (___2227 ___2866 = ___3686; ___2866 < ___2842; ___2866++) { T ValueBuffer = (T)___1735(___1352, ___2866); uint8_t* ByteValue = (uint8_t *) & ValueBuffer; ___2040 = WriteBinaryByteValues<T>( ___1401, ByteValue, 1 ); } } ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } static ___372 WriteBinaryFieldDataBlockOfTypeBit( ___1405* ___1401, ___1361  ___1352, ___2227     ASSERT_ONLY(___3686), ___2227     ___2842) { ___372 ___2040 = ___1305; size_t NumBytes = 1 + (___2842 - 1) / 8; if (___2019(___1352)) { uint8_t *ByteArray = ___1681(___1352); ___2040 = WriteBinaryByteValues<uint8_t>( ___1401, ByteArray, (___2227)NumBytes ); } else { for (___2227 ___2866 = 0; ___2866 < ___2842; ___2866 += 8) { uint8_t ValueBuffer = 0; for (int ___1841 = 0; ___1841 < 8; ___1841++) { uint8_t CurBit = (uint8_t)___1735(___1352, ___2866 + ___1841); ValueBuffer |= (CurBit << ___1841); } ___2040 = WriteBinaryByteValues<uint8_t>(
___1401, &ValueBuffer, 1 ); } } ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } ___372 ___4487( ___1405* ___1401, ___1361  ___1352, ___2227     ___3686, ___2227     ___2842) { ___372 ___2040 = ___1305; switch (___1726(___1352)) { case FieldDataType_Float  : ___2040 = WriteBinaryFieldDataBlockOfType<float>(___1401, ___1352, ___3686, ___2842); break; case FieldDataType_Double : ___2040 = WriteBinaryFieldDataBlockOfType<double>(___1401, ___1352, ___3686, ___2842); break; case FieldDataType_Int32  : ___2040 = WriteBinaryFieldDataBlockOfType<int32_t>(___1401, ___1352, ___3686, ___2842); break; case FieldDataType_Int16  : ___2040 = WriteBinaryFieldDataBlockOfType<int16_t>(___1401, ___1352, ___3686, ___2842); break; case FieldDataType_Byte   : ___2040 = WriteBinaryFieldDataBlockOfType<uint8_t>(___1401, ___1352, ___3686, ___2842); break; case ___1365    : ___2040 = WriteBinaryFieldDataBlockOfTypeBit(___1401, ___1352, ___3686, ___2842); break; default: ___478(___1305); break; } ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } static ___372 WriteASCIIFieldDataValue( ___1405* ___1401, ___1361  ___1352, ___2227     ___2866, int32_t       ___200) { double V = ___1735(___1352, ___2866); char ___416[100*MAX_SIZEOFUTF8CHAR]; switch (___1726(___1352)) { case FieldDataType_Float : case FieldDataType_Double : sprintf(___416, " %.*E", (int)___200, V); break; case FieldDataType_Int32 : sprintf(___416, " %*d", (int)___200, ROUND32(V)); break; case FieldDataType_Int16 : sprintf(___416, " %6d", ___3420(V)); break; case FieldDataType_Byte : sprintf(___416, " %3d", ___3422(V)); break; case ___1365 : sprintf(___416, " %c", ((V == 0) ? '0' : '1')); break; default: ___478(___1305); break; } ___372 ___2040 = ___1482(fprintf(___1401->File, "%s", ___416)); ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } ___372 ___4495(___1405 *___1401, ___1361  ___1352, ___372     ___2043, ___2227     ___2809, ___2227     ___2814, ___2227     ___2817, ___372     ___4485, int32_t   ___200) { ___372 ___2040 = ___4226; ___2227 ___2842; ___2227 ___1832, ___2106, ___2135; ___2227 ___2807 = -1; ___2227 ___1839     = -1; ___2227 ___2111     = -1; ___2227 ___2139     = -1; ___372 IsLinear = -1; REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(VALID_REF(___1352)); REQUIRE(VALID_BOOLEAN(___2043)); REQUIRE(___2809 >= 0); REQUIRE(___2814 >= 0); REQUIRE(___2817 >= 0); REQUIRE(VALID_BOOLEAN(___4485)); REQUIRE(IMPLICATION(!___4485, ___200 >= 0)); if (___2043 && !___4485) { ___2807  = ___2809 * ___2814; ___1839      = MAX(___2809 - 1, 1); ___2111      = MAX(___2814 - 1, 1); ___2139      = MAX(___2817 - 1, 1); ___2842 = (___1839 * ___2111 * ___2139); IsLinear  = ((___2814 == 1 && ___2817 == 1) || (___2809 == 1 && ___2817 == 1) || (___2809 == 1 && ___2814 == 1)); } else { ___2842 = ___1717(___1352); } if (___4485) { ___2040 = ___4487(___1401, ___1352, 0, ___2842); } else { ___2227 NumValuesPerLine = 80 / (___200 + 5); if (___2043 && !IsLinear) { ___2227 ValueIndex = 0; for (___2135 = 0; ___2135 < ___2139 && ___2040; ___2135++) for (___2106 = 0; ___2106 < ___2111 && ___2040; ___2106++) for (___1832 = 0; ___1832 < ___1839 && ___2040; ___1832++) { ___2227 ___463 = ___1832 + (___2106 * ___2809) + (___2135 * ___2807); ___2040 = WriteASCIIFieldDataValue(___1401, ___1352, ___463, ___200); if ((ValueIndex + 1) % NumValuesPerLine == 0 || ValueIndex == ___2842 - 1) ___2040 = (fputc('\n', ___1401->File) != EOF); ValueIndex++; } } else { for (___1832 = 0; ___1832 < ___2842 && ___2040; ___1832++) { ___2040 = WriteASCIIFieldDataValue(___1401, ___1352, ___1832, ___200); if ((___1832 + 1) % NumValuesPerLine == 0 || ___1832 == ___2842 - 1) ___2040 = (fputc('\n', ___1401->File) != EOF); } } } ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } ___372 ___1131(___1405 *___1401, const char   *S, ___372     ___4485) { ___372 ___2040 = ___4226; const char *___685 = S; if (___4485) { const char *___685 = S; while (___2040 && ___685 && *___685) ___2040 = ___4490(___1401, (___2227)(unsigned char) * ___685++); if (___2040) ___2040 = ___4490(___1401, 0); } else { fputc('"', ___1401->File); while (___685 && *___685) { if (*___685 == '\n') { ___685++; fputc('\\', ___1401->File); fputc('\\', ___1401->File); fputc('n', ___1401->File); } else { if ((*___685 == '"') || (*___685 == '\\')) fputc('\\', ___1401->File); fputc(*___685++, ___1401->File); } } fputc('"', ___1401->File); ___2040 = (fputc('\n', ___1401->File) != EOF); } return (___2040); } static void WriteAsciiColor(FILE        *File, ___516 Color) { if (Color >= ___1422 && Color <= ___2196) fprintf(File, "CUST%1d ", Color - ___1422 + 1); else { switch (Color) { case ___364  : fprintf(File, "BLACK "); break; case ___3301    : fprintf(File, "RED "); break; case ___1810  : fprintf(File, "GREEN "); break;
case ___366   : fprintf(File, "BLUE "); break; case ___799   : fprintf(File, "CYAN "); break; case ___4587 : fprintf(File, "YELLOW "); break; case ___3256 : fprintf(File, "PURPLE "); break; case ___4455  : fprintf(File, "WHITE "); break; } } } static void WriteAsciiTextGeomBasics(FILE*              File, CoordSys_e         CoordSys, ___372          ___227, ___1172         ___4600, ___516       Color, Scope_e            ___3443, ___372          IncludeZ, ___372          ___4525, ___54 const* ___52, double             ___3434) { REQUIRE(VALID_REF(File)); REQUIRE(VALID_TEXT_COORDSYS(CoordSys) || VALID_GEOM_COORDSYS(CoordSys)); REQUIRE(VALID_BOOLEAN(___227)); REQUIRE(IMPLICATION(___227, ___4600 >= 0)); REQUIRE(VALID_ENUM(___3443, Scope_e)); REQUIRE(VALID_BOOLEAN(IncludeZ)); REQUIRE(VALID_BOOLEAN(___4525)); fprintf(File, "CS="); if (CoordSys == CoordSys_Frame) { fprintf(File, "FRAME"); } else if (CoordSys == CoordSys_Grid) { fprintf(File, "GRID"); } else if (CoordSys == CoordSys_Grid3D) { fprintf(File, "GRID3D"); }
 #if 0 
else if (CoordSys == ___661) { fprintf(File,"FRAMEOFFSET"); }
 #endif
else { ___478(___1305); } if (CoordSys == CoordSys_Grid && !IncludeZ && ___4525) { fprintf(File, "\nTHETA=%.12G,R=%.12G", ___3434*___52->___4147.___4141, ___3434*___52->___4147.___3265); ___478(!IncludeZ); } else { fprintf(File, "\nX=%.12G,Y=%.12G", ___3434*___52->___4580.X, ___3434*___52->___4580.Y); if (IncludeZ) fprintf(File, ",Z=%.12G", ___3434*___52->___4580.Z); } if (___227) fprintf(File, "\nZN=%d", ___4600 + 1); fprintf(File, "\nC="); WriteAsciiColor(File, Color); fprintf(File, "\nS="); if (___3443 == ___3444) { fprintf(File, "GLOBAL"); } else { ___478(___3443 == ___3446); fprintf(File, "LOCAL"); } fputc('\n', File); } bool ___1132(___1405* ___1401, ___1632 const* ___1556, ___372     ___4485, ___372     ___4525) { ___2227       ___1832, ___1926; ___2227       SegIndex; bool            ___2040 = ___4226; FieldDataType_e ___1310; REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(VALID_REF(___1556)); REQUIRE(___1556->___1652 != GeomType_Image); if (___4485) { ___4493(___1401, ___1617, FieldDataType_Float); if (___1556->___3167 == CoordSys_Grid) { ___4490(___1401, 0); } else if (___1556->___3167 == CoordSys_Frame) { ___4490(___1401, 1); } else if (___1556->___3167 == CoordSys_Grid3D) { ___4490(___1401, 4); }
 #if 0 
else if (___1556->___3167 == ___661) { ___4490(___1401, 2); }
 #endif
else { ___478(___1305); } ___4490(___1401, (___2227)___1556->___3443); ___4490(___1401, (___2227)___1556->___1113); ___4493(___1401, ___1556->position.XOrTheta(), FieldDataType_Double); ___4493(___1401, ___1556->position.YOrR(), FieldDataType_Double); ___4493(___1401, ___1556->position.Z(), FieldDataType_Double); if (___1556->___227) ___4490(___1401, (___2227)___1556->___4600); else ___4490(___1401, (___2227) - 1); ___4490(___1401, (___2227)___1556->___351); ___4490(___1401, (___2227)___1556->___1410); ___4490(___1401, (___2227)___1556->___2023); ___478(___1556->___1652 != GeomType_LineSegs3D); ___4490(___1401, (___2227)___1556->___1652); ___4490(___1401, (___2227)___1556->___2264); ___4493(___1401, ___1556->___2987, FieldDataType_Double); ___4493(___1401, ___1556->___2290, FieldDataType_Double); ___4490(___1401, (___2227)___1556->___2794); ___4490(___1401, (___2227)___1556->___188); ___4490(___1401, (___2227)___1556->___176); ___4493(___1401, ___1556->___187, FieldDataType_Double); ___4493(___1401, ___1556->___171, FieldDataType_Double); ___1131(___1401, ___1556->___2331, ___4226); ___1310 = ___1747(___1556); ___4513(___1401, ___1310, ___4226); ___4490(___1401, (___2227)___1556->___496); if (___1556->___1652 == GeomType_LineSegs) { short S; ___4490(___1401, ___1556->___2836); ___1832 = 0; for (S = 0; ___2040 && (S < ___1556->___2836); S++) { ___4490(___1401, ___1556->___2838[S]); ___4487(___1401, ___1556->___1573.___1548.___4293, ___1832, ___1556->___2838[S]); ___2040 = ___4487(___1401, ___1556->___1573.___1548.___4295, ___1832, ___1556->___2838[S]) == ___4226; if (GEOM_USES_V3(___1556)) ___2040 = ___4487(___1401, ___1556->___1573.___1548.___4297, ___1832, ___1556->___2838[S]) == ___4226; ___1832 += ___1556->___2838[S]; } } else if (___1556->___1652 == GeomType_Rectangle || ___1556->___1652 == GeomType_Ellipse) { ___4493(___1401, ___1735(___1556->___1573.___4580.___4569, 0), ___1310); ___2040 = ___4493(___1401, ___1735(___1556->___1573.___4580.___4586, 0), ___1310) == ___4226; } else { ___478((___1556->___1652 == GeomType_Square) || (___1556->___1652 == GeomType_Circle)); ___2040 = ___4493(___1401, ___1735(___1556->___1573.___4580.___4569, 0), ___1310) == ___4226; } } else { double ___3434; if (___1556->___3167 == CoordSys_Frame) ___3434 = 100.0; else ___3434 = 1.0; fprintf(___1401->File, "GEOMETRY\nF=POINT\n"); ___54 const positon = ___1556->position.anchorPosition(); WriteAsciiTextGeomBasics(___1401->File, ___1556->___3167, ___1556->___227, ___1556->___4600, ___1556->___351, ___1556->___3443, ___4226, ___4525, &positon, ___3434); switch (___1556->___2264) { case ___2271      : fprintf(___1401->File, "L=SOLID\n"); break; case ___2267     : fprintf(___1401->File, "L=DASHED\n"); break; case ___2265    : fprintf(___1401->File, "L=DASHDOT\n"); break; case ___2268     : fprintf(___1401->File, "L=DOTTED\n"); break; case ___2270   : fprintf(___1401->File, "L=LONGDASH\n"); break; case ___2266 : fprintf(___1401->File, "L=DASHDOTDOT\n"); break; default: ___478(___1305); break; } fprintf(___1401->File, "PL=%.12G\n", ___1556->___2987*PatternLengthInputSpec.___1978.___3434); fprintf(___1401->File, "LT=%.12G\n", ___1556->___2290*LineThicknessInputSpec.___1978.___3434); if (___1556->___2023) { fprintf(___1401->File, "FC="); WriteAsciiColor(___1401->File, ___1556->___1410); } if (___1556->___496 == ___498) { fprintf(___1401->File, "CLIPPING=CLIPTOVIEWPORT\n"); } else { ___478(___1556->___496 == ___497); fprintf(___1401->File, "CLIPPING=CLIPTOFRAME\n"); } if (___1556->___1113 == ___1114) { fprintf(___1401->File, "DRAWORDER=AFTERDATA\n"); } else { ___478(___1556->___1113 == ___1115); fprintf(___1401->File, "DRAWORDER=BEFOREDATA\n"); } fprintf(___1401->File, "MFC="); ___1131(___1401, ___1556->___2331, ___1305); if ((___1556->___1652 == GeomType_Circle) || (___1556->___1652 == GeomType_Ellipse)) fprintf(___1401->File, "EP=%ld\n", (ldfmt_t)___1556->___2794); if (___1556->___1652 == GeomType_LineSegs && ___1556->___3167 != CoordSys_Grid3D) { switch (___1556->___188) { case ___192  : fprintf(___1401->File, "AST=PLAIN\n"); break; case ___189 : fprintf(___1401->File, "AST=FILLED\n"); break; case ___190 : fprintf(___1401->File, "AST=HOLLOW\n"); break; default: ___478(___1305); break; } switch (___1556->___176) { case ___181        : break; case ___177 : fprintf(___1401->File, "AAT=BEGINNING\n"); break;
case ___179       : fprintf(___1401->File, "AAT=END\n"); break; case ___178  : fprintf(___1401->File, "AAT=BOTH\n"); break; default: ___478(___1305); break; } if (___1556->___176 != ___181) { fprintf(___1401->File, "ASZ=%.12G\n", ___1556->___187*ArrowheadSizeInputSpec.___1978.___3434); fprintf(___1401->File, "AAN=%.12G\n", ___1556->___171*ArrowheadAngleInputSpec.___1978.___3434); } } switch (___1556->___1652) { case GeomType_LineSegs : { fprintf(___1401->File, "T=LINE\n"); fprintf(___1401->File, "DT="); ___4513(___1401, ___1726(___1556->___1573.___1548.___4293), ___1305); fputc('\n', ___1401->File); fprintf(___1401->File, "%d\n", (int)___1556->___2836); SegIndex = 0; for (___1832 = 0; ___2040 && (___1832 < ___1556->___2836); ___1832++) { fprintf(___1401->File, "%ld\n", (ldfmt_t)___1556->___2838[___1832]); for (___1926 = 0; ___1926 < ___1556->___2838[___1832]; ___1926++) { fprintf(___1401->File, "%.12G ", ___1735(___1556->___1573.___1548.___4293, SegIndex + ___1926)*___3434); fprintf(___1401->File, "%.12G", ___1735(___1556->___1573.___1548.___4295, SegIndex + ___1926)*___3434); if (GEOM_USES_V3(___1556)) ___2040 = ___1482(fprintf(___1401->File, " %.12G\n", ___1735(___1556->___1573.___1548.___4297, SegIndex + ___1926))); else ___2040 = (___372)(fputc('\n', ___1401->File) != EOF); } SegIndex += ___1556->___2838[___1832]; } } break; case GeomType_Rectangle : { fprintf(___1401->File, "T=RECTANGLE %.12G %.12G\n", ___1735(___1556->___1573.___4580.___4569, 0)*___3434, ___1735(___1556->___1573.___4580.___4586, 0)*___3434); } break; case GeomType_Square : { fprintf(___1401->File, "T=SQUARE %.12G\n", ___1735(___1556->___1573.___4580.___4569, 0)*___3434); } break; case GeomType_Circle : { fprintf(___1401->File, "T=CIRCLE %.12G\n", ___1735(___1556->___1573.___4580.___4569, 0)*___3434); } break; case GeomType_Ellipse : { fprintf(___1401->File, "T=ELLIPSE %.12G %.12G\n", ___1735(___1556->___1573.___4580.___4569, 0)*___3434, ___1735(___1556->___1573.___4580.___4586, 0)*___3434); } break; default: ___478(___1305); } } return ___2040; } bool ___1133(___1405* ___1401, ___4118 const* Text, ___372     ___4485, ___372     ___4525) { REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(VALID_REF(Text)); REQUIRE(VALID_BOOLEAN(___4485)); REQUIRE(VALID_BOOLEAN(___4525)); if (___4485) { ___4493(___1401, ___4112, FieldDataType_Float); if (Text->___3167 == CoordSys_Grid) { ___4490(___1401, 0); } else if (Text->___3167 == CoordSys_Frame) { ___4490(___1401, 1); } else if (Text->___3167 == CoordSys_Grid3D) { ___4490(___1401, 4); }
 #if 0 
else if (___1556->___3167 == ___661) { ___4490(___1401, 2); }
 #endif
else { ___478(___1305); } ___4490(___1401, (___2227)Text->___3443); ___4493(___1401, Text->___52.___1548.___4292, FieldDataType_Double); ___4493(___1401, Text->___52.___1548.___4294, FieldDataType_Double); ___4493(___1401, Text->___52.___1548.___4296, FieldDataType_Double); { ___4490(___1401, static_cast<___2227>(Text->___4121.___1444)); } ___4490(___1401, (___2227)Text->___4121.___3601); ___4493(___1401, Text->___4121.___1827, FieldDataType_Double); ___4490(___1401, (___2227)Text->___401.___411); ___4493(___1401, Text->___401.___2338, FieldDataType_Double); ___4493(___1401, Text->___401.___2290, FieldDataType_Double); ___4490(___1401, (___2227)Text->___401.___351); ___4490(___1401, (___2227)Text->___401.___1410); ___4493(___1401, Text->___57, FieldDataType_Double); ___4493(___1401, Text->___2288, FieldDataType_Double); ___4490(___1401, (___2227)Text->___39); if (Text->___227) ___4490(___1401, (___2227)Text->___4600); else ___4490(___1401, (___2227) - 1); ___4490(___1401, (___2227)Text->___351); } else { double ___3434; ___372 IncludeZ = Text->___3167 == CoordSys_Grid3D; if (Text->___3167 == CoordSys_Frame) ___3434 = 100.0; else ___3434 = 1.0; fprintf(___1401->File, "TEXT\n"); WriteAsciiTextGeomBasics(___1401->File, Text->___3167, Text->___227, Text->___4600, Text->___351, Text->___3443, IncludeZ, ___4525, &Text->___52, ___3434); fprintf(___1401->File, "HU="); switch (Text->___4121.___3601) { case ___4269  : fprintf(___1401->File, "GRID\n"); break; case ___4268 : fprintf(___1401->File, "FRAME\n"); break; case ___4271 : fprintf(___1401->File, "POINT\n"); break; case ___4267 : default: ___478(___1305); break; } fprintf(___1401->File, "LS=%.4G ", Text->___2288); fprintf(___1401->File, "AN="); switch (Text->___39) { case ___4050       : fprintf(___1401->File, "LEFT\n");        break; case ___4045     : fprintf(___1401->File, "CENTER\n");      break; case ___4055      : fprintf(___1401->File, "RIGHT\n");       break; case ___4052    : fprintf(___1401->File, "MIDLEFT\n");     break; case ___4051  : fprintf(___1401->File, "MIDCENTER\n");   break; case ___4053   : fprintf(___1401->File, "MIDRIGHT\n");    break; case ___4047   : fprintf(___1401->File, "HEADLEFT\n");    break; case ___4046 : fprintf(___1401->File, "HEADCENTER\n");  break; case ___4048  : fprintf(___1401->File, "HEADRIGHT\n");   break; default: ___478(___1305); break; } switch (Text->___401.___411) { case ___4069 : fprintf(___1401->File, "BX=Hollow "); break; case ___4063 : fprintf(___1401->File, "BX=Filled "); break; default :; } fprintf(___1401->File, "BXM=%.4G ", Text->___401.___2338*100); fprintf(___1401->File, "LT=%.4G ", Text->___401.___2290*100.0); fprintf(___1401->File, "BXO="); WriteAsciiColor(___1401->File, Text->___401.___351); fprintf(___1401->File, "BXF="); WriteAsciiColor(___1401->File, Text->___401.___1410); fprintf(___1401->File, "\nF="); Font_e ___1443; { ___1443 = Text->___4121.___1444; } switch (___1443) { case ___1454                  : fprintf(___1401->File, "HELV");                break; case ___1455              : fprintf(___1401->File, "HELV-BOLD");           break; case Font_HelveticaItalic            : fprintf(___1401->File, "HELV-ITALIC");         break; case Font_HelveticaItalicBold        : fprintf(___1401->File, "HELV-ITALIC-BOLD");    break; case ___1466                      : fprintf(___1401->File, "TIMES");               break; case ___1467                  : fprintf(___1401->File, "TIMES-BOLD");          break; case ___1468                : fprintf(___1401->File, "TIMES-ITALIC");        break; case ___1469            : fprintf(___1401->File, "TIMES-ITALIC-BOLD");   break; case ___1445                    : fprintf(___1401->File, "COURIER");             break; case ___1446                : fprintf(___1401->File, "COURIER-BOLD");        break; case Font_CourierItalic              : fprintf(___1401->File, "COURIER-ITALIC");      break; case Font_CourierItalicBold          : fprintf(___1401->File, "COURIER-ITALIC-BOLD"); break; case ___1449                      : fprintf(___1401->File, "GREEK");               break; case ___1459                       : fprintf(___1401->File, "MATH");                break; case ___1470                : fprintf(___1401->File, "USER-DEF");            break; default: ___478(___1305); break; } if (Text->___4121.___3601 == ___4268) ___3434 = 100.0; else ___3434 = 1.0; fprintf(___1401->File, "\nH=%.12G A=%.12G",
Text->___4121.___1827*___3434, Text->___57*___954); } if (!___4485) fprintf(___1401->File, "\nMFC="); ___1131(___1401, Text->___2331, ___4485); if (!___4485) { if (Text->___496 == ___498) { fprintf(___1401->File, "CLIPPING=CLIPTOVIEWPORT\n"); } else { ___478(Text->___496 == ___497); fprintf(___1401->File, "CLIPPING=CLIPTOFRAME\n"); } } else { ___4490(___1401, (___2227)Text->___496); } if (!___4485) fprintf(___1401->File, "T="); return ___1131(___1401, Text->Text, ___4485) == ___4226; } ___372 ___1130(___1405  *___1401, ___372      ___4485, ___3839  ___2170) { ___372 ___2040 = ___4226; ___2227 ___1926 = 0; ___2227 ___684 = 0; REQUIRE(VALID_REF(___1401) && VALID_REF(___1401->File)); REQUIRE(VALID_BOOLEAN(___4485)); REQUIRE(___3848(___2170)); ___684 = ___3826(___2170); if (___4485) { ___4493(___1401, ___792, FieldDataType_Float); ___4490(___1401, ___684); } else { fprintf(___1401->File, " CUSTOMLABELS = \n"); } for (___1926 = 0, ___2040 = ___4226; ___1926 < ___684 && ___2040; ___1926++) { const char *CurLabel = ___3835(___2170, ___1926); ___2040 = ___1131(___1401, CurLabel, ___4485); } ENSURE(VALID_BOOLEAN(___2040)); return ___2040; } ___372 ___4492(___1405 *___1401) { return (___4490(___1401, 1)); } bool ___4494(___1405& ___1400, int           ___4409) { char ___416[5]; sprintf(___416, "V%-3d", ___4409); ___478(strlen(___416) == 4); return fprintf(___1400.File, "#!TD%s", ___416) > 0; }
