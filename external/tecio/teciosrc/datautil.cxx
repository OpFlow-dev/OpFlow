#include "stdafx.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "TASSERT.h"
#include "Q_UNICODE.h"
#include "SYSTEM.h"
#include "ALLOC.h"
#include "ARRLIST.h"
#include "SET.h"
#include "DATASET.h"
#include "FILESTREAM.h"
#include "DATAIO.h"
#include "DATAIO4.h"
#include "DATAUTIL.h"
#include "STRLIST.h"
#include "Q_MSG.h"
 #if defined MAKEARCHIVE
 #define ___1937
 #endif
#include "INPUT.h"
using namespace tecplot;
 #if defined MAKEARCHIVE
 #define ___58 1.0e-10
void ___1935(void) { LineThicknessInputSpec.___4236                                = ___1942; LineThicknessInputSpec.___2470                                 = 0.000001; LineThicknessInputSpec.___2346                                 = 1.0; LineThicknessInputSpec.___1978.___3434           = 100.0; LineThicknessInputSpec.___3884                      = NULL; PatternLengthInputSpec.___4236                                = ___1942; PatternLengthInputSpec.___2470                                 = 0.0001; PatternLengthInputSpec.___2346                                 = 1.0; PatternLengthInputSpec.___1978.___3434           = 100.0; PatternLengthInputSpec.___3884                      = NULL; TextBoxMarginInputSpec.___4236                                = ___1942; TextBoxMarginInputSpec.___2470                                 = 0.0; TextBoxMarginInputSpec.___2346                                 = 20.0; TextBoxMarginInputSpec.___1978.___3434           = 100.0; TextBoxMarginInputSpec.___3884                      = NULL; TextLineSpacingInputSpec.___4236                              = ___1942; TextLineSpacingInputSpec.___2470                               = 0.0; TextLineSpacingInputSpec.___2346                               = 5.0; TextLineSpacingInputSpec.___1978.___3434         = 1.0; TextLineSpacingInputSpec.___3884                    = NULL; ArrowheadSizeInputSpec.___4236                                = ___1942; ArrowheadSizeInputSpec.___2470                                 = 0.0; ArrowheadSizeInputSpec.___2346                                 = 0.5; ArrowheadSizeInputSpec.___1978.___3434           = 100.0; ArrowheadSizeInputSpec.___3884                      = NULL; TextAngleInputSpec.___4236                                    = ___1942; TextAngleInputSpec.___2470                                     = -___3003 - ___58; TextAngleInputSpec.___2346                                     =  ___3003 + ___58; TextAngleInputSpec.___1978.___3434               = ___954; TextAngleInputSpec.___3884                          = NULL; ArrowheadAngleInputSpec.___4236                               = ___1942; ArrowheadAngleInputSpec.___2470                                = 1.0 / ___954 - ___58; ArrowheadAngleInputSpec.___2346                                = ___3088 + ___58; ArrowheadAngleInputSpec.___1978.___3434          = ___954; ArrowheadAngleInputSpec.___3884                     = NULL; }
 #endif
void LocalReadBlock(___1405   *___1401, double         *CurVPtr, FieldDataType_e ___1367, ___2227       ___2842, ___372      *___2040) { REQUIRE(VALID_REF(___2040) && VALID_BOOLEAN(*___2040)); REQUIRE(!(*___2040) || VALID_REF(___1401)); REQUIRE(!(*___2040) || VALID_FIELD_DATA_TYPE(___1367)); if (*___2040) { ___372 ___1099 = (CurVPtr != NULL); ___372 ReadByBlock = (FieldDataType_Double == ___1367) || !___1099; if (ReadByBlock) { ___3296(___1401, ___1099, (void *)CurVPtr, ___1367, 0, ___2842, ___2040); } else { ___2227 N; for (N = 0; *___2040 && (N < ___2842); N++) { double D = ___1762(___1401, ___1367, -___2179, ___2179, ___2040); if (___1099) CurVPtr[N] = D; } } } } ___372 STDCALL ___3297(___372       ___1748, char           *___1439, int32_t        *___2104, char          **___903, ___1172     *___2847, ___1172     *NumVars, ___3839  *___4366, ___3839  *___4653, ___2227     **___2830, ___2227     **___2831, ___2227     **___2832, ZoneType_e    **___4693, ___3839  *___4285, ___264     *___885, ___372       RawDataSpaceAllocated, ___2732    ***___2724, double       ***___4395) { ___372     InputIsOk         = ___1305; ___134  ___4682      = NULL; ___2227    *___1441   = NULL; ___1405 *ReadTecFileStream = NULL; ___3501       *___2075 = NULL; REQUIRE(VALID_BOOLEAN(___1748)); REQUIRE(VALID_NON_ZERO_LEN_STR(___1439)); REQUIRE(VALID_REF(___2104)); REQUIRE(VALID_REF(___903) || ___903 == NULL); REQUIRE(VALID_REF(___2847)); REQUIRE(VALID_REF(NumVars)); REQUIRE(___4366  == NULL || VALID_REF(___4366)); REQUIRE(___4653 == NULL || VALID_REF(___4653)); REQUIRE(___2830   == NULL || VALID_REF(___2830)); REQUIRE(___2831   == NULL || VALID_REF(___2831)); REQUIRE(___2832   == NULL || VALID_REF(___2832)); REQUIRE(___4693  == NULL || VALID_REF(___4693)); REQUIRE(___4285   == NULL || VALID_REF(___4285)); REQUIRE(VALID_BOOLEAN(RawDataSpaceAllocated)); REQUIRE(IMPLICATION(!___1748 && RawDataSpaceAllocated, VALID_REF(___2724) && VALID_REF(___4395)));
 #if defined MAKEARCHIVE
___1935();
 #endif
InputIsOk  = ___2876(&ReadTecFileStream, ___1439, 0, ___2104); if (InputIsOk) InputIsOk = ___3279(ReadTecFileStream, *___2104, ___1305, ___2847, NumVars, (int32_t *)NULL, ___903, (___4118 **)NULL, (___1632 **)NULL, (___3839  **)NULL, ___4285, ___885, 0, &___2075, (___372 *)NULL, (___372 *)NULL, &___4682, ___4366, (___134 *)NULL, (___3501 *)NULL, &___1441, (DataFileType_e *)NULL); if (InputIsOk) { if (*___2847 == 0) *NumVars = 0; else if (*___2104 > 112) { ___1177(___4217("ReadTec does not yet support version %d " "Tecplot binary data files."), *___2104); InputIsOk = ___1305; } else if (!___1748) { ___1172 Z; for (Z = 0; Z < *___2847 && InputIsOk; Z++) { InputIsOk = ___2015(___2075[Z]); if (!InputIsOk) ___1177(___4217("Cell centered data not supported by ReadTec.")); } } } if (___2075 != NULL) { ___1172 Z; for (Z = 0; Z < *___2847; Z++) ___939(&___2075[Z]); ___1530(___2075, "Array of IsVarCellCentered sets"); } if (InputIsOk) { ___1172 Z; if (___4653) *___4653 = ___3821(); if (___2830) *___2830  = ___23(*___2847, ___2227, "numptsi"); if (___2831) *___2831  = ___23(*___2847, ___2227, "numptsj"); if (___2832) *___2832  = ___23(*___2847, ___2227, "numptsk"); if (___4693) *___4693 = ___23(*___2847, ZoneType_e, "zonetype"); for (Z = 0; Z < *___2847; Z++) { ___4683 *___4677 = ___1803(___4682, Z); if (___4677 != NULL) { if (___4653 && *___4653) ___3823(*___4653, ___4677->___2686); if (___2830 && *___2830) (*___2830)[Z] = ___4677->___2830; if (___2831 && *___2831) (*___2831)[Z] = ___4677->___2831; if (___2832 && *___2832) (*___2832)[Z] = ___4677->___2832; if (___4693 && *___4693) (*___4693)[Z] = ___4677->___4236; } else { if (___4653 && *___4653) ___3823(*___4653, NULL); if (___2830 && *___2830) (*___2830)[Z] = 0; if (___2831 && *___2831) (*___2831)[Z] = 0; if (___2832 && *___2832) (*___2832)[Z] = 0; if (___4693 && *___4693) (*___4693)[Z] = ___4703; } } } if (!___1748 && InputIsOk && (*___2847 > 0)) { ___1172      *VarSharesFromZone          = NULL; ___372       *___2076               = NULL; ___1172      *ConnectivitySharesFromZone = NULL; FieldDataType_e *VarType = NULL; int              ___734; int              ___718; ___2227        ___2809 = 0; ___2227        ___2814 = 0; ___2227        ___2817 = 0; ___2227        TotalNumPts; ___2227        ___1832, ___2106; if ((*___2847 > 0) && !RawDataSpaceAllocated) { *___4395   = ___23(*___2847 * (*NumVars), double *, "vdatabase array"); if (*___4395 == NULL) { ___1177(___4217("Cannot allocate space for field data")); InputIsOk = ___1305; } else { int ___1832; for (___1832 = 0; ___1832 < *___2847*(*NumVars); ___1832++) (*___4395)[___1832] = NULL; } if (InputIsOk) { *___2724 = ___23(*___2847, ___2732 *, "nodemap array"); if (*___2724 == NULL) { ___1177(___4217("Cannot allocate space for nodemap")); InputIsOk = ___1305; } else { int ___1832; for (___1832 = 0; ___1832 < *___2847; ___1832++) (*___2724)[___1832] = NULL; } } } if (InputIsOk) { VarType           = ___23(*NumVars + 1, FieldDataType_e, "Var Type"); VarSharesFromZone = ___23(*NumVars + 1, ___1172, "VarSharesFromZone"); ___2076      = ___23(*NumVars + 1, ___372, "IsVarPassive"); ConnectivitySharesFromZone = ___23(*___2847, ___1172, "ConnectivitySharesFromZone"); InputIsOk = (VarType                    != NULL && VarSharesFromZone          != NULL && ___2076               != NULL && ConnectivitySharesFromZone != NULL); } for (___734 = 0; ___734 < *___2847 && InputIsOk; ___734++) { double ___4567 = ___1762(ReadTecFileStream, FieldDataType_Float, 0.0, 1000.0, &InputIsOk); if (InputIsOk && (___4567 == ___4649)) { ___4683 *CurZoneSpec   = ___1803(___4682, ___734); ___372   ZoneIsFinite  = (CurZoneSpec->___4236 != ___4704); ___372   ZoneIsFEPoly  = (CurZoneSpec->___4236 == ___4698 || CurZoneSpec->___4236 == ___4699); ___372   InBlockFormat = CurZoneSpec->___4647.___2027; for (___2106 = 0; ___2106 < *NumVars; ___2106++) { VarSharesFromZone[___2106] = -1; VarType[___2106]           = FieldDataType_Float; ___2076[___2106]      = ___1305; } if (*___2104 > 45 && *___2104 < 101 && InputIsOk) { ___1172 NumDupVars, ZZ; NumDupVars = (___1172)___1750<int32_t>(ReadTecFileStream, *___2104, 0, *NumVars, &InputIsOk); for (___2106 = 0; ___2106 < NumDupVars; ___2106++) { ZZ = (___1172)___1750<int32_t>(ReadTecFileStream, *___2104, 0, *NumVars, &InputIsOk) - 1; VarSharesFromZone[ZZ] = ___734 - 1; } if ((NumDupVars > 0) && (___734 == 0)) { ___1177(___4217("Cannot duplicate variables from the first zone since there are " "no previous zones to duplicate from.")); InputIsOk = ___1305; } } if (*___2104 >= 70 && InputIsOk) { for (___2106 = 0; ___2106 < *NumVars; ___2106++) { VarType[___2106] = (FieldDataType_e)___1750<int32_t>(ReadTecFileStream, *___2104,
0, ___1365, &InputIsOk); if (!InputIsOk) { ___1177(___4217("Invalid data type - binary input file corrupted")); InputIsOk = ___1305; } } } if (InputIsOk) { ___2809 = CurZoneSpec->___2830; ___2814 = CurZoneSpec->___2831; ___2817 = CurZoneSpec->___2832; } if (ZoneIsFinite) TotalNumPts = ___2809; else TotalNumPts = (___2809 * ___2814 * ___2817); for (___718 = 0; ___718 < *NumVars && InputIsOk; ___718++) { if (!RawDataSpaceAllocated && TotalNumPts >= 1) { (*___4395)[___718+___734*(*NumVars)] = ___23(TotalNumPts, double, "raw data"); } } if (*___2104 >= 105 && InputIsOk) { if ((___372)___1750<int32_t>(ReadTecFileStream, *___2104, 0, 1, &InputIsOk) && InputIsOk) { for (___718 = 0; ___718 < *NumVars && InputIsOk; ___718++) { ___2076[___718] = (___372)___1750<int32_t>(ReadTecFileStream, *___2104, 0, 1, &InputIsOk); } } } if (*___2104 >= 101 && InputIsOk) { if ((___372)___1750<int32_t>(ReadTecFileStream, *___2104, 0, 1, &InputIsOk) && InputIsOk) { for (___718 = 0; ___718 < *NumVars && InputIsOk; ___718++) { ___1172 SharedZone = ___1750<int32_t>(ReadTecFileStream, *___2104, -1, ___2382 - 1, &InputIsOk); if (SharedZone != -1 && InputIsOk) VarSharesFromZone[___718] = SharedZone; } } if (InputIsOk) { ___1172 SharedZone = ___1750<int32_t>(ReadTecFileStream, *___2104, -1, ___2382 - 1, &InputIsOk); if (InputIsOk) ConnectivitySharesFromZone[___734] = SharedZone; } } if (*___2104 >= 103 && InputIsOk) { for (___718 = 0; ___718 < *NumVars && InputIsOk; ___718++) { if (VarSharesFromZone[___718] == -1 && !___2076[___718]) { ___1762(ReadTecFileStream, FieldDataType_Double, -___2179, ___2179, &InputIsOk); ___1762(ReadTecFileStream, FieldDataType_Double, -___2179, ___2179, &InputIsOk); } } } if (InBlockFormat) { ___718 = -1; while (InputIsOk && ((___718 + 1) < *NumVars)) { ___718++; if ((___718 < *NumVars) && (TotalNumPts > 0)) { double *CurVPtr  = (*___4395)[___718+___734*(*NumVars)]; ___2106 = 0; if (VarSharesFromZone[___718] != -1) { ___2227 M; ___1172 ___3648 = VarSharesFromZone[___718]; double *SourceVPtr = (*___4395)[___718+___3648*(*NumVars)]; for (M = 0; M < TotalNumPts; M++) CurVPtr[M] = SourceVPtr[M]; } else if (!___2076[___718]) { LocalReadBlock(ReadTecFileStream, CurVPtr, VarType[___718], TotalNumPts, &InputIsOk); } } } if (!InputIsOk) ___1177(___4217("Invalid raw data section of binary file")); } else if (TotalNumPts > 0) { ___2106 = -1; if (InputIsOk) { ___2227 N; N = 0; while (InputIsOk && (N < TotalNumPts)) { ___1172 ___718; for (___718 = 0; InputIsOk && (___718 < *NumVars); ___718++) { double *CurVPtr  = (*___4395)[___718+___734*(*NumVars)]; if (VarSharesFromZone[___718] != -1) { ___1172 ___3648 = VarSharesFromZone[___718]; double *SourceVPtr = (*___4395)[___718+___3648*(*NumVars)]; CurVPtr[N] = SourceVPtr[N]; } else if (!___2076[___718]) { double D = ___1762(ReadTecFileStream, VarType[___718], -___2179, ___2179, &InputIsOk); if (InputIsOk && CurVPtr) CurVPtr[N] = D; } } if (!InputIsOk) ___1177(___4217("Binary datafile corrupted!")); N++; } } } if (InputIsOk && *___2104 < 101) { if (ZoneIsFinite) { ___372 DupConnectivity; if (*___2104 > 61) DupConnectivity = ___1750<int32_t>(ReadTecFileStream, *___2104, 0, 1, &InputIsOk); else DupConnectivity = ___1305; if (DupConnectivity) ConnectivitySharesFromZone[___734] = ___734 - 1; else ConnectivitySharesFromZone[___734] = -1; } else ConnectivitySharesFromZone[___734] = -1; } if (InputIsOk && ZoneIsFinite && !ZoneIsFEPoly) { ___372   SkipNodemap; ___2732  *___2707 = NULL; ___2732  *ONM = NULL; if (!RawDataSpaceAllocated && ___2817*___2814 >= 1) { (*___2724)[___734] = ___23(___2817 * ___2814, ___2732, "node map"); if ((*___2724)[___734] == NULL) ___1177(___4217("Cannot allocate space for connectivity list", "See the Tecplot User's Manual for a definition of 'connectivity list'")); } if (InputIsOk) ___2707 = (*___2724)[___734]; SkipNodemap = (___2707 == NULL); if (InputIsOk && ConnectivitySharesFromZone[___734] != -1) { ___1172 ___3648 = ConnectivitySharesFromZone[___734]; if (___3648 >= ___734) { ___1177(___4217("Zone %d is attempting to share connectivity " "with a zone that has not yet been loaded."), ___734 + 1); InputIsOk = ___1305; } else { ONM = (*___2724)[___3648]; if (ONM == NULL) { ___1177(___4217("Zone %d is attempting to share connectivity " "with a zone that is not finite element."), ___734 + 1); InputIsOk = ___1305; } } } if (InputIsOk) { for (___2106 = 0; ___2106 < ___2814; ___2106++) for (___1832 = 0; ___1832 < ___2817; ___1832++) { ___2227 M; ___2227 ___2165 = ___2106 * ___2817 + ___1832; if (ConnectivitySharesFromZone[___734] != -1) { M = ONM[___2165]; } else { int32_t const nodeShift = *___2104 < 103 ? 1 : 0; M = ___1750<int32_t>(ReadTecFileStream, *___2104, ___2749+nodeShift, ___2182, &InputIsOk)-nodeShift; } if (!SkipNodemap) ___2707[___2165] = M; } } } if (*___2104 >= 101 && InputIsOk) { ___1172 SharedZone = ConnectivitySharesFromZone[___734];
if (SharedZone == -1 && ___1441[___734] != 0) { ___2227 Connection = 0; while (Connection < ___1441[___734] && InputIsOk) { (void)___1750<int32_t>(ReadTecFileStream, *___2104, -___2182, ___2182, &InputIsOk); if (!InputIsOk) ___1177(___4217("Unexpected end-of-file while reading face neighbor data.")); (void)___1750<int32_t>(ReadTecFileStream, *___2104, -___2182, ___2182, &InputIsOk); if (InputIsOk) { ___478(CurZoneSpec->___1440 == ___1290  || CurZoneSpec->___1440 == ___1289 || CurZoneSpec->___1440 == ___1287 || CurZoneSpec->___1440 == ___1286); if (CurZoneSpec->___1440 == ___1290) (void)___1750<int32_t>(ReadTecFileStream, *___2104, ___2749, ___2182, &InputIsOk); else (void)___1750<int32_t>(ReadTecFileStream, *___2104, -___2182, ___2182, &InputIsOk); if (CurZoneSpec->___1440 != ___1290 && InputIsOk) { ___2227 NumAssociations = 0; if (CurZoneSpec->___1440 == ___1289) { NumAssociations = ___1750<int32_t>(ReadTecFileStream, *___2104, 0, ___2182, &InputIsOk); } else if (CurZoneSpec->___1440 == ___1287) { (void)___1750<int32_t>(ReadTecFileStream, *___2104, ___2749, ___2182, &InputIsOk); } else { ___478(CurZoneSpec->___1440 == ___1286); NumAssociations = ___1750<int32_t>(ReadTecFileStream, *___2104, 0, ___2182, &InputIsOk); } if (CurZoneSpec->___1440 != ___1287 && InputIsOk) { ___2227 Assoc; if (CurZoneSpec->___1440 == ___1289) { for (Assoc = 0; Assoc < NumAssociations && InputIsOk; Assoc++) (void)___1750<int32_t>(ReadTecFileStream, *___2104, ___2749, ___2182, &InputIsOk); } else { ___478(CurZoneSpec->___1440 == ___1286); for (Assoc = 0; Assoc < NumAssociations && InputIsOk; Assoc++) { (void)___1750<int32_t>(ReadTecFileStream, *___2104, ___2750, ___2382, &InputIsOk); (void)___1750<int32_t>(ReadTecFileStream, *___2104, ___2749, ___2182, &InputIsOk); } } if (InputIsOk) Connection += NumAssociations; } else if (InputIsOk) Connection += 1; } else if (InputIsOk) Connection += 1; if (!InputIsOk) ___1177(___4217("Corrupt input file: invalid face neighbors.")); } } } } if (ZoneIsFEPoly                              && *___2104 >= 110                          && ConnectivitySharesFromZone[___734] != -1 && InputIsOk) { if (!InBlockFormat) { ___1177(___4217("Poly zones must be in block format")); InputIsOk = ___1305; } if (InputIsOk) { ___2227 ___2806 = CurZoneSpec->___2832; if (*___2104 == 110) { CurZoneSpec->___2805      = ___1750<int32_t>(ReadTecFileStream, *___2104, 0, ___2182, &InputIsOk); CurZoneSpec->___2799 = ___1750<int32_t>(ReadTecFileStream, *___2104, 0, ___2182, &InputIsOk); CurZoneSpec->___2800 = ___1750<int32_t>(ReadTecFileStream, *___2104, 0, ___2182, &InputIsOk); } ___2227 ___4193  = CurZoneSpec->___2805; ___2227 TotalNumBndryFaces = CurZoneSpec->___2799; ___2227 TotalNumBndryItems = CurZoneSpec->___2800; if (CurZoneSpec->___4236 == ___4699) ___3292(ReadTecFileStream, ___1305, NULL, 0, ___2806 + 1, &InputIsOk); if (InputIsOk) ___3292(ReadTecFileStream, ___1305, NULL, 0, ___4193, &InputIsOk); if (InputIsOk) ___3292(ReadTecFileStream, ___1305, NULL, 0, ___2806, &InputIsOk); if (InputIsOk) ___3292(ReadTecFileStream, ___1305, NULL, 0, ___2806, &InputIsOk); if (TotalNumBndryFaces > 0) { if (InputIsOk) ___3292(ReadTecFileStream, ___1305, NULL, 0, TotalNumBndryFaces + 1, &InputIsOk); if (InputIsOk) ___3292(ReadTecFileStream, ___1305, NULL, 0, TotalNumBndryItems, &InputIsOk); if (InputIsOk) { if (*___2104 >= 112) ___3292(ReadTecFileStream, ___1305, NULL, 0, TotalNumBndryItems, &InputIsOk); else ___3290(ReadTecFileStream, ___1305, NULL, 0, TotalNumBndryItems, &InputIsOk); } } } } } else { ___1177(___4217("Corrupt input file")); InputIsOk = ___1305; } } if (VarSharesFromZone) ___1530(VarSharesFromZone, "VarSharesFromZone"); if (___2076) ___1530(___2076, "IsVarPassive"); if (ConnectivitySharesFromZone) ___1530(ConnectivitySharesFromZone, "ConnectivitySharesFromZone"); if (VarType) ___1530(VarType, "VarType"); if (!InputIsOk && !RawDataSpaceAllocated) { int ___1832; if (*___4395) { for (___1832 = 0; ___1832 < *___2847*(*NumVars); ___1832++) { if ((*___4395)[___1832]) ___1530((*___4395)[___1832], "vdatabase array"); } ___1530(*___4395, "vdatabase pointer array"); } if (*___2724) { for (___1832 = 0; ___1832 < *___2847; ___1832++) { if ((*___2724)[___1832]) ___1530((*___2724)[___1832], "connectivity list"); } ___1530(*___2724, "connectivity pointer array"); } } } if (___1441 != NULL) ___1530(___1441, "FNNumBndryConns");
if (___4682) ArrayListDealloc(&___4682, ___4681, 0); if (ReadTecFileStream) { ___4195(ReadTecFileStream->File); free(ReadTecFileStream); } return (InputIsOk); } void* STDCALL ___3957(size_t size) { return (void *)___23(size, char, "TecAlloc"); } void STDCALL ___3968(void *___3251) { char *Tmp = (char *)___3251; ___1530(Tmp, "TecAlloc"); }
