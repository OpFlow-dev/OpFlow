#include "FieldData.h"
#include <float.h>
#include <algorithm>
namespace tecplot { namespace ___3933 { ___1352::___1352( ___37* tecUtil, ___1172  zone, ___1172  ___4336, bool        writable, bool        ___964) : m_tecUtil(tecUtil) , m_fieldData(0) , m_rawDataPtr(0) , m_getFieldValue(0) , m_setFieldValue(0) , ___2459(___1369) , ___2669(___4329) , ___2668(0) , m_allocated(false) { REQUIRE(VALID_REF(tecUtil)); REQUIRE(m_tecUtil->___896()); REQUIRE(zone > 0 && m_tecUtil->___4638(zone)); REQUIRE(___4336  > 0 && m_tecUtil->___4353(___4336)); REQUIRE(IMPLICATION(___964, !writable)); bool ___2039 = true; if (___964) { ___478(!writable); m_fieldData  = m_tecUtil->___916(zone, ___4336); m_rawDataPtr = NULL; if (!m_fieldData) ___2039 = false; } else { if (writable) { m_fieldData = m_tecUtil->___924(zone, ___4336); if (m_fieldData) m_tecUtil->___925(zone, ___4336, &m_rawDataPtr, &___2459); else ___2039 = false; } else { m_fieldData = m_tecUtil->___917(zone, ___4336); if (m_fieldData) m_tecUtil->___919(zone, ___4336, &m_rawDataPtr, &___2459); else ___2039 = false; } } if (___2039) { if (m_rawDataPtr != NULL) { m_getFieldValue = NULL; m_setFieldValue = NULL; } else { m_getFieldValue = m_tecUtil->___927(m_fieldData); if (writable) m_setFieldValue = m_tecUtil->___928(m_fieldData); else m_setFieldValue = NULL; ___2459 = m_tecUtil->___920(m_fieldData); } if (___964) { ValueLocation_e ___4326 = m_tecUtil->___910(zone, ___4336); if (___4326 == ___4328) ___2669 = ___4330; else ___2669 = ___4328; } else { ___2669 = m_tecUtil->___910(zone, ___4336); } ___1844 ___1843; m_tecUtil->___4615(zone, ___1843); if (m_tecUtil->___4640(zone)) { if (___2669 == ___4328) ___2668 = ___1843.___2105(); else ___2668 = ___1843.i(); } else { if (___2669 == ___4328) { ___2227 finalNumIPts = ___1843.i(); ___2227 finalNumJPts = ___1843.___2105(); ___2227 finalNumKPts = ___1843.___2134(); if (___1843.___2134() > 1) finalNumKPts--; else if (___1843.___2105() > 1) finalNumJPts--; else if (___1843.i() > 1) finalNumIPts--; ___2668 = (finalNumIPts * finalNumJPts * finalNumKPts); } else { ___2668 = (___1843.i() * ___1843.___2105() * ___1843.___2134()); } } } if (!___2039) { *this = ___1352(); } ENSURE(IMPLICATION(___2039, ___2067())); } void ___1352::allocate( FieldDataType_e ___1363, ValueLocation_e ___4326, ___2227 ___4325) { size_t        Size = 1; REQUIRE(VALID_ENUM(___1363, FieldDataType_e)); REQUIRE(VALID_ENUM(___4326, ValueLocation_e)); REQUIRE(___4325 > 0); switch (___1363) { case FieldDataType_Float: Size = ___2668 * sizeof(float); break; case FieldDataType_Double: Size = ___2668 * sizeof(double); break; case FieldDataType_Int32: Size = ___2668 * sizeof(long); break; case FieldDataType_Int16: Size = ___2668 * sizeof(short); break; case FieldDataType_Byte: Size = (size_t)___2668; break; case ___1365: Size = (size_t)numBytesForNumBits(___2668); break; default: ___478(___1305); break; } m_rawDataPtr = malloc(Size); m_fieldData = NULL; m_getFieldValue = NULL; m_setFieldValue = NULL; if (m_rawDataPtr) { ___2459 = ___1363; ___2669 = ___4326; ___2668 = ___4325; m_allocated = true; } else { *this = ___1352(); } } void ___1352::___1759(double* minVal, double* maxVal) const { REQUIRE(___2067()); REQUIRE(VALID_REF(minVal)); REQUIRE(VALID_REF(maxVal)); m_tecUtil->___912(m_fieldData, minVal, maxVal); } }}
